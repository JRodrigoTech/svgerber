// Generated by CoffeeScript 1.7.1
(function() {
  var Fill, LayerObject, Pad, PathObject, Trace, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  LayerObject = (function() {
    function LayerObject(params) {
      var key, value;
      if (params == null) {
        params = {};
      }
      for (key in params) {
        value = params[key];
        this["" + key] = value;
      }
    }

    LayerObject.prototype.print = function() {
      var key, value, _results;
      _results = [];
      for (key in params) {
        value = params[key];
        _results.push(console.log("" + key + ": " + value));
      }
      return _results;
    };

    LayerObject.prototype.draw = function(svgItem) {
      return svgItem.bbox();
    };

    return LayerObject;

  })();

  Pad = (function(_super) {
    __extends(Pad, _super);

    function Pad() {
      return Pad.__super__.constructor.apply(this, arguments);
    }

    Pad.prototype.print = function() {
      return console.log("" + this.tool.shape + " pad created at " + this.x + ", " + this.y);
    };

    Pad.prototype.draw = function(drawing) {
      var h, m, p, pad;
      pad = null;
      switch (this.tool.shape) {
        case 'C':
          pad = drawing.circle(this.tool.dia);
          pad.center(this.x, this.y);
          break;
        case 'R':
          pad = drawing.rect(this.tool.sizeX, this.tool.sizeY);
          pad.center(this.x, this.y);
          break;
        case 'O':
          console.log("obround pad");
          break;
        case 'P':
          console.log("polygon pad");
          break;
        default:
          console.log("unrecognized shape");
      }
      if (this.tool.holeX != null) {
        p = pad.clone().fill({
          color: '#fff'
        });
        h = null;
        if (this.tool.holeY != null) {
          h = drawing.rect(this.tool.holeX, this.tool.holeY);
        } else {
          h = drawing.circle(this.tool.holeX);
        }
        h.center(pad.cx(), pad.cy()).fill({
          color: '#000'
        });
        m = drawing.mask().add(p).add(h);
        pad.maskWith(m);
      }
      return Pad.__super__.draw.call(this, pad);
    };

    return Pad;

  })(LayerObject);

  PathObject = (function(_super) {
    __extends(PathObject, _super);

    function PathObject() {
      return PathObject.__super__.constructor.apply(this, arguments);
    }

    PathObject.prototype.pathArrayToString = function(pathArray) {
      var pathString;
      return pathString = pathArray.join(' ');
    };

    return PathObject;

  })(LayerObject);

  Trace = (function(_super) {
    __extends(Trace, _super);

    function Trace() {
      return Trace.__super__.constructor.apply(this, arguments);
    }

    Trace.prototype.print = function() {
      return console.log("trace created from " + this.x + ", " + this.y + " to " + this.coord.x + ", " + this.coord.y);
    };

    Trace.prototype.draw = function(drawing) {
      var path;
      path = this.pathArrayToString(this.pathArray);
      path = drawing.path(path);
      if (this.tool.dia != null) {
        path.stroke({
          width: this.tool.dia,
          linecap: 'round'
        });
      } else {
        throw "rectangular trace apertures unimplimented in this reader";
      }
      path.fill({
        color: 'transparent'
      });
      return Trace.__super__.draw.call(this, path);
    };

    return Trace;

  })(PathObject);

  Fill = (function(_super) {
    __extends(Fill, _super);

    function Fill() {
      return Fill.__super__.constructor.apply(this, arguments);
    }

    Fill.prototype.draw = function(drawing) {
      var path;
      path = this.pathArrayToString(this.pathArray);
      path = drawing.path(path);
      path.fill({
        color: '#000'
      }).stroke({
        width: 0
      });
      return Fill.__super__.draw.call(this, path);
    };

    return Fill;

  })(PathObject);

  root.Layer = (function() {
    function Layer(name) {
      this.name = name;
      this.layerObjects = [];
    }

    Layer.prototype.setUnits = function(u) {
      if (u === 'in') {
        return this.units = 'in';
      } else if (u === 'mm') {
        return this.units = 'mm';
      }
    };

    Layer.prototype.addTrace = function(params) {
      var t;
      if (!(params.tool.shape === 'C' || params.tool.shape === 'R')) {
        throw "cannot create trace with " + tool.shape + " (tool " + tool.code + ")";
      }
      if (params.tool.holeX != null) {
        throw "cannot create trace with a holed tool (tool " + tool.code + ")";
      }
      t = new Trace(params);
      return this.layerObjects.push(t);
    };

    Layer.prototype.addPad = function(params) {
      var p;
      p = new Pad(params);
      return this.layerObjects.push(p);
    };

    Layer.prototype.addFill = function(params) {
      var f;
      f = new Fill(params);
      return this.layerObjects.push(f);
    };

    Layer.prototype.draw = function(id) {
      var box, group, o, svg, _i, _len, _ref;
      console.log("objects to draw: " + this.layerObjects.length);
      svg = SVG(id);
      group = svg.group();
      _ref = this.layerObjects;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        o.draw(group);
      }
      box = group.bbox();
      svg.size("" + box.width + this.units, "" + box.height + this.units).viewbox(0, 0, box.width, box.height);
      group.transform({
        x: -box.x,
        y: box.y2,
        scaleY: -1
      });
      return svg;
    };

    return Layer;

  })();

}).call(this);
