// Generated by CoffeeScript 1.7.1
(function() {
  var Fill, LayerObject, Pad, Trace, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  LayerObject = (function() {
    function LayerObject(tool, x, y, coord) {
      this.tool = tool;
      this.x = x;
      this.y = y;
      this.coord = coord != null ? coord : null;
      this.print();
    }

    return LayerObject;

  })();

  Pad = (function(_super) {
    __extends(Pad, _super);

    function Pad() {
      return Pad.__super__.constructor.apply(this, arguments);
    }

    Pad.prototype.print = function() {
      return console.log("" + this.tool.shape + " pad created at " + this.x + ", " + this.y);
    };

    Pad.prototype.getRange = function() {
      return [this.x, this.y];
    };

    Pad.prototype.draw = function(drawing, origin, canvas, units) {
      var h, m, moveX, moveY, p, pad, x, y;
      pad = null;
      x = this.x - origin.x + canvas.margin;
      x = "" + x + units;
      y = canvas.height - (this.y - origin.y) + canvas.margin;
      y = "" + y + units;
      switch (this.tool.shape) {
        case 'C':
          pad = drawing.circle("" + this.tool.params.dia + units);
          pad.center(x, y);
          break;
        case 'R':
          pad = drawing.rect("" + this.tool.params.sizeX + units, "" + this.tool.params.sizeY + units);
          moveX = "" + (parseFloat(x) - this.tool.params.sizeX / 2) + units;
          moveY = "" + (parseFloat(y) - this.tool.params.sizeY / 2) + units;
          pad.move(moveX, moveY);
          break;
        case 'O':
          console.log("obround pad");
          break;
        case 'P':
          console.log("polygon pad");
          break;
        default:
          console.log("unrecognized shape");
      }
      if (this.tool.params.holeX != null) {
        p = pad.clone().fill({
          color: '#fff'
        });
        h = null;
        if (this.tool.params.holeY != null) {
          h = drawing.rect(this.tool.params.holeX, this.tool.params.holeY);
        } else {
          h = drawing.circle(this.tool.params.holeX);
        }
        h.center(pad.cx(), pad.cy()).fill({
          color: '#000'
        });
        m = drawing.mask().add(p).add(h);
        return pad.maskWith(m);
      }
    };

    return Pad;

  })(LayerObject);

  Trace = (function(_super) {
    __extends(Trace, _super);

    function Trace() {
      return Trace.__super__.constructor.apply(this, arguments);
    }

    Trace.prototype.print = function() {
      return console.log("trace created from " + this.x + ", " + this.y + " to " + this.coord.x + ", " + this.coord.y);
    };

    Trace.prototype.getRange = function() {
      return [this.x, this.y, this.coord.x, this.coord.y];
    };

    Trace.prototype.draw = function(drawing, origin, canvas, units) {
      var trace, x1, x2, y1, y2;
      trace = null;
      x1 = this.x - origin.x + canvas.margin;
      x2 = this.coord.x - origin.x + canvas.margin;
      x1 = "" + x1 + units;
      x2 = "" + x2 + units;
      y1 = canvas.height - (this.y - origin.y) + canvas.margin;
      y2 = canvas.height - (this.coord.y - origin.y) + canvas.margin;
      y1 = "" + y1 + units;
      y2 = "" + y2 + units;
      if (this.tool.shape === 'C') {
        trace = drawing.line();
        trace.stroke({
          width: "" + this.tool.params.dia + units,
          linecap: 'round'
        });
        return trace.plot(x1, y1, x2, y2);
      } else if (this.tool.shape === 'R') {
        return console.log("fancy trace");
      }
    };

    return Trace;

  })(LayerObject);

  Fill = (function(_super) {
    __extends(Fill, _super);

    function Fill(path) {
      this.path = path;
    }

    Fill.prototype.draw = function(drawing, origin, canvas, units) {
      var drawPath, index, p, path, _i, _len, _ref;
      console.log('drawing fill');
      drawPath = '';
      index = 0;
      while (index < this.path.length) {
        if (this.path[index] === 'M') {
          drawPath += 'M';
          index++;
          drawPath += "" + (this.path[index] - origin.x + canvas.margin) + " ";
          index++;
          drawPath += "" + (canvas.height - (this.path[index] - origin.y) + canvas.margin);
          index++;
        } else if (this.path[index] === 'L') {
          drawPath += 'L';
          index++;
          drawPath += "" + (this.path[index] - origin.x + canvas.margin) + " ";
          index++;
          drawPath += "" + (canvas.height - (this.path[index] - origin.y) + canvas.margin);
          index++;
        } else if (this.path[index] === 'A') {
          _ref = this.path.slice(index, index + 5);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            p = _ref[_i];
            drawPath += "" + p + " ";
          }
          index += 5;
          drawPath += "" + (this.path[index] - origin.x + canvas.margin) + " ";
          index++;
          drawPath += "" + (canvas.height - (this.path[index] - origin.y) + canvas.margin);
          index++;
        } else if (this.path[index] === 'Z') {
          drawPath += 'Z';
          index++;
        } else {
          throw "unrecognized path command " + this.path[index];
        }
      }
      path = drawing.path(drawPath);
      path.fill({
        color: '#000'
      });
      return path.stroke({
        width: 0
      });
    };

    return Fill;

  })(LayerObject);

  root.Layer = (function() {
    function Layer(name) {
      this.name = name;
      this.layerObjects = [];
      this.minX = null;
      this.minY = null;
      this.maxX = null;
      this.maxY = null;
    }

    Layer.prototype.setUnits = function(u) {
      if (u === 'in') {
        return this.units = 'in';
      } else if (u === 'mm') {
        return this.units = 'mm';
      }
    };

    Layer.prototype.getSize = function() {
      return [this.minX, this.maxX, this.minY, this.maxY];
    };

    Layer.prototype.addTrace = function(tool, startX, startY, c) {
      var i, m, t, _i, _len, _ref, _results;
      if (!(tool.shape === 'C' || tool.shape === 'R')) {
        throw "cannot create trace with " + tool.shape + " (tool " + tool.code + ")";
      }
      if (tool.holeX != null) {
        throw "cannot create trace with a holed tool (tool " + tool.code + ")";
      }
      t = new Trace(tool, startX, startY, c);
      this.layerObjects.push(t);
      _ref = t.getRange();
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        m = _ref[i];
        if (i % 2 === 0) {
          if ((this.minX == null) || (m < this.minX)) {
            _results.push(this.minX = m);
          } else if ((this.maxX == null) || (m > this.maxX)) {
            _results.push(this.maxX = m);
          } else {
            _results.push(void 0);
          }
        } else {
          if ((this.minY == null) || (m < this.minY)) {
            _results.push(this.minY = m);
          } else if ((this.maxY == null) || (m > this.maxY)) {
            _results.push(this.maxY = m);
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    };

    Layer.prototype.addPad = function(tool, x, y) {
      var i, m, p, _i, _len, _ref, _results;
      p = new Pad(tool, x, y);
      this.layerObjects.push(p);
      _ref = p.getRange();
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        m = _ref[i];
        if (i % 2 === 0) {
          if ((this.minX == null) || (m < this.minX)) {
            _results.push(this.minX = m);
          } else if ((this.maxX == null) || (m > this.maxX)) {
            _results.push(this.maxX = m);
          } else {
            _results.push(void 0);
          }
        } else {
          if ((this.minY == null) || (m < this.minY)) {
            _results.push(this.minY = m);
          } else if ((this.maxY == null) || (m > this.maxY)) {
            _results.push(this.maxY = m);
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    };

    Layer.prototype.addFill = function(path) {
      var f;
      f = new Fill(path);
      return this.layerObjects.push(f);
    };

    Layer.prototype.addObject = function(action, tool, params) {
      var i, m, p, t, _i, _j, _len, _len1, _ref, _ref1;
      switch (action) {
        case 'T':
          t = new Trace(tool, params);
          _ref = t.getRange();
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            m = _ref[i];
            if (i % 2 === 0) {
              if ((this.minX == null) || (m < this.minX)) {
                this.minX = m;
              } else if ((this.maxX == null) || (m > this.maxX)) {
                this.maxX = m;
              }
            } else {
              if ((this.minY == null) || (m < this.minY)) {
                this.minY = m;
              } else if ((this.maxY == null) || (m > this.maxY)) {
                this.maxY = m;
              }
            }
          }
          return this.layerObjects.push(t);
        case 'P':
          p = new Pad(tool, params);
          _ref1 = p.getRange();
          for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
            m = _ref1[i];
            if (i % 2 === 0) {
              if ((this.minX == null) || (m < this.minX)) {
                this.minX = m;
              } else if ((this.maxX == null) || (m > this.maxX)) {
                this.maxX = m;
              }
            } else {
              if ((this.minY == null) || (m < this.minY)) {
                this.minY = m;
              } else if ((this.maxY == null) || (m > this.maxY)) {
                this.maxY = m;
              }
            }
          }
          return this.layerObjects.push(p);
        case 'F':
          return console.log("create a fill or something");
        default:
          throw "" + action + "_IsInvalidInputTo_Layer::addObject_Error";
      }
    };

    Layer.prototype.draw = function(id) {
      var canvas, o, origin, svg, _i, _len, _ref, _results;
      console.log("drawing layer origin at " + this.minX + ", " + this.minY);
      console.log("objects to draw: " + this.layerObjects.length);
      origin = {
        x: this.minX,
        y: this.minY
      };
      canvas = {
        width: this.maxX - this.minX,
        height: this.maxY - this.minY,
        margin: 0.5
      };
      svg = SVG(id).size("" + (2 * canvas.margin + canvas.width) + this.units, "" + (2 * canvas.margin + canvas.height) + this.units);
      _ref = this.layerObjects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.draw(svg, origin, canvas, this.units));
      }
      return _results;
    };

    return Layer;

  })();

}).call(this);

//# sourceMappingURL=layer.map
