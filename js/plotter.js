// Generated by CoffeeScript 1.7.1
(function() {
  var root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Plotter = (function() {
    function Plotter(gerber, name) {
      this.gerber = gerber;
      this.name = name;
      this.index = 0;
      this.line = 1;
      this.end = false;
      this.layer = new Layer(this.name);
      this.format = {
        set: false,
        zero: null,
        notation: null,
        int: null,
        dec: null
      };
      this.units = null;
      this.tools = {};
      this.polarity = 'D';
      this.tool = null;
      this.position = {
        x: 0,
        y: 0
      };
      this.mode = {
        int: null,
        quad: null,
        region: false
      };
      this.path = {
        current: null,
        startX: null,
        startY: null
      };
    }

    Plotter.prototype.plot = function() {
      var block, next;
      while (!(this.end || this.index >= this.gerber.length)) {
        next = this.gerber[this.index];
        if (next === '%') {
          this.readParameter();
        } else {
          console.log("data block found at line " + this.line);
          block = this.readBlock();
          console.log("block found: " + block);
          while (block.length > 0) {
            if (block.match(/^M0?2$/)) {
              console.log("end of file at line " + (this.line - 1));
              this.end = true;
              block = '';
            } else if (block.match(/^G[01234579][0-7]?/)) {
              console.log("state command at line " + (this.line - 1));
              block = this.processState(block);
            } else if (block.match(/D[0-9]\d*$/)) {
              console.log("operation command at line " + (this.line - 1));
              block = this.operate(block);
            } else {
              console.log("don't know what to do with " + block + " at line " + (this.line - 1));
              block = '';
            }
          }
        }
      }
      this.finishPath();
      this.layer.setUnits(this.units);
      return this.layer;
    };

    Plotter.prototype.processState = function(command) {
      var g;
      console.log("changing plotter state given " + command);
      g = command.match(/^G[01234579][0-7]?/);
      if (g != null) {
        g = g[0];
      } else {
        throw "error: " + command + " is not a valid state command";
      }
      switch (g) {
        case 'G1':
        case 'G01':
          this.mode.int = 1;
          console.log("interpolation mode set to linear");
          break;
        case 'G2':
        case 'G02':
          this.mode.int = 2;
          console.log("interpolation mode set to clockwise arc");
          break;
        case 'G3':
        case 'G03':
          this.mode.int = 3;
          console.log("interpolation mode set to counter clockwise arc");
          break;
        case 'G4':
        case 'G04':
          console.log("comment; ignoring");
          command = '';
          break;
        case 'G36':
          this.mode.region = true;
          console.log("region mode on");
          break;
        case 'G37':
          this.finishPath();
          this.mode.region = false;
          console.log("region mode off");
          break;
        case 'G74':
          this.mode.quad = 74;
          console.log("quadrant mode set to single");
          break;
        case 'G75':
          this.mode.quad = 75;
          console.log("quadrant mode set to multiple");
          break;
        case 'G54':
        case 'G55':
        case 'G70':
        case 'G71':
        case 'G90':
        case 'G91':
          console.log("deprecated command " + g + "; ignoring");
          break;
        default:
          throw "error at " + this.line + ": " + g + " is unrecognized";
      }
      if (command.length > g.length) {
        return command.slice(g.length);
      } else {
        return '';
      }
    };

    Plotter.prototype.operate = function(command) {
      var d;
      console.log("operating the plotter given " + command);
      d = command.match(/D[0-9]\d*$/);
      if (d != null) {
        d = d[0];
      } else {
        throw "error: " + command + " is not a valid operation command";
      }
      switch (d) {
        case 'D1':
        case 'D01':
          console.log('interpolate operation found');
          this.interpolate(this.getCoordinates(command));
          break;
        case 'D2':
        case 'D02':
          console.log('move operation found');
          this.move(this.getCoordinates(command));
          break;
        case 'D3':
        case 'D03':
          console.log('flash operation found');
          this.flash(this.getCoordinates(command));
          break;
        default:
          console.log('change tool command found');
          this.changeTool(d);
      }
      return '';
    };

    Plotter.prototype.getCoordinates = function(command) {
      var c;
      c = {};
      c.x = command.match(/X[+-]?\d+/);
      if (c.x != null) {
        c.x = this.parseCoordinate(c.x[0].slice(1));
      } else {
        c.x = this.position.x;
      }
      c.y = command.match(/Y[+-]?\d+/);
      if (c.y != null) {
        c.y = this.parseCoordinate(c.y[0].slice(1));
      } else {
        c.y = this.position.y;
      }
      c.i = command.match(/I[+-]?\d+/);
      if (c.i != null) {
        c.i = this.parseCoordinate(c.i[0].slice(1));
      } else if (this.mode.int !== 1) {
        c.i = 0;
      }
      c.j = command.match(/J[+-]?\d+/);
      if (c.j != null) {
        c.j = this.parseCoordinate(c.j[0].slice(1));
      } else if (this.mode.int !== 1) {
        c.j = 0;
      }
      return c;
    };

    Plotter.prototype.parseCoordinate = function(coord) {
      var negative, sign;
      negative = false;
      sign = '+';
      if (coord[0] === '-' || coord[0] === '+') {
        sign = coord[0];
        coord = coord.slice(1);
      }
      if (this.format.zero === 'L') {
        while (coord.length <= this.format.dec) {
          coord = '0' + coord;
        }
        coord = coord.slice(0, -this.format.dec) + '.' + coord.slice(-this.format.dec);
      } else if (this.format.zero === 'T') {
        while (coord.length <= this.format.int + 1) {
          coord = +'0';
        }
        coord = coord.slice(0, this.format.int) + '.' + coord.slice(this.format.int);
      }
      return coord = parseFloat(sign + coord);
    };

    Plotter.prototype.finishPath = function() {
      if (this.path.current != null) {
        if (this.mode.region === false) {
          this.layer.addTrace({
            tool: this.tool,
            pathArray: this.path.current
          });
        } else if (abs(this.position.x - this.path.startX) < 0.0000001 && abs(this.position.y - this.path.startY) < 0.0000001) {
          this.path.current.push('Z');
          this.layer.addFill({
            pathArray: this.path.current
          });
          this.path.startX = null;
          this.path.startY = null;
        } else {
          throw "error at " + this.line + ": region close command on open contour";
        }
        return this.path.current = null;
      }
    };

    Plotter.prototype.interpolate = function(c) {
      var cenX, largeArcFlag, r, sweepFlag, theta, xAxisRot;
      if (this.path.current == null) {
        this.path.current = ['M', this.position.x, this.position.y];
        this.path.startX = this.position.x;
        this.path.startY = this.position.y;
      }
      if (this.mode.int === 1) {
        this.path.current.push('L', c.x, c.y);
      } else if (this.mode.int === 2 || this.mode.int === 3) {
        if (!(this.tool.shape === 'C' && (this.tool.holeX == null))) {
          throw "error at " + this.line + ": arcs may only be drawn with a solid circular aperture";
        }
        r = Math.sqrt(Math.pow(c.i, 2) + Math.pow(c.j, 2));
        xAxisRot = 0;
        sweepFlag = this.mode.int - 2;
        largeArcFlag = 0;
        if (this.mode.quad === 75) {
          cenX = this.position.x + c.i;
          theta = Math.acos((c.x - cenX) / r);
          if (theta >= Math.PI) {
            largeArcFlag = 1;
          }
          if ((Math.abs(this.position.x - c.x) < 0.000001) && (Math.abs(this.position.y - c.y) < 0.000001)) {
            this.path.current.push('A', r, r, xAxisRot, largeArcFlag, sweepFlag, c.x + 2 * c.i, c.y + 2 * c.j);
          }
        }
        this.path.current.push('A', r, r, xAxisRot, largeArcFlag, sweepFlag, c.x, c.y);
      } else {
        throw "error at #@{line}: interpolation command without setting mode with G1/2/3";
      }
      return this.moveTo(c);
    };

    Plotter.prototype.move = function(c) {
      this.finishPath();
      return this.moveTo(c);
    };

    Plotter.prototype.moveTo = function(c) {
      this.position.x = c.x;
      this.position.y = c.y;
      return console.log("moved to " + c.x + ", " + c.y);
    };

    Plotter.prototype.flash = function(c) {
      if (this.mode.region === true) {
        throw "error at " + this.line + ": cannot flash (D03) in region mode";
      }
      if (this.tool == null) {
        throw "error at " + this.line + ": no tool selected for flash";
      }
      this.layer.addPad({
        tool: this.tool,
        x: c.x,
        y: c.y
      });
      return this.moveTo(c);
    };

    Plotter.prototype.readBlock = function() {
      var block;
      block = '';
      while (this.gerber[this.index] !== '*') {
        if (this.gerber[this.index] === '\n') {
          this.line++;
        } else {
          block += this.gerber[this.index];
        }
        this.index++;
      }
      while (this.gerber[this.index] === '*' || this.gerber[this.index] === '\n' || this.gerber[this.index] === '\r') {
        if (this.gerber[this.index] === '\n') {
          this.line++;
        }
        this.index++;
      }
      return block;
    };

    Plotter.prototype.readParameter = function() {
      var block, c, command, param, _results;
      c = '';
      while (c !== '%') {
        block = this.readBlock();
        param = block.slice(1, 3);
        command = block.slice(3);
        switch (param) {
          case 'FS':
            console.log("format command at line " + this.line + ": " + block);
            this.setFormat(command);
            break;
          case 'MO':
            console.log("unit mode command at line " + this.line + ": " + block);
            this.setUnitMode(command);
            break;
          case 'AD':
            console.log("aperture definition at line " + this.line + ": " + block);
            this.createTool(command);
            break;
          case 'AM':
            console.log("aperture macro at line " + this.line + ": " + block);
            break;
          case 'SR':
            console.log("step repeat command at line " + this.line + ": " + block);
            break;
          case 'LP':
            console.log("level polarity at line " + this.line + ": " + block);
            this.setPolarity;
        }
        c = this.gerber[this.index];
      }
      console.log("done with parameter block");
      this.index++;
      _results = [];
      while (this.gerber[this.index] === '\n' || this.gerber[this.index] === '\r') {
        if (this.gerber[this.index] === '\n') {
          this.line++;
        }
        _results.push(this.index++);
      }
      return _results;
    };

    Plotter.prototype.setFormat = function(command) {
      var notation, xFormat, yFormat, zero;
      console.log("setting format according to " + command);
      if (this.format.set) {
        throw "error at " + line + ": format has already been set";
      }
      zero = command[0];
      if (zero === 'L' || zero === 'T') {
        this.format.zero = zero;
      } else {
        throw "" + zero + " at line " + this.line + " is invalid zero omission value (L or T)";
      }
      notation = command[1];
      if (notation === 'A' || notation === 'I') {
        this.format.notation = notation;
      } else {
        throw "" + notation + " at line " + this.line + " is invalid notation value (A or I)";
      }
      xFormat = command.slice(2, 5);
      yFormat = command.slice(5, 8);
      if (xFormat[0] !== 'X') {
        throw "error at " + line + ": " + xFormat[0] + " is not a valid coordinate";
      }
      if (yFormat[0] !== 'Y') {
        throw "error at " + line + ": " + yFormat[0] + " is not a valid coordinate";
      }
      if (xFormat.slice(1) !== yFormat.slice(1)) {
        throw "error at " + line + ": x format and y format don't match";
      }
      this.format.int = parseInt(xFormat[1], 10);
      this.format.dec = parseInt(xFormat[2], 10);
      if (this.format.int > 7) {
        throw "error at " + line + ": " + this.format.int + " exceeds max interger places of 7";
      }
      if (this.format.dec > 7) {
        throw "error at " + line + ": " + this.format.dec + " exceeds max decimal places of 7";
      }
      console.log("zero omission set to: " + this.format.zero + ", coordinate notation set to: " + this.format.notation + ", integer places set to " + this.format.int + ", decimal places set to " + this.format.dec);
      return this.format.set = true;
    };

    Plotter.prototype.setUnitMode = function(command) {
      console.log("setting unit mode according to " + command);
      if (this.units != null) {
        throw "error at " + this.line + ": unit mode has already been set";
      }
      if (command === 'IN') {
        this.units = 'in';
      } else if (command === 'MM') {
        this.units = 'mm';
      } else {
        throw "#error at " + this.line + ": " + command + " is not a valid unit mode (IN or MM)";
      }
      return console.log("unit mode set to: " + this.units);
    };

    Plotter.prototype.setPolarity = function(command) {
      console.log("setting polarity according to " + command);
      if (command === 'C' || command === 'D') {
        this.polarity = command;
        this.position.x = null;
        return this.position.y = null;
      } else {
        throw "error at " + this.line + ": " + command + " is not a valid polarity (C or D)";
      }
    };

    Plotter.prototype.changeTool = function(code) {
      if (this.mode.region === true) {
        throw "error at " + this.line + ": cannot change tool (Dnn) in region mode";
      }
      if (this.tools[code] == null) {
        throw "error at " + this.line + ": tool " + code + " does not exist";
      }
      this.finishPath();
      this.tool = this.tools[code];
      return console.log("tool changed to " + code);
    };

    Plotter.prototype.createTool = function(command) {
      var tool, toolCode, toolParams, toolShape;
      console.log("creating a aperture according to " + command);
      toolCode = command.slice(0, 3);
      if (!toolCode.match(/D[1-9]\d+/)) {
        throw "error at " + this.line + ": " + toolCode + " is not a valid tool number";
      }
      if (this.tools[toolCode] != null) {
        throw "error at " + this.line + ": " + toolCode + " already exists";
      }
      toolShape = command.slice(3, 5);
      toolParams = command.slice(5);
      switch (toolShape) {
        case 'C,':
          toolParams = this.getCircleToolParams(toolParams);
          break;
        case 'R,':
          toolParams = this.getRectToolParams(toolParams);
          break;
        case 'O,':
          toolParams = this.getRectToolParams(toolParams);
          break;
        case 'P,':
          toolParams = this.getPolyToolParams(toolParams);
          break;
        default:
          console.lot("tool " + toolCode + " might be a macro");
      }
      toolParams.code = toolCode;
      toolParams.shape = toolShape[0];
      tool = new Aperture(toolParams);
      this.tools[toolCode] = tool;
      return this.changeTool(toolCode);
    };

    Plotter.prototype.getCircleToolParams = function(command) {
      var numbers, params, _ref;
      numbers = this.gatherToolParams(command);
      if (!((1 <= (_ref = numbers.length) && _ref <= 3))) {
        throw "error at " + line + ": circle aperture must have between 1 and 3 params";
      }
      if (!(numbers[0] >= 0)) {
        throw "error at " + line + ": circle dia must be greater than or equal to 0";
      }
      params = {
        dia: numbers[0]
      };
      if (numbers[1] != null) {
        if (!(numbers[1] >= 0)) {
          throw "error at " + line + ": hole x size must be greater than or equal to 0";
        }
        params.holeX = numbers[1];
      }
      if (numbers[2] != null) {
        if (!(numbers[2] >= 0)) {
          throw "error at " + line + ": hole y size must be greater than or equal to 0";
        }
        params.holeY = numbers[2];
      }
      return params;
    };

    Plotter.prototype.getRectToolParams = function(command) {
      var numbers, params, _ref;
      numbers = this.gatherToolParams(command);
      if (!((2 <= (_ref = numbers.length) && _ref <= 4))) {
        throw "error at " + line + ": rect/obround aperture must have between 2 and 4 params";
      }
      if (!(numbers[0] > 0)) {
        throw "error at " + line + ": rect/obround x size must be greater than 0";
      }
      if (!(numbers[1] > 0)) {
        throw "error at " + line + ": rect/obround y size must be greater than 0";
      }
      params = {
        sizeX: numbers[0],
        sizeY: numbers[1]
      };
      if (numbers[2] != null) {
        if (!(numbers[2] >= 0)) {
          throw "error at " + line + ": hole x size must be greater than or equal to 0";
        }
        params.holeX = numbers[2];
      }
      if (numbers[3] != null) {
        if (!(numbers[3] >= 0)) {
          throw "error at " + line + ": hole y size must be greater than or equal to 0";
        }
        params.holeY = numbers[3];
      }
      return params;
    };

    Plotter.prototype.getPolyToolParams = function(command) {
      var numbers, params, _ref, _ref1;
      numbers = gatherToolParams(command);
      if (!((2 <= (_ref = numbers.length) && _ref <= 5))) {
        throw "error at " + line + ": polygon aperture must have between 2 and 4 params";
      }
      if (!(numbers[0] > 0)) {
        throw "error at " + line + ": polygon diameter must be greater than 0";
      }
      if (!((3 <= (_ref1 = numbers[1]) && _ref1 <= 12))) {
        throw "error at " + line + ": polygon must have 3 to 12 points";
      }
      params = {
        dia: numbers[0],
        points: numbers[1]
      };
      if (numbers[2] != null) {
        params.rotation = numbers[2];
      }
      if (numbers[3] != null) {
        if (!(numbers[3] >= 0)) {
          throw "error at " + line + ": hole x size must be greater than or equal to 0";
        }
        params.holeY = numbers[3];
      }
      if (numbers[4] != null) {
        if (!(numbers[4] >= 0)) {
          throw "error at " + line + ": hole y size must be greater than or equal to 0";
        }
        params.holeY = numbers[4];
      }
      return params;
    };

    Plotter.prototype.gatherToolParams = function(command) {
      var i, n, numbers, _i, _len;
      numbers = command.match(/[\+-]?[\d\.]+(?=X|$)/g);
      for (i = _i = 0, _len = numbers.length; _i < _len; i = ++_i) {
        n = numbers[i];
        if (!n.match(/^[\+-]?((\d+\.?\d*)|(\d*\.?\d+))$/)) {
          throw "error at " + line + ": " + n + " is not a valid number";
        }
        numbers[i] = parseFloat(n);
      }
      return numbers;
    };

    return Plotter;

  })();

}).call(this);

//# sourceMappingURL=plotter.map
