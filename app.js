// Generated by CoffeeScript 1.7.1
(function() {
  var Aperture, Fill, Layer, LayerObject, Pad, Plotter, Trace, fileToSVG, handleFileSelect, readFileToDiv,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Aperture = (function() {
    function Aperture(code, shape, params) {
      this.code = code;
      this.shape = shape;
      this.params = params;
      console.log("Aperture " + this.code + " was created and is a " + this.shape);
    }

    return Aperture;

  })();

  if (typeof exports !== "undefined" && exports !== null) {
    exports.Aperture = Aperture;
  }

  LayerObject = (function() {
    function LayerObject(shape, x, y, params) {
      this.shape = shape;
      this.x = x;
      this.y = y;
      this.size = null;
      this.parseParams(params);
    }

    LayerObject.prototype.parseParams = function(p) {
      switch (this.shape) {
        case 'C':
          if (p[0] == null) {
            throw "BadCircleParamsError";
          }
          return this.size = p[0];
        case 'R':
          if (!(p.length > 1)) {
            throw "BadRectParamsError";
          }
          return this.size = p.slice(0, 2);
      }
    };

    return LayerObject;

  })();

  Pad = (function(_super) {
    __extends(Pad, _super);

    function Pad() {
      return Pad.__super__.constructor.apply(this, arguments);
    }

    Pad.prototype.parseParams = function(p) {
      switch (this.shape) {
        case 'C':
          this.holeX = p[1] != null ? p[1] : null;
          this.holeY = p[2] != null ? p[2] : null;
          break;
        case 'R':
        case 'O':
          this.holeX = p[2] != null ? p[2] : null;
          this.holeY = p[3] != null ? p[3] : null;
      }
      return Pad.__super__.parseParams.call(this, p);
    };

    Pad.prototype.draw = function(drawing) {
      var h, m, p, pad;
      pad = null;
      switch (this.shape) {
        case 'C':
          console.log("circular pad at " + this.x + ", " + this.y);
          pad = drawing.circle(this.size).center(this.x, this.y);
          break;
        case 'R':
          console.log("rectangular pad at " + this.x + ", " + this.y);
          pad = drawing.rect(this.size[0], this.size[1]).center(this.x, this.y);
          break;
        case 'O':
          console.log("obround pad");
          break;
        case 'P':
          console.log("polygon pad");
          break;
        default:
          console.log("unrecognized shape");
      }
      if (this.holeX != null) {
        p = pad.clone().fill({
          color: '#fff'
        });
        h = null;
        if (this.holeY != null) {
          h = drawing.rect(this.holeX, this.holeY);
        } else {
          h = drawing.circle(this.holeX);
        }
        h.center(pad.cx(), pad.cy()).fill({
          color: '#000'
        });
        m = drawing.mask().add(p).add(h);
        return pad.maskWith(m);
      }
    };

    return Pad;

  })(LayerObject);

  Trace = (function(_super) {
    __extends(Trace, _super);

    function Trace() {
      return Trace.__super__.constructor.apply(this, arguments);
    }

    Trace.prototype.parseParams = function(p) {
      switch (this.shape) {
        case 'C':
          if (p.length !== 3) {
            throw "BadCircleTraceError";
          }
          this.end = p.slice(1, 3);
          break;
        case 'R':
          if (p.length !== 4) {
            throw "BadRectTraceError";
          }
          this.end = p.slice(2, 4);
          break;
        default:
          throw "InvalidTraceShapeError";
      }
      return Trace.__super__.parseParams.call(this, p);
    };

    Trace.prototype.draw = function(drawing) {
      var trace;
      if (this.shape === 'C') {
        trace = drawing.line();
        trace.stroke({
          width: this.size,
          linecap: 'round'
        });
        return trace.plot(this.x, this.y, this.end[0], this.end[1]);
      } else if (this.shape === 'R') {
        return console.log("fancy trace");
      }
    };

    return Trace;

  })(LayerObject);

  Fill = (function(_super) {
    __extends(Fill, _super);

    function Fill() {
      return Fill.__super__.constructor.apply(this, arguments);
    }

    return Fill;

  })(LayerObject);

  Layer = (function() {
    function Layer(name) {
      this.name = name;
      this.layerObjects = [];
    }

    Layer.prototype.addObject = function(action, tool, params) {
      var p, t;
      switch (action) {
        case 'T':
          return t = new Trace(tool.shape, tool.params);
        case 'P':
          return p = new Pad(tool.shape, tool.params);
        case 'F':
          return console.log("create a fill or something");
        default:
          throw "" + action + "_IsInvalidInputTo_Layer::addObject_Error";
      }
    };

    Layer.prototype.draw = function(id) {
      var o, svg, _i, _len, _ref, _results;
      svg = SVG(id);
      _ref = this.layerObjects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.draw(svg));
      }
      return _results;
    };

    return Layer;

  })();

  if (typeof exports !== "undefined" && exports !== null) {
    exports.Layer = Layer;
  }

  Plotter = (function() {
    function Plotter(gerberFile) {
      this.zeroOmit = null;
      this.notation = null;
      this.leadDigits = null;
      this.trailDigits = null;
      this.units = null;
      this.apertures = [];
      this.tool = null;
      this.iMode = null;
      this.aMode = null;
      this.xPos = 0;
      this.yPos = 0;
      this.gerber = gerberFile.split('\n');
      console.log("Plotter created");
    }

    Plotter.prototype.parseFormatSpec = function(fS) {
      var formatMatch, notationMatch, xDataMatch, xFormat, yDataMatch, yFormat, zeroMatch, _ref, _ref1;
      formatMatch = /^%FS.*\*%$/;
      zeroMatch = /[LT]/;
      notationMatch = /[AI]/;
      xDataMatch = /X+?\d{2}/;
      yDataMatch = /Y+?\d{2}/;
      if (!fS.match(formatMatch)) {
        throw "InputTo_parseFormatSpec_NotAFormatSpecError";
      }
      this.zeroOmit = fS.match(zeroMatch);
      if (this.zeroOmit != null) {
        this.zeroOmit = this.zeroOmit[0][0];
        console.log("zero omission set to: " + this.zeroOmit);
      } else {
        throw "NoZeroSuppressionInFormatSpecError";
      }
      this.notation = fS.match(notationMatch);
      if (this.notation != null) {
        this.notation = this.notation[0][0];
        console.log("notation set to: " + this.notation);
      } else {
        throw "NoCoordinateNotationInFormatSpecError";
      }
      xFormat = fS.match(xDataMatch);
      yFormat = fS.match(yDataMatch);
      if (xFormat != null) {
        xFormat = xFormat[0].slice(-2);
      } else {
        throw "MissingCoordinateFormatInFormatSpecError";
      }
      if (yFormat != null) {
        yFormat = yFormat[0].slice(-2);
      } else {
        throw "MissingCoordinateFormatInFormatSpecError";
      }
      if (xFormat === yFormat) {
        this.leadDigits = parseInt(xFormat[0], 10);
        this.trailDigits = parseInt(xFormat[1], 10);
      } else {
        throw "CoordinateFormatMismatchInFormatSpecError";
      }
      if (!(((0 < (_ref = this.leadDigits) && _ref < 8)) && ((0 < (_ref1 = this.trailDigits) && _ref1 < 8)))) {
        throw "InvalidCoordinateFormatInFormatSpecError";
      } else {
        return console.log("coordinate format set to: " + this.leadDigits + ", " + this.trailDigits);
      }
    };

    Plotter.prototype.parseUnits = function(u) {
      var unitMatch;
      unitMatch = /^%MO((MM)|(IN))\*%/;
      if (u.match(unitMatch)) {
        return this.units = u.slice(3, 5);
      } else {
        throw "NoValidUnitsGivenError";
      }
    };

    Plotter.prototype.parseAperture = function(a) {
      var apertureMatch, code, params, shape;
      apertureMatch = /^%AD.*$/;
      if (!a.match(apertureMatch)) {
        throw "InputTo_parseAperture_NotAnApertureError";
      }
      code = a.match(/D[1-9]\d+/);
      if (code != null) {
        code = parseInt(code[0].slice(1), 10);
      } else {
        throw "InvalidApertureToolCodeError";
      }
      shape = a.match(/[CROP].*(?=\*%$)/);
      if (shape != null) {
        shape = shape[0];
        params = ((function() {
          switch (shape[0]) {
            case "C":
            case "R":
            case "O":
              return this.parseBasicAperture(shape);
            case "P":
              throw "UnimplementedApertureError";
          }
        }).call(this));
        shape = shape[0];
      } else {
        throw "NoApertureShapeError";
      }
      return a = new Aperture(code, shape, params);
    };

    Plotter.prototype.parseBasicAperture = function(string) {
      var badInput, circle, circleMatch, i, obround, obroundMatch, p, params, rect, rectangleMatch, _i, _len;
      circleMatch = /^C,[\d\.]+(X[\d\.]+){0,2}$/;
      rectangleMatch = /^R,[\d\.]+X[\d\.]+(X[\d\.]+){0,2}$/;
      obroundMatch = /^O,[\d\.]+X[\d\.]+(X[\d\.]+){0,2}$/;
      badInput = true;
      if (((circle = string[0][0] === 'C') && string.match(circleMatch)) || ((rect = string[0][0] === 'R') && string.match(rectangleMatch)) || ((obround = string[0][0] === 'O') && string.match(obroundMatch))) {
        params = string.match(/[\d\.]+/g);
        for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
          p = params[i];
          if (p.match(/^((\d+\.?\d*)|(\d*\.?\d+))$/)) {
            params[i] = parseFloat(p);
            badInput = false;
          } else {
            badInput = true;
            break;
          }
        }
      }
      if (badInput) {
        if (circle) {
          throw "BadCircleApertureError";
        } else if (rect) {
          throw "BadRectangleApertureError";
        } else if (obround) {
          throw "BadObroundApertureError";
        }
      }
      return params;
    };

    Plotter.prototype.parseGCode = function(s) {
      var code, match;
      match = s.match(/^G\d{1,2}(?=\D)/);
      if (!match) {
        throw "InputTo_parseGCode_NotAGCodeError";
      } else {
        match = match[0];
      }
      code = parseInt(match.slice(1), 10);
      switch (code) {
        case 1:
        case 2:
        case 3:
          this.iMode = code;
          break;
        case 4:
          console.log("found a comment");
          return "";
        case 74:
        case 75:
          this.aMode = code;
          break;
        case 54:
        case 55:
          console.log("deprecated G" + code + " found");
          break;
        case 70:
          if (this.units == null) {
            console.log("warning: deprecated G70 command used to set units to in");
            this.units = 'IN';
          }
          break;
        case 71:
          if (this.units == null) {
            console.log("warning: deprecated G71 command used to set units to mm");
            this.units = 'MM';
          }
          break;
        case 90:
          if (this.notation == null) {
            console.log("warning: deprecated G90 command used to set notation to abs");
            this.notation = 'A';
          }
          break;
        case 91:
          if (this.notation == null) {
            console.log("warning: deprecated G91 command used to set notation to inc");
            this.notation = 'I';
          }
          break;
        default:
          throw "G" + code + "IsUnimplementedGCodeError";
      }
      return s.slice(match.length);
    };

    Plotter.prototype.parseCoordinate = function(coord) {
      var c;
      console.log("parsing coordinates");
      coord = coord.slice(1);
      if (this.zeroOmit === 'L') {
        console.log("coord is " + coord);
        c = coord.slice(0, +(-(this.trailDigits + 1)) + 1 || 9e9) + '.' + coord.slice(-this.trailDigits);
        console.log("c is " + c);
        return parseFloat(c);
      } else if (this.zeroOmit === 'T') {
        c = coord.slice(0, +this.leadDigits + 1 || 9e9) + '.' + coord.slice(this.leadDigits);
        return parseFloat(coord.slice(0, +this.leadDigits + 1 || 9e9) + '.' + coord.slice(this.leadDigits));
      }
    };

    Plotter.prototype.parseMove = function(line) {
      var x, y;
      x = line.match(/X[+-]?[\d]+/);
      if (x != null) {
        x = this.parseCoordinate(x[0]);
      }
      y = line.match(/Y[+-]?[\d]+/);
      if (y != null) {
        y = this.parseCoordinate(y[0]);
      }
      return this.move(x, y);
    };

    Plotter.prototype.move = function(x, y) {
      console.log("moving to " + x + ", " + y);
      this.xPos = x;
      return this.yPos = y;
    };

    Plotter.prototype.stroke = function(x, y) {
      var t;
      return t = new Trace(this.tool, this.xPos, this.yPos, [x, y]);
    };

    Plotter.prototype.flash = function(x, y) {
      return console.log;
    };

    Plotter.prototype.parseToolChange = function(line) {
      var tool;
      if (!line.match(/^D1\d+\*$/)) {
        throw "BadToolLineError";
      }
      tool = parseInt(line.slice(1, -1), 10);
      return this.changeTool(tool);
    };

    Plotter.prototype.changeTool = function(tool) {
      if (tool < 10) {
        throw "Tool_" + tool + "_IsOutOfRangeError";
      }
      return this.tool = this.apertures[tool - 10];
    };

    Plotter.prototype.plot = function() {
      var ap, apertureMatch, endMatch, fileEnd, formatMatch, gMatch, gotFormat, gotUnits, i, interpolationMode, layer, line, moveMatch, quadrantMode, toolMatch, unitMatch, _i, _len, _ref;
      gotFormat = false;
      gotUnits = false;
      fileEnd = false;
      interpolationMode = null;
      quadrantMode = null;
      formatMatch = /^%FS.*\*%$/;
      unitMatch = /^%MO((MM)|(IN))\*%$/;
      apertureMatch = /^%AD.*\*%$/;
      gMatch = /^G.*\*$/;
      endMatch = /^M0?2\*$/;
      toolMatch = /^D1\d+\*$/;
      moveMatch = /^(X[+-]?\d+)?(Y[+-]?\d+)?D0?[123]\*$/;
      layer = new Layer('layerName');
      _ref = this.gerber;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        line = _ref[i];
        if (line.match(endMatch)) {
          console.log("" + line + " indicates end of file at line: " + i);
          fileEnd = true;
          break;
        }
        if ((!gotFormat) || (!gotUnits)) {
          if (line.match(formatMatch)) {
            this.parseFormatSpec(line);
            gotFormat = true;
          } else if (line.match(unitMatch)) {
            this.parseUnits(line);
            gotUnits = true;
          }
        } else {
          if (line.match(gMatch)) {
            line = this.parseGCode(line);
          }
          if (line.match(apertureMatch)) {
            ap = this.parseAperture(line);
            if (this.apertures[ap.code - 10] == null) {
              this.apertures[ap.code - 10] = ap;
            } else {
              throw "ApertureAlreadyExistsError";
            }
          } else if (line.match(toolMatch)) {
            console.log("changing tool to " + line);
            this.parseToolChange(line);
            console.log("current tool " + this.tool.code + " is a " + this.tool.shape);
          } else if (line.match(moveMatch)) {
            this.parseMove(line);
          } else {
            console.log("don't know what " + line + " means");
          }
        }
      }
      if (!gotFormat) {
        throw "NoFormatSpecGivenError";
      }
      if (!gotUnits) {
        throw "NoValidUnitsGivenError";
      }
      if (!fileEnd) {
        throw "NoM02CommandBeforeEndError";
      }
      return layer;
    };

    return Plotter;

  })();

  if (typeof exports !== "undefined" && exports !== null) {
    exports.Plotter = Plotter;
  }

  fileToSVG = function(file) {
    var p;
    console.log('converting to svg');
    p = new Plotter(file);
    return p.plot();
  };

  readFileToDiv = function(event) {
    if (event.target.readyState === FileReader.DONE) {
      return fileToSVG(event.target.result);
    }
  };

  handleFileSelect = function(event) {
    var f, importFiles, output, reader, _i, _j, _len, _len1, _results;
    importFiles = event.target.files;
    output = [];
    for (_i = 0, _len = importFiles.length; _i < _len; _i++) {
      f = importFiles[_i];
      output.push('<li><strong>', escape(f.name), '</li>');
    }
    document.getElementById('list').innerHTML = '<ul>' + output.join('') + '</ul>';
    _results = [];
    for (_j = 0, _len1 = importFiles.length; _j < _len1; _j++) {
      f = importFiles[_j];
      reader = new FileReader();
      reader.addEventListener('loadend', readFileToDiv, false);
      _results.push(reader.readAsText(f));
    }
    return _results;
  };

  document.getElementById('files').addEventListener('change', handleFileSelect, false);

}).call(this);

//# sourceMappingURL=app.map
