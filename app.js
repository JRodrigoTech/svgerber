!function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({"./src/index.coffee":[function(a){var b,c,d,e,f;c=a("Base64"),"function"!=typeof window.btoa&&(window.btoa=c.btoa),"function"!=typeof window.atob&&(window.atob=c.atob),b=a("./views/app-view"),e=new b,d=a("./routers/router"),f=new d,Backbone.history.start()},{"./routers/router":"/Users/mc/projects/svgerber/src/routers/router.coffee","./views/app-view":"/Users/mc/projects/svgerber/src/views/app-view.coffee",Base64:"/Users/mc/projects/svgerber/node_modules/Base64/base64.js"}],"/Users/mc/projects/svgerber/node_modules/Base64/base64.js":[function(a,b,c){!function(){function a(a){this.message=a}var b="undefined"!=typeof c?c:this,d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";a.prototype=new Error,a.prototype.name="InvalidCharacterError",b.btoa||(b.btoa=function(b){for(var c,e,f=String(b),g=0,h=d,i="";f.charAt(0|g)||(h="=",g%1);i+=h.charAt(63&c>>8-g%1*8)){if(e=f.charCodeAt(g+=.75),e>255)throw new a("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");c=c<<8|e}return i}),b.atob||(b.atob=function(b){var c=String(b).replace(/=+$/,"");if(c.length%4==1)throw new a("'atob' failed: The string to be decoded is not correctly encoded.");for(var e,f,g=0,h=0,i="";f=c.charAt(h++);~f&&(e=g%4?64*e+f:f,g++%4)?i+=String.fromCharCode(255&e>>(-2*g&6)):0)f=d.indexOf(f);return i})}()},{}],"/Users/mc/projects/svgerber/src/collections/boards.coffee":[function(a,b){var c,d,e,f,g={}.hasOwnProperty,h=function(a,b){function c(){this.constructor=a}for(var d in b)g.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};e=a("./renders"),c=a("../models/board"),f=new Worker(window.URL.createObjectURL(new Blob(['(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module \'"+o+"\'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar reCOPPER, reDRILL, reEDGE, reMASK, rePASTE, reSILK, unique, uniqueId;\n\nunique = 0;\n\nuniqueId = function() {\n  return unique++;\n};\n\nreCOPPER = /cu/;\n\nreMASK = /sm/;\n\nreSILK = /ss/;\n\nrePASTE = /sp/;\n\nreEDGE = /out/;\n\nreDRILL = /drl/;\n\nmodule.exports = function(name, layers) {\n  var addVboxToBbox, attr, bbox, bboxRect, copper, cuFinishId, d, defs, draw, drill, drlId, drlMask, edge, getVboxFromBbox, key, layer, layerId, ly, mask, node, paste, silk, smId, smPos, svg, trans, u, units, val, vbox, xml, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;\n  if (layers == null) {\n    layers = [];\n  }\n  copper = null;\n  mask = null;\n  silk = null;\n  paste = null;\n  edge = null;\n  drill = [];\n  attr = {};\n  defs = [];\n  draw = [];\n  bbox = [Infinity, Infinity, -Infinity, -Infinity];\n  units = \'px\';\n  addVboxToBbox = function(v) {\n    var xMax, yMax;\n    xMax = v[2] + v[0];\n    yMax = v[3] + v[1];\n    if (v[0] < bbox[0]) {\n      bbox[0] = v[0];\n    }\n    if (v[1] < bbox[1]) {\n      bbox[1] = v[1];\n    }\n    if (xMax > bbox[2]) {\n      bbox[2] = xMax;\n    }\n    if (yMax > bbox[3]) {\n      return bbox[3] = yMax;\n    }\n  };\n  getVboxFromBbox = function() {\n    return [bbox[0], bbox[1], bbox[2] - bbox[0], bbox[3] - bbox[1]];\n  };\n  for (_i = 0, _len = layers.length; _i < _len; _i++) {\n    layer = layers[_i];\n    ly = layer.type;\n    xml = layer.svgObj;\n    if (xml.svg == null) {\n      continue;\n    }\n    addVboxToBbox(xml.svg.viewBox);\n    u = (_ref = xml.svg.width.match(/(in)|(mm)/)) != null ? _ref[0] : void 0;\n    if (units === \'px\') {\n      units = u;\n    } else if (u !== units) {\n      return {};\n    }\n    delete xml.svg.viewBox;\n    delete xml.svg.width;\n    delete xml.svg.height;\n    delete xml.svg.id;\n    _ref1 = xml.svg;\n    for (key in _ref1) {\n      val = _ref1[key];\n      if ((attr[key] == null) && key !== \'_\') {\n        attr[key] = val;\n      }\n    }\n    layerId = "" + name + "-" + ly + "_" + (uniqueId());\n    _ref2 = xml.svg._;\n    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n      node = _ref2[_j];\n      if (node.defs != null) {\n        _ref3 = node.defs._;\n        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\n          d = _ref3[_k];\n          defs.push(d);\n        }\n      } else if (node.g != null) {\n        delete node.g.transform;\n        node.g.id = layerId;\n        defs.push(node);\n      }\n    }\n    if (reCOPPER.test(ly)) {\n      copper = layerId;\n    } else if (reMASK.test(ly)) {\n      mask = layerId;\n    } else if (reSILK.test(ly)) {\n      silk = layerId;\n    } else if (rePASTE.test(ly)) {\n      paste = layerId;\n    } else if (reEDGE.test(ly)) {\n      edge = layerId;\n    } else if (reDRILL.test(ly)) {\n      drill.push(layerId);\n    }\n  }\n  if (copper == null) {\n    return {};\n  }\n  vbox = getVboxFromBbox();\n  bboxRect = function(cls, fill) {\n    if (cls == null) {\n      cls = \'Board--cover\';\n    }\n    if (fill == null) {\n      fill = \'currentColor\';\n    }\n    return {\n      rect: {\n        "class": cls,\n        fill: fill,\n        x: vbox[0],\n        y: vbox[1],\n        width: vbox[2],\n        height: vbox[3]\n      }\n    };\n  };\n  draw.push(bboxRect(\'Board--board\'));\n  draw.push({\n    use: {\n      "class": \'Board--cu\',\n      \'xlink:href\': "#" + copper\n    }\n  });\n  if (mask != null) {\n    cuFinishId = "" + name + "-sm_" + (uniqueId());\n    defs.push({\n      mask: {\n        id: cuFinishId,\n        color: \'#fff\',\n        _: [\n          {\n            use: {\n              \'xlink:href\': "#" + copper\n            }\n          }\n        ]\n      }\n    });\n    draw.push({\n      use: {\n        "class": \'Board--cf\',\n        mask: "url(#" + cuFinishId + ")",\n        \'xlink:href\': "#" + mask\n      }\n    });\n    smId = "" + name + "-sm_" + (uniqueId());\n    defs.push({\n      mask: {\n        id: smId,\n        color: \'#000\',\n        _: [\n          bboxRect(null, \'#fff\'), {\n            use: {\n              \'xlink:href\': "#" + mask\n            }\n          }\n        ]\n      }\n    });\n    smPos = {\n      g: {\n        mask: "url(#" + smId + ")",\n        _: [bboxRect(\'Board--sm\')]\n      }\n    };\n    if (silk != null) {\n      smPos.g._.push({\n        use: {\n          "class": \'Board--ss\',\n          \'xlink:href\': "#" + silk\n        }\n      });\n    }\n    draw.push(smPos);\n  }\n  if (paste != null) {\n    draw.push({\n      use: {\n        "class": \'Board--sp\',\n        \'xlink:href\': "#" + paste\n      }\n    });\n  }\n  if (edge != null) {\n    draw.push({\n      use: {\n        "class": \'Board--out\',\n        \'xlink:href\': "#" + edge\n      }\n    });\n  }\n  drlId = null;\n  if (drill.length) {\n    drlId = "" + name + "-drl_" + (uniqueId());\n    drlMask = {\n      mask: {\n        id: drlId,\n        color: \'#000\',\n        _: [bboxRect(null, \'#fff\')]\n      }\n    };\n    for (_l = 0, _len3 = drill.length; _l < _len3; _l++) {\n      d = drill[_l];\n      drlMask.mask._.push({\n        use: {\n          \'xlink:href\': "#" + d\n        }\n      });\n    }\n    defs.push(drlMask);\n  }\n  if (name === \'bottom\') {\n    trans = "translate(" + (bbox[2] + bbox[0]) + "," + (bbox[3] + bbox[1]) + ") scale(-1,-1)";\n  } else {\n    trans = "translate(0," + (bbox[3] + bbox[1]) + ") scale(1,-1)";\n  }\n  draw = {\n    g: {\n      transform: trans,\n      _: draw\n    }\n  };\n  if (drlId) {\n    draw.g.mask = "url(#" + drlId + ")";\n  }\n  svg = attr;\n  svg["class"] = \'Board\';\n  svg.viewBox = getVboxFromBbox();\n  svg.width = "" + svg.viewBox[2] + units;\n  svg.height = "" + svg.viewBox[3] + units;\n  svg._ = [];\n  if (defs.length) {\n    svg._.push({\n      defs: {\n        _: defs\n      }\n    });\n  }\n  if (draw.g._.length) {\n    svg._.push(draw);\n  }\n  return {\n    svg: svg\n  };\n};\n\n\n\n},{}],2:[function(require,module,exports){\nvar build;\n\nbuild = require(\'../build-board.coffee\');\n\nself.addEventListener(\'message\', function(e) {\n  var boardObj, layers, name;\n  name = e.data.name;\n  layers = e.data.layers;\n  boardObj = build(name, layers);\n  return self.postMessage({\n    name: name,\n    svgObj: boardObj\n  });\n}, false);\n\n\n\n},{"../build-board.coffee":1}]},{},[2])'],{type:"text/javascript"}))),d=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return h(b,a),b.prototype.model=c,b.prototype.initialize=function(){return this.attachBuilderHandler(),this.on("buildNeeded",this.buildBoard),b.__super__.initialize.call(this)},b.prototype.buildBoard=function(a){return f.postMessage({name:a.get("name"),layers:a.get("boardLayers")})},b.prototype.attachBuilderHandler=function(){var a,b;return b=this,a=function(a){return b.convert(a.data.name,a.data.svgObj)},f.addEventListener("message",a,!1)},b}(e),b.exports=d},{"../models/board":"/Users/mc/projects/svgerber/src/models/board.coffee","./renders":"/Users/mc/projects/svgerber/src/collections/renders.coffee"}],"/Users/mc/projects/svgerber/src/collections/layers.coffee":[function(a,b){var c,d,e,f={}.hasOwnProperty,g=function(a,b){function c(){this.constructor=a}for(var d in b)f.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};c=a("../models/layer"),e=a("./renders"),d=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return g(b,a),b.prototype.model=c,b.prototype.initialize=function(){return this.on("change:type",this.validateLayers),this.on("change:gerber",function(a){var b;return b=a.get("gerber"),b?this.convert(a.get("name"),b):void 0}),b.__super__.initialize.call(this)},b.prototype.validateLayers=function(){var a;return a=!0,this.forEach(function(b){return b.isValid()?b.trigger("valid"):a=!1,!0}),a},b}(e),b.exports=d},{"../models/layer":"/Users/mc/projects/svgerber/src/models/layer.coffee","./renders":"/Users/mc/projects/svgerber/src/collections/renders.coffee"}],"/Users/mc/projects/svgerber/src/collections/renders.coffee":[function(a,b){var c,d,e,f={}.hasOwnProperty,g=function(a,b){function c(){this.constructor=a}for(var d in b)f.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d=new Worker(window.URL.createObjectURL(new Blob(["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function() {\n  module.exports = function(coord, format) {\n    var divisor, key, parse, result, val, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;\n    if (coord == null) {\n      return {};\n    }\n    if (!((format.zero != null) && (format.places != null))) {\n      throw new Error('format undefined');\n    }\n    parse = {};\n    result = {};\n    parse.x = (_ref = coord.match(/X[+-]?\\d+/)) != null ? (_ref1 = _ref[0]) != null ? _ref1.slice(1) : void 0 : void 0;\n    parse.y = (_ref2 = coord.match(/Y[+-]?\\d+/)) != null ? (_ref3 = _ref2[0]) != null ? _ref3.slice(1) : void 0 : void 0;\n    parse.i = (_ref4 = coord.match(/I[+-]?\\d+/)) != null ? (_ref5 = _ref4[0]) != null ? _ref5.slice(1) : void 0 : void 0;\n    parse.j = (_ref6 = coord.match(/J[+-]?\\d+/)) != null ? (_ref7 = _ref6[0]) != null ? _ref7.slice(1) : void 0 : void 0;\n    for (key in parse) {\n      val = parse[key];\n      if (val != null) {\n        divisor = 1;\n        if (val[0] === '+' || val[0] === '-') {\n          if (val[0] === '-') {\n            divisor = -1;\n          }\n          val = val.slice(1);\n        }\n        if (format.zero === 'L') {\n          divisor *= Math.pow(10, format.places[1]);\n        } else if (format.zero === 'T') {\n          divisor *= Math.pow(10, val.length - format.places[0]);\n        } else {\n          throw new Error('invalid zero suppression format');\n        }\n        result[key] = Number(val) / divisor;\n      }\n    }\n    return result;\n  };\n\n}).call(this);\n\n},{}],2:[function(require,module,exports){\n(function() {\n  var ABS_COMMAND, DrillParser, INCH_COMMAND, INC_COMMAND, METRIC_COMMAND, PLACES_BACKUP, ZERO_BACKUP, parseCoord, reCOORD;\n\n  parseCoord = require('./coord-parser');\n\n  INCH_COMMAND = {\n    'FMAT,1': 'M70',\n    'FMAT,2': 'M72'\n  };\n\n  METRIC_COMMAND = 'M71';\n\n  ABS_COMMAND = 'G90';\n\n  INC_COMMAND = 'G91';\n\n  reCOORD = /([XY]-?\\d*){1,2}/;\n\n  ZERO_BACKUP = 'L';\n\n  PLACES_BACKUP = [2, 4];\n\n  DrillParser = (function() {\n    function DrillParser() {\n      this.format = {\n        zero: null,\n        places: null\n      };\n      this.fmat = 'FMAT,2';\n    }\n\n    DrillParser.prototype.parseCommand = function(block) {\n      var code, command, dia, k, v, _ref, _ref1, _ref2;\n      command = {};\n      if (block[0] === ';') {\n        return command;\n      }\n      if (block === 'FMAT,1') {\n        this.fmat = block;\n      } else if (block === 'M30' || block === 'M00') {\n        command.set = {\n          done: true\n        };\n      } else if (block === INCH_COMMAND[this.fmat] || block.match(/INCH/)) {\n        this.format.places = [2, 4];\n        command.set = {\n          units: 'in'\n        };\n      } else if (block === METRIC_COMMAND || block.match(/METRIC/)) {\n        this.format.places = [3, 3];\n        command.set = {\n          units: 'mm'\n        };\n      } else if (block === ABS_COMMAND) {\n        command.set = {\n          notation: 'abs'\n        };\n      } else if (block === INC_COMMAND) {\n        command.set = {\n          notation: 'inc'\n        };\n      } else if ((code = (_ref = block.match(/T\\d+/)) != null ? _ref[0] : void 0)) {\n        if ((dia = (_ref1 = block.match(/C[\\d\\.]+(?=.*$)/)) != null ? _ref1[0] : void 0)) {\n          dia = Number(dia.slice(1));\n          command.tool = {};\n          command.tool[code] = {\n            dia: dia\n          };\n        } else {\n          command.set = {\n            currentTool: code\n          };\n        }\n      }\n      if (block.match(/TZ/)) {\n        this.format.zero = 'L';\n      } else if (block.match(/LZ/)) {\n        this.format.zero = 'T';\n      }\n      if (block.match(reCOORD)) {\n        command.op = {\n          \"do\": 'flash'\n        };\n        if (this.format.zero == null) {\n          console.warn('no drill file zero suppression specified. assuming leading zero suppression (same as no zero suppression)');\n          this.format.zero = ZERO_BACKUP;\n        }\n        if (this.format.places == null) {\n          console.warn('no drill file units specified; assuming 2:4 inches format');\n          this.format.places = PLACES_BACKUP;\n        }\n        _ref2 = parseCoord(block, this.format);\n        for (k in _ref2) {\n          v = _ref2[k];\n          command.op[k] = v;\n        }\n      }\n      return command;\n    };\n\n    return DrillParser;\n\n  })();\n\n  module.exports = DrillParser;\n\n}).call(this);\n\n},{\"./coord-parser\":1}],3:[function(require,module,exports){\n(function() {\n  var DrillReader;\n\n  DrillReader = (function() {\n    function DrillReader(drillFile) {\n      this.line = 0;\n      this.blocks = drillFile.split(/\\r?\\n/);\n    }\n\n    DrillReader.prototype.nextBlock = function() {\n      if (this.line < this.blocks.length) {\n        return this.blocks[++this.line - 1];\n      } else {\n        return false;\n      }\n    };\n\n    return DrillReader;\n\n  })();\n\n  module.exports = DrillReader;\n\n}).call(this);\n\n},{}],4:[function(require,module,exports){\n(function() {\n  var GerberParser, parseCoord, reCOORD;\n\n  parseCoord = require('./coord-parser');\n\n  reCOORD = /([XYIJ][+-]?\\d+){1,4}/g;\n\n  GerberParser = (function() {\n    function GerberParser() {\n      this.format = {\n        zero: null,\n        places: null\n      };\n    }\n\n    GerberParser.prototype.parseFormat = function(p, c) {\n      var nota, places, zero;\n      zero = p[2] === 'L' || p[2] === 'T' ? p[2] : null;\n      nota = p[3] === 'A' || p[3] === 'I' ? p[3] : null;\n      if (p[4] === 'X' && p[7] === 'Y' && p.slice(5, 7) === p.slice(8, 10) && p[5] < 8 && p[6] < 8) {\n        places = [+p[5], +p[6]];\n      }\n      if ((places == null) || (nota == null) || (zero == null)) {\n        throw new Error(\"invalid format specification\");\n      }\n      this.format.zero = zero;\n      this.format.places = places;\n      if (c.set == null) {\n        c.set = {};\n      }\n      return c.set.notation = nota;\n    };\n\n    GerberParser.prototype.parseToolDef = function(p, c) {\n      var code, hole, mods, shape, _ref, _ref1;\n      if (c.tool == null) {\n        c.tool = {};\n      }\n      code = (_ref = p.match(/^ADD\\d{2,}/)) != null ? _ref[0].slice(2) : void 0;\n      _ref1 = p.slice(2 + code.length).split(','), shape = _ref1[0], mods = _ref1[1];\n      mods = mods != null ? mods.split('X') : void 0;\n      while (code[1] === '0') {\n        code = code[0] + code.slice(2);\n      }\n      switch (shape) {\n        case 'C':\n          if (mods.length > 2) {\n            hole = {\n              width: +mods[1],\n              height: +mods[2]\n            };\n          } else if (mods.length > 1) {\n            hole = {\n              dia: +mods[1]\n            };\n          }\n          c.tool[code] = {\n            dia: +mods[0]\n          };\n          if (hole != null) {\n            return c.tool[code].hole = hole;\n          }\n          break;\n        case 'R':\n        case 'O':\n          if (mods.length > 3) {\n            hole = {\n              width: +mods[2],\n              height: +mods[3]\n            };\n          } else if (mods.length > 2) {\n            hole = {\n              dia: +mods[2]\n            };\n          }\n          c.tool[code] = {\n            width: +mods[0],\n            height: +mods[1]\n          };\n          if (shape === 'O') {\n            c.tool[code].obround = true;\n          }\n          if (hole != null) {\n            return c.tool[code].hole = hole;\n          }\n          break;\n        case 'P':\n          if (mods.length > 4) {\n            hole = {\n              width: +mods[3],\n              height: +mods[4]\n            };\n          } else if (mods.length > 3) {\n            hole = {\n              dia: +mods[3]\n            };\n          }\n          c.tool[code] = {\n            dia: +mods[0],\n            verticies: +mods[1]\n          };\n          if (mods.length > 2) {\n            c.tool[code].degrees = +mods[2];\n          }\n          if (hole != null) {\n            return c.tool[code].hole = hole;\n          }\n          break;\n        default:\n          return c.tool[code] = {\n            macro: shape,\n            mods: mods != null ? mods : []\n          };\n      }\n    };\n\n    GerberParser.prototype.parseCommand = function(block) {\n      var axis, c, code, coord, i, j, m, op, p, param, tool, u, val, x, y, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;\n      if (block == null) {\n        block = {};\n      }\n      c = {};\n      if (param = block.param) {\n        for (_i = 0, _len = param.length; _i < _len; _i++) {\n          p = param[_i];\n          switch (code = p.slice(0, 2)) {\n            case 'FS':\n              this.parseFormat(p, c);\n              break;\n            case 'MO':\n              u = p.slice(2, 4);\n              if (c.set == null) {\n                c.set = {};\n              }\n              if (u === 'IN') {\n                c.set.units = 'in';\n              } else if (u === 'MM') {\n                c.set.units = 'mm';\n              } else {\n                throw new Error(\"\" + p + \" is an invalid units setting\");\n              }\n              break;\n            case 'AD':\n              this.parseToolDef(p, c);\n              break;\n            case 'AM':\n              return {\n                macro: param\n              };\n            case 'LP':\n              if (c[\"new\"] == null) {\n                c[\"new\"] = {};\n              }\n              if (p[2] === 'D' || p[2] === 'C') {\n                c[\"new\"].layer = p[2];\n              }\n              if (c[\"new\"].layer == null) {\n                throw new Error('invalid level polarity');\n              }\n              break;\n            case 'SR':\n              if (c[\"new\"] == null) {\n                c[\"new\"] = {};\n              }\n              x = (_ref = (_ref1 = p.match(/X[+-]?[\\d\\.]+/)) != null ? _ref1[0].slice(1) : void 0) != null ? _ref : 1;\n              y = (_ref2 = (_ref3 = p.match(/Y[+-]?[\\d\\.]+/)) != null ? _ref3[0].slice(1) : void 0) != null ? _ref2 : 1;\n              i = (_ref4 = p.match(/I[+-]?[\\d\\.]+/)) != null ? _ref4[0].slice(1) : void 0;\n              j = (_ref5 = p.match(/J[+-]?[\\d\\.]+/)) != null ? _ref5[0].slice(1) : void 0;\n              if (x < 1 || y < 1 || (x > 1 && (i == null) || i < 0) || (y > 1 && (j == null) || j < 0)) {\n                throw new Error('invalid step repeat');\n              }\n              c[\"new\"].sr = {\n                x: x,\n                y: y\n              };\n              if (i != null) {\n                c[\"new\"].sr.i = +i;\n              }\n              if (j != null) {\n                c[\"new\"].sr.j = +j;\n              }\n          }\n        }\n      } else if (block = block.block) {\n        if (block === 'M02') {\n          return {\n            set: {\n              done: true\n            }\n          };\n        } else if (block[0] === 'G') {\n          switch (code = (_ref6 = block.slice(1).match(/^\\d{1,2}/)) != null ? _ref6[0] : void 0) {\n            case '4':\n            case '04':\n              return {};\n            case '1':\n            case '01':\n            case '2':\n            case '02':\n            case '3':\n            case '03':\n              code = code[code.length - 1];\n              m = code === '1' ? 'i' : code === '2' ? 'cw' : 'ccw';\n              c.set = {\n                mode: m\n              };\n              break;\n            case '36':\n            case '37':\n              c.set = {\n                region: code === '36'\n              };\n              break;\n            case '70':\n            case '71':\n              c.set = {\n                backupUnits: code === '70' ? 'in' : 'mm'\n              };\n              break;\n            case '74':\n            case '75':\n              c.set = {\n                quad: code === '74' ? 's' : 'm'\n              };\n          }\n        }\n        coord = parseCoord((_ref7 = block.match(reCOORD)) != null ? _ref7[0] : void 0, this.format);\n        if (op = ((_ref8 = block.match(/D0?[123]$/)) != null ? _ref8[0] : void 0) || Object.keys(coord).length) {\n          if (op != null) {\n            op = op[op.length - 1];\n          }\n          op = (function() {\n            switch (op) {\n              case '1':\n                return 'int';\n              case '2':\n                return 'move';\n              case '3':\n                return 'flash';\n              default:\n                return 'last';\n            }\n          })();\n          c.op = {\n            \"do\": op\n          };\n          for (axis in coord) {\n            val = coord[axis];\n            c.op[axis] = val;\n          }\n        } else if (tool = (_ref9 = block.match(/D\\d+$/)) != null ? _ref9[0] : void 0) {\n          c.set = {\n            currentTool: tool\n          };\n        }\n      }\n      return c;\n    };\n\n    return GerberParser;\n\n  })();\n\n  module.exports = GerberParser;\n\n}).call(this);\n\n},{\"./coord-parser\":1}],5:[function(require,module,exports){\n(function() {\n  var GerberReader;\n\n  GerberReader = (function() {\n    function GerberReader(gerberFile) {\n      this.gerberFile = gerberFile;\n      this.line = 0;\n      this.charIndex = 0;\n      this.end = this.gerberFile.length;\n    }\n\n    GerberReader.prototype.nextBlock = function() {\n      var char, current, parameter;\n      if (this.index >= this.end) {\n        return false;\n      }\n      current = '';\n      parameter = false;\n      if (this.line === 0) {\n        this.line++;\n      }\n      while (!(this.charIndex >= this.end)) {\n        char = this.gerberFile[this.charIndex++];\n        if (char === '%') {\n          if (!parameter) {\n            parameter = [];\n          } else {\n            return {\n              param: parameter\n            };\n          }\n        } else if (char === '*') {\n          if (parameter) {\n            parameter.push(current);\n            current = '';\n          } else {\n            return {\n              block: current\n            };\n          }\n        } else if (char === '\\n') {\n          this.line++;\n        } else if ((' ' <= char && char <= '~')) {\n          current += char;\n        }\n      }\n      return false;\n    };\n\n    return GerberReader;\n\n  })();\n\n  module.exports = GerberReader;\n\n}).call(this);\n\n},{}],6:[function(require,module,exports){\n\n/*\n@license copyright 2014 by mike cousins <mike@cousins.io> (http://cousins.io)\nshared under the terms of the MIT license\nview source at http://github.com/mcous/gerber-to-svg\n */\n\n(function() {\n  var DEFAULT_OPTS, Plotter, builder;\n\n  builder = require('./obj-to-xml');\n\n  Plotter = require('./plotter');\n\n  DEFAULT_OPTS = {\n    drill: false,\n    pretty: false,\n    object: false\n  };\n\n  module.exports = function(gerber, options) {\n    var Parser, Reader, a, error, height, key, opts, p, val, width, xml, xmlObject, _ref;\n    if (options == null) {\n      options = {};\n    }\n    opts = {};\n    for (key in DEFAULT_OPTS) {\n      val = DEFAULT_OPTS[key];\n      opts[key] = val;\n    }\n    for (key in options) {\n      val = options[key];\n      opts[key] = val;\n    }\n    if (typeof gerber === 'object') {\n      if (gerber.svg != null) {\n        return builder(gerber, {\n          pretty: opts.pretty\n        });\n      } else {\n        throw new Error(\"non SVG object cannot be converted to an SVG string\");\n      }\n    }\n    if (opts.drill) {\n      Reader = require('./drill-reader');\n      Parser = require('./drill-parser');\n    } else {\n      Reader = require('./gerber-reader');\n      Parser = require('./gerber-parser');\n    }\n    p = new Plotter(gerber, Reader, Parser);\n    try {\n      xmlObject = p.plot();\n    } catch (_error) {\n      error = _error;\n      throw new Error(\"Error at line \" + p.reader.line + \" - \" + error.message);\n    }\n    if (!(p.bbox.xMin >= p.bbox.xMax)) {\n      width = p.bbox.xMax - p.bbox.xMin;\n    } else {\n      p.bbox.xMin = 0;\n      p.bbox.xMax = 0;\n      width = 0;\n    }\n    if (!(p.bbox.yMin >= p.bbox.yMax)) {\n      height = p.bbox.yMax - p.bbox.yMin;\n    } else {\n      p.bbox.yMin = 0;\n      p.bbox.yMax = 0;\n      height = 0;\n    }\n    xml = {\n      svg: {\n        xmlns: 'http://www.w3.org/2000/svg',\n        version: '1.1',\n        'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n        width: \"\" + width + p.units,\n        height: \"\" + height + p.units,\n        viewBox: [p.bbox.xMin, p.bbox.yMin, width, height],\n        _: []\n      }\n    };\n    _ref = p.attr;\n    for (a in _ref) {\n      val = _ref[a];\n      xml.svg[a] = val;\n    }\n    if (p.defs.length) {\n      xml.svg._.push({\n        defs: {\n          _: p.defs\n        }\n      });\n    }\n    if (p.group.g._.length) {\n      xml.svg._.push(p.group);\n    }\n    if (!opts.object) {\n      return builder(xml, {\n        pretty: opts.pretty\n      });\n    } else {\n      return xml;\n    }\n  };\n\n}).call(this);\n\n},{\"./drill-parser\":2,\"./drill-reader\":3,\"./gerber-parser\":4,\"./gerber-reader\":5,\"./obj-to-xml\":9,\"./plotter\":11}],7:[function(require,module,exports){\n(function() {\n  var NUMBER, OPERATOR, TOKEN, isNumber, parse, tokenize;\n\n  OPERATOR = /[\\+\\-\\/xX\\(\\)]/;\n\n  NUMBER = /[\\$\\d\\.]+/;\n\n  TOKEN = new RegExp(\"(\" + OPERATOR.source + \")|(\" + NUMBER.source + \")\", 'g');\n\n  tokenize = function(arith) {\n    var results;\n    return results = arith.match(TOKEN);\n  };\n\n  isNumber = function(token) {\n    return NUMBER.test(token);\n  };\n\n  parse = function(arith) {\n    var consume, index, parseExpression, parseMultiplication, parsePrimary, peek, tokens;\n    tokens = tokenize(arith);\n    index = 0;\n    peek = function() {\n      return tokens[index];\n    };\n    consume = function(t) {\n      if (t === peek()) {\n        return index++;\n      }\n    };\n    parsePrimary = function() {\n      var exp, t;\n      t = peek();\n      consume(t);\n      if (isNumber(t)) {\n        exp = {\n          type: 'n',\n          val: t\n        };\n      } else if (t === '(') {\n        exp = parseExpression();\n        if (peek() !== ')') {\n          throw new Error(\"expected ')'\");\n        } else {\n          consume(')');\n        }\n      } else {\n        throw new Error(\"\" + t + \" is unexpected in an arithmetic string\");\n      }\n      return exp;\n    };\n    parseMultiplication = function() {\n      var exp, rhs, t;\n      exp = parsePrimary();\n      t = peek();\n      while (t === 'x' || t === '/' || t === 'X') {\n        consume(t);\n        if (t === 'X') {\n          console.warn(\"Warning: uppercase 'X' as multiplication symbol is incorrect; macros should use lowercase 'x' to multiply\");\n          t = 'x';\n        }\n        rhs = parsePrimary();\n        exp = {\n          type: t,\n          left: exp,\n          right: rhs\n        };\n        t = peek();\n      }\n      return exp;\n    };\n    parseExpression = function() {\n      var exp, rhs, t;\n      exp = parseMultiplication();\n      t = peek();\n      while (t === '+' || t === '-') {\n        consume(t);\n        rhs = parseMultiplication();\n        exp = {\n          type: t,\n          left: exp,\n          right: rhs\n        };\n        t = peek();\n      }\n      return exp;\n    };\n    return parseExpression();\n  };\n\n  module.exports = {\n    tokenize: tokenize,\n    isNumber: isNumber,\n    parse: parse\n  };\n\n}).call(this);\n\n},{}],8:[function(require,module,exports){\n(function() {\n  var MacroTool, calc, shapes, unique;\n\n  shapes = require('./pad-shapes');\n\n  calc = require('./macro-calc');\n\n  unique = require('./unique-id');\n\n  MacroTool = (function() {\n    function MacroTool(blocks) {\n      this.modifiers = {};\n      this.name = blocks[0].slice(2);\n      this.blocks = blocks.slice(1);\n      this.shapes = [];\n      this.masks = [];\n      this.lastExposure = null;\n      this.bbox = [null, null, null, null];\n    }\n\n    MacroTool.prototype.run = function(tool, modifiers) {\n      var b, group, i, m, pad, padId, s, shape, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;\n      if (modifiers == null) {\n        modifiers = [];\n      }\n      this.lastExposure = null;\n      this.shapes = [];\n      this.masks = [];\n      this.bbox = [null, null, null, null];\n      this.modifiers = {};\n      for (i = _i = 0, _len = modifiers.length; _i < _len; i = ++_i) {\n        m = modifiers[i];\n        this.modifiers[\"$\" + (i + 1)] = m;\n      }\n      _ref = this.blocks;\n      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n        b = _ref[_j];\n        this.runBlock(b);\n      }\n      padId = \"tool-\" + tool + \"-pad-\" + (unique());\n      pad = [];\n      _ref1 = this.masks;\n      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n        m = _ref1[_k];\n        pad.push(m);\n      }\n      if (this.shapes.length > 1) {\n        group = {\n          id: padId,\n          _: []\n        };\n        _ref2 = this.shapes;\n        for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {\n          s = _ref2[_l];\n          group._.push(s);\n        }\n        pad = [\n          {\n            g: group\n          }\n        ];\n      } else if (this.shapes.length === 1) {\n        shape = Object.keys(this.shapes[0])[0];\n        this.shapes[0][shape].id = padId;\n        pad.push(this.shapes[0]);\n      }\n      return {\n        pad: pad,\n        padId: padId,\n        bbox: this.bbox,\n        trace: false\n      };\n    };\n\n    MacroTool.prototype.runBlock = function(block) {\n      var a, args, i, mod, val, _i, _len, _ref;\n      switch (block[0]) {\n        case '$':\n          mod = (_ref = block.match(/^\\$\\d+(?=\\=)/)) != null ? _ref[0] : void 0;\n          val = block.slice(1 + mod.length);\n          return this.modifiers[mod] = this.getNumber(val);\n        case '1':\n        case '2':\n        case '20':\n        case '21':\n        case '22':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n          args = block.split(',');\n          for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {\n            a = args[i];\n            args[i] = this.getNumber(a);\n          }\n          return this.primitive(args);\n        default:\n          if (block[0] !== '0') {\n            throw new Error(\"'\" + block + \"' unrecognized tool macro block\");\n          }\n      }\n    };\n\n    MacroTool.prototype.primitive = function(args) {\n      var group, i, key, m, mask, maskId, points, rot, rotation, s, shape, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;\n      mask = false;\n      rotation = false;\n      shape = null;\n      switch (args[0]) {\n        case 1:\n          shape = shapes.circle({\n            dia: args[2],\n            cx: args[3],\n            cy: args[4]\n          });\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox);\n          }\n          break;\n        case 2:\n        case 20:\n          shape = shapes.vector({\n            width: args[2],\n            x1: args[3],\n            y1: args[4],\n            x2: args[5],\n            y2: args[6]\n          });\n          if (args[7]) {\n            shape.shape.line.transform = \"rotate(\" + args[7] + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[7]);\n          }\n          break;\n        case 21:\n          shape = shapes.rect({\n            cx: args[4],\n            cy: args[5],\n            width: args[2],\n            height: args[3]\n          });\n          if (args[6]) {\n            shape.shape.rect.transform = \"rotate(\" + args[6] + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[6]);\n          }\n          break;\n        case 22:\n          shape = shapes.lowerLeftRect({\n            x: args[4],\n            y: args[5],\n            width: args[2],\n            height: args[3]\n          });\n          if (args[6]) {\n            shape.shape.rect.transform = \"rotate(\" + args[6] + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[6]);\n          }\n          break;\n        case 4:\n          points = [];\n          for (i = _i = 3, _ref = 3 + 2 * args[2]; _i <= _ref; i = _i += 2) {\n            points.push([args[i], args[i + 1]]);\n          }\n          shape = shapes.outline({\n            points: points\n          });\n          if (rot = args[args.length - 1]) {\n            shape.shape.polygon.transform = \"rotate(\" + rot + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[args.length - 1]);\n          }\n          break;\n        case 5:\n          if (args[6] !== 0 && (args[3] !== 0 || args[4] !== 0)) {\n            throw new RangeError('polygon center must be 0,0 if rotated in macro');\n          }\n          shape = shapes.polygon({\n            cx: args[3],\n            cy: args[4],\n            dia: args[5],\n            verticies: args[2],\n            degrees: args[6]\n          });\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox);\n          }\n          break;\n        case 6:\n          if (args[9] !== 0 && (args[1] !== 0 || args[2] !== 0)) {\n            throw new RangeError('moiré center must be 0,0 if rotated in macro');\n          }\n          shape = shapes.moire({\n            cx: args[1],\n            cy: args[2],\n            outerDia: args[3],\n            ringThx: args[4],\n            ringGap: args[5],\n            maxRings: args[6],\n            crossThx: args[7],\n            crossLength: args[8]\n          });\n          if (args[9]) {\n            _ref1 = shape.shape;\n            for (_j = 0, _len = _ref1.length; _j < _len; _j++) {\n              s = _ref1[_j];\n              if (s.line != null) {\n                s.line.transform = \"rotate(\" + args[9] + \")\";\n              }\n            }\n          }\n          this.addBbox(shape.bbox, args[9]);\n          break;\n        case 7:\n          if (args[9] !== 0 && (args[1] !== 0 || args[2] !== 0)) {\n            throw new RangeError('thermal center must be 0,0 if rotated in macro');\n          }\n          shape = shapes.thermal({\n            cx: args[1],\n            cy: args[2],\n            outerDia: args[3],\n            innerDia: args[4],\n            gap: args[5]\n          });\n          if (args[6]) {\n            _ref2 = shape.shape;\n            for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {\n              s = _ref2[_k];\n              if (s.mask != null) {\n                _ref3 = s.mask._;\n                for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {\n                  m = _ref3[_l];\n                  if (m.rect != null) {\n                    m.rect.transform = \"rotate(\" + args[6] + \")\";\n                  }\n                }\n              }\n            }\n          }\n          this.addBbox(shape.bbox, args[6]);\n          break;\n        default:\n          throw new Error(\"\" + args[0] + \" is not a valid primitive code\");\n      }\n      if (mask) {\n        for (key in shape.shape) {\n          shape.shape[key].fill = '#000';\n        }\n        if (this.lastExposure !== 0) {\n          this.lastExposure = 0;\n          maskId = \"macro-\" + this.name + \"-mask-\" + (unique());\n          m = {\n            mask: {\n              id: maskId\n            }\n          };\n          m.mask._ = [\n            {\n              rect: {\n                x: this.bbox[0],\n                y: this.bbox[1],\n                width: this.bbox[2] - this.bbox[0],\n                height: this.bbox[3] - this.bbox[1],\n                fill: '#fff'\n              }\n            }\n          ];\n          if (this.shapes.length === 1) {\n            for (key in this.shapes[0]) {\n              this.shapes[0][key].mask = \"url(#\" + maskId + \")\";\n            }\n          } else if (this.shapes.length > 1) {\n            group = {\n              mask: \"url(#\" + maskId + \")\",\n              _: []\n            };\n            _ref4 = this.shapes;\n            for (_m = 0, _len3 = _ref4.length; _m < _len3; _m++) {\n              s = _ref4[_m];\n              group._.push(s);\n            }\n            this.shapes = [\n              {\n                g: group\n              }\n            ];\n          }\n          this.masks.push(m);\n        }\n        return this.masks[this.masks.length - 1].mask._.push(shape.shape);\n      } else {\n        this.lastExposure = 1;\n        if (!Array.isArray(shape.shape)) {\n          return this.shapes.push(shape.shape);\n        } else {\n          _ref5 = shape.shape;\n          _results = [];\n          for (_n = 0, _len4 = _ref5.length; _n < _len4; _n++) {\n            s = _ref5[_n];\n            if (s.mask != null) {\n              _results.push(this.masks.push(s));\n            } else {\n              _results.push(this.shapes.push(s));\n            }\n          }\n          return _results;\n        }\n      }\n    };\n\n    MacroTool.prototype.addBbox = function(bbox, rotation) {\n      var c, p, points, s, x, y, _i, _len, _results;\n      if (rotation == null) {\n        rotation = 0;\n      }\n      if (!rotation) {\n        if (this.bbox[0] === null || bbox[0] < this.bbox[0]) {\n          this.bbox[0] = bbox[0];\n        }\n        if (this.bbox[1] === null || bbox[1] < this.bbox[1]) {\n          this.bbox[1] = bbox[1];\n        }\n        if (this.bbox[2] === null || bbox[2] > this.bbox[2]) {\n          this.bbox[2] = bbox[2];\n        }\n        if (this.bbox[3] === null || bbox[3] > this.bbox[3]) {\n          return this.bbox[3] = bbox[3];\n        }\n      } else {\n        s = Math.sin(rotation * Math.PI / 180);\n        c = Math.cos(rotation * Math.PI / 180);\n        if (Math.abs(s) < 0.000000001) {\n          s = 0;\n        }\n        if (Math.abs(c) < 0.000000001) {\n          c = 0;\n        }\n        points = [[bbox[0], bbox[1]], [bbox[2], bbox[1]], [bbox[2], bbox[3]], [bbox[0], bbox[3]]];\n        _results = [];\n        for (_i = 0, _len = points.length; _i < _len; _i++) {\n          p = points[_i];\n          x = p[0] * c - p[1] * s;\n          y = p[0] * s + p[1] * c;\n          if (this.bbox[0] === null || x < this.bbox[0]) {\n            this.bbox[0] = x;\n          }\n          if (this.bbox[1] === null || y < this.bbox[1]) {\n            this.bbox[1] = y;\n          }\n          if (this.bbox[2] === null || x > this.bbox[2]) {\n            this.bbox[2] = x;\n          }\n          if (this.bbox[3] === null || y > this.bbox[3]) {\n            _results.push(this.bbox[3] = y);\n          } else {\n            _results.push(void 0);\n          }\n        }\n        return _results;\n      }\n    };\n\n    MacroTool.prototype.getNumber = function(s) {\n      if (s.match(/^[+-]?[\\d.]+$/)) {\n        return Number(s);\n      } else if (s.match(/^\\$\\d+$/)) {\n        return Number(this.modifiers[s]);\n      } else {\n        return this.evaluate(calc.parse(s));\n      }\n    };\n\n    MacroTool.prototype.evaluate = function(op) {\n      switch (op.type) {\n        case 'n':\n          return this.getNumber(op.val);\n        case '+':\n          return this.evaluate(op.left) + this.evaluate(op.right);\n        case '-':\n          return this.evaluate(op.left) - this.evaluate(op.right);\n        case 'x':\n          return this.evaluate(op.left) * this.evaluate(op.right);\n        case '/':\n          return this.evaluate(op.left) / this.evaluate(op.right);\n      }\n    };\n\n    return MacroTool;\n\n  })();\n\n  module.exports = MacroTool;\n\n}).call(this);\n\n},{\"./macro-calc\":7,\"./pad-shapes\":10,\"./unique-id\":13}],9:[function(require,module,exports){\n(function() {\n  var CKEY, DTAB, objToXml, repeat;\n\n  repeat = function(pattern, count) {\n    var result;\n    result = '';\n    if (count === 0) {\n      return '';\n    }\n    while (count > 1) {\n      if (count & 1) {\n        result += pattern;\n      }\n      count >>= 1;\n      pattern += pattern;\n    }\n    return result + pattern;\n  };\n\n  CKEY = '_';\n\n  DTAB = '  ';\n\n  objToXml = function(obj, op) {\n    var children, dec, decimals, elem, i, ind, key, nl, o, pre, tb, v, val, xml, _i, _len, _ref, _ref1, _ref2;\n    if (op == null) {\n      op = {};\n    }\n    pre = op.pretty;\n    ind = (_ref = op.indent) != null ? _ref : 0;\n    dec = (_ref1 = op.maxDec) != null ? _ref1 : false;\n    decimals = function(n) {\n      if (typeof n === 'number') {\n        return Number(n.toFixed(dec));\n      } else {\n        return n;\n      }\n    };\n    nl = pre ? '\\n' : '';\n    tb = nl ? (typeof pre === 'string' ? pre : DTAB) : '';\n    tb = repeat(tb, ind);\n    xml = '';\n    if (typeof obj === 'function') {\n      obj = obj();\n    }\n    if (Array.isArray(obj)) {\n      for (i = _i = 0, _len = obj.length; _i < _len; i = ++_i) {\n        o = obj[i];\n        xml += (i !== 0 ? nl : '') + (objToXml(o, op));\n      }\n    } else if (typeof obj === 'object') {\n      children = false;\n      elem = Object.keys(obj)[0];\n      if (elem != null) {\n        xml = \"\" + tb + \"<\" + elem;\n        if (typeof obj[elem] === 'function') {\n          obj[elem] = obj[elem]();\n        }\n        _ref2 = obj[elem];\n        for (key in _ref2) {\n          val = _ref2[key];\n          if (typeof val === 'function') {\n            val = val();\n          }\n          if (key === CKEY) {\n            children = val;\n          } else {\n            if (Array.isArray(val)) {\n              if (dec) {\n                val = (function() {\n                  var _j, _len1, _results;\n                  _results = [];\n                  for (_j = 0, _len1 = val.length; _j < _len1; _j++) {\n                    v = val[_j];\n                    _results.push(decimals(v));\n                  }\n                  return _results;\n                })();\n              }\n              val = val.join(' ');\n            }\n            if (dec) {\n              val = decimals(val);\n            }\n            xml += \" \" + key + \"=\\\"\" + val + \"\\\"\";\n          }\n        }\n        if (children) {\n          xml += '>' + nl + objToXml(children, {\n            pretty: pre,\n            indent: ind + 1\n          });\n        }\n        if (obj[elem]._ != null) {\n          xml += \"\" + nl + tb + \"</\" + elem + \">\";\n        } else {\n          xml += '/>';\n        }\n      }\n    } else {\n      xml += \"\" + obj + \" \";\n    }\n    return xml;\n  };\n\n  module.exports = objToXml;\n\n}).call(this);\n\n},{}],10:[function(require,module,exports){\n(function() {\n  var circle, lowerLeftRect, moire, outline, polygon, rect, thermal, unique, vector;\n\n  unique = require('./unique-id');\n\n  circle = function(p) {\n    var r;\n    if (p.dia == null) {\n      throw new Error('circle function requires diameter');\n    }\n    if (p.cx == null) {\n      throw new Error('circle function requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('circle function requires y center');\n    }\n    r = p.dia / 2;\n    return {\n      shape: {\n        circle: {\n          cx: p.cx,\n          cy: p.cy,\n          r: r\n        }\n      },\n      bbox: [p.cx - r, p.cy - r, p.cx + r, p.cy + r]\n    };\n  };\n\n  rect = function(p) {\n    var radius, rectangle, x, y;\n    if (p.width == null) {\n      throw new Error('rectangle requires width');\n    }\n    if (p.height == null) {\n      throw new Error('rectangle requires height');\n    }\n    if (p.cx == null) {\n      throw new Error('rectangle function requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('rectangle function requires y center');\n    }\n    x = p.cx - p.width / 2;\n    y = p.cy - p.height / 2;\n    rectangle = {\n      shape: {\n        rect: {\n          x: x,\n          y: y,\n          width: p.width,\n          height: p.height\n        }\n      },\n      bbox: [x, y, x + p.width, y + p.height]\n    };\n    if (p.obround) {\n      radius = 0.5 * Math.min(p.width, p.height);\n      rectangle.shape.rect.rx = radius;\n      rectangle.shape.rect.ry = radius;\n    }\n    return rectangle;\n  };\n\n  polygon = function(p) {\n    var i, points, r, rx, ry, start, step, theta, x, xMax, xMin, y, yMax, yMin, _i, _ref;\n    if (p.dia == null) {\n      throw new Error('polygon requires diameter');\n    }\n    if (p.verticies == null) {\n      throw new Error('polygon requires verticies');\n    }\n    if (p.cx == null) {\n      throw new Error('polygon function requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('polygon function requires y center');\n    }\n    start = p.degrees != null ? p.degrees * Math.PI / 180 : 0;\n    step = 2 * Math.PI / p.verticies;\n    r = p.dia / 2;\n    points = '';\n    xMin = null;\n    yMin = null;\n    xMax = null;\n    yMax = null;\n    for (i = _i = 0, _ref = p.verticies; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      theta = start + i * step;\n      rx = r * Math.cos(theta);\n      ry = r * Math.sin(theta);\n      if (Math.abs(rx) < 0.000000001) {\n        rx = 0;\n      }\n      if (Math.abs(ry) < 0.000000001) {\n        ry = 0;\n      }\n      x = p.cx + rx;\n      y = p.cy + ry;\n      if (x < xMin || xMin === null) {\n        xMin = x;\n      }\n      if (x > xMax || xMax === null) {\n        xMax = x;\n      }\n      if (y < yMin || yMin === null) {\n        yMin = y;\n      }\n      if (y > yMax || yMax === null) {\n        yMax = y;\n      }\n      points += \" \" + x + \",\" + y;\n    }\n    return {\n      shape: {\n        polygon: {\n          points: points.slice(1)\n        }\n      },\n      bbox: [xMin, yMin, xMax, yMax]\n    };\n  };\n\n  vector = function(p) {\n    var theta, xDelta, yDelta;\n    if (p.x1 == null) {\n      throw new Error('vector function requires start x');\n    }\n    if (p.y1 == null) {\n      throw new Error('vector function requires start y');\n    }\n    if (p.x2 == null) {\n      throw new Error('vector function requires end x');\n    }\n    if (p.y2 == null) {\n      throw new Error('vector function requires end y');\n    }\n    if (p.width == null) {\n      throw new Error('vector function requires width');\n    }\n    theta = Math.abs(Math.atan((p.y2 - p.y1) / (p.x2 - p.x1)));\n    xDelta = p.width / 2 * Math.sin(theta);\n    yDelta = p.width / 2 * Math.cos(theta);\n    if (xDelta < 0.0000001) {\n      xDelta = 0;\n    }\n    if (yDelta < 0.0000001) {\n      yDelta = 0;\n    }\n    return {\n      shape: {\n        line: {\n          x1: p.x1,\n          x2: p.x2,\n          y1: p.y1,\n          y2: p.y2,\n          'stroke-width': p.width,\n          'stroke-linecap': 'butt'\n        }\n      },\n      bbox: [(Math.min(p.x1, p.x2)) - xDelta, (Math.min(p.y1, p.y2)) - yDelta, (Math.max(p.x1, p.x2)) + xDelta, (Math.max(p.y1, p.y2)) + yDelta]\n    };\n  };\n\n  lowerLeftRect = function(p) {\n    if (p.width == null) {\n      throw new Error('lower left rect requires width');\n    }\n    if (p.height == null) {\n      throw new Error('lower left rect requires height');\n    }\n    if (p.x == null) {\n      throw new Error('lower left rectangle requires x');\n    }\n    if (p.y == null) {\n      throw new Error('lower left rectangle requires y');\n    }\n    return {\n      shape: {\n        rect: {\n          x: p.x,\n          y: p.y,\n          width: p.width,\n          height: p.height\n        }\n      },\n      bbox: [p.x, p.y, p.x + p.width, p.y + p.height]\n    };\n  };\n\n  outline = function(p) {\n    var point, pointString, x, xLast, xMax, xMin, y, yLast, yMax, yMin, _i, _len, _ref;\n    if (!(Array.isArray(p.points) && p.points.length > 1)) {\n      throw new Error('outline function requires points array');\n    }\n    xMin = null;\n    yMin = null;\n    xMax = null;\n    yMax = null;\n    pointString = '';\n    _ref = p.points;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      point = _ref[_i];\n      if (!(Array.isArray(point) && point.length === 2)) {\n        throw new Error('outline function requires points array');\n      }\n      x = point[0];\n      y = point[1];\n      if (x < xMin || xMin === null) {\n        xMin = x;\n      }\n      if (x > xMax || xMax === null) {\n        xMax = x;\n      }\n      if (y < yMin || yMin === null) {\n        yMin = y;\n      }\n      if (y > yMax || yMax === null) {\n        yMax = y;\n      }\n      pointString += \" \" + x + \",\" + y;\n    }\n    xLast = p.points[p.points.length - 1][0];\n    yLast = p.points[p.points.length - 1][1];\n    if (!(xLast === p.points[0][0] && yLast === p.points[0][1])) {\n      throw new RangeError('last point must match first point of outline');\n    }\n    return {\n      shape: {\n        polygon: {\n          points: pointString.slice(1)\n        }\n      },\n      bbox: [xMin, yMin, xMax, yMax]\n    };\n  };\n\n  moire = function(p) {\n    var r, rings, shape;\n    if (p.cx == null) {\n      throw new Error('moiré requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('moiré requires y center');\n    }\n    if (p.outerDia == null) {\n      throw new Error('moiré requires outer diameter');\n    }\n    if (p.ringThx == null) {\n      throw new Error('moiré requires ring thickness');\n    }\n    if (p.ringGap == null) {\n      throw new Error('moiré requires ring gap');\n    }\n    if (p.maxRings == null) {\n      throw new Error('moiré requires max rings');\n    }\n    if (p.crossLength == null) {\n      throw new Error('moiré requires crosshair length');\n    }\n    if (p.crossThx == null) {\n      throw new Error('moiré requires crosshair thickness');\n    }\n    shape = [\n      {\n        line: {\n          x1: p.cx - p.crossLength / 2,\n          y1: 0,\n          x2: p.cx + p.crossLength / 2,\n          y2: 0,\n          'stroke-width': p.crossThx,\n          'stroke-linecap': 'butt'\n        }\n      }, {\n        line: {\n          x1: 0,\n          y1: p.cy - p.crossLength / 2,\n          x2: 0,\n          y2: p.cy + p.crossLength / 2,\n          'stroke-width': p.crossThx,\n          'stroke-linecap': 'butt'\n        }\n      }\n    ];\n    r = (p.outerDia - p.ringThx) / 2;\n    rings = 0;\n    while (r >= p.ringThx && rings < p.maxRings) {\n      shape.push({\n        circle: {\n          cx: p.cx,\n          cy: p.cy,\n          r: r,\n          fill: 'none',\n          'stroke-width': p.ringThx\n        }\n      });\n      rings++;\n      r -= p.ringThx + p.ringGap;\n    }\n    r += 0.5 * p.ringThx;\n    if (r > 0 && rings < p.maxRings) {\n      shape.push({\n        circle: {\n          cx: p.cx,\n          cy: p.cy,\n          r: r\n        }\n      });\n    }\n    return {\n      shape: shape,\n      bbox: [Math.min(p.cx - p.crossLength / 2, p.cx - p.outerDia / 2), Math.min(p.cy - p.crossLength / 2, p.cy - p.outerDia / 2), Math.max(p.cx + p.crossLength / 2, p.cx + p.outerDia / 2), Math.max(p.cy + p.crossLength / 2, p.cy + p.outerDia / 2)]\n    };\n  };\n\n  thermal = function(p) {\n    var halfGap, maskId, outerR, r, thx, xMax, xMin, yMax, yMin;\n    if (p.cx == null) {\n      throw new Error('thermal requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('thermal requires y center');\n    }\n    if (p.outerDia == null) {\n      throw new Error('thermal requires outer diameter');\n    }\n    if (p.innerDia == null) {\n      throw new Error('thermal requires inner diameter');\n    }\n    if (p.gap == null) {\n      throw new Error('thermal requires gap');\n    }\n    maskId = \"thermal-mask-\" + (unique());\n    thx = (p.outerDia - p.innerDia) / 2;\n    outerR = p.outerDia / 2;\n    r = outerR - thx / 2;\n    xMin = p.cx - outerR;\n    xMax = p.cx + outerR;\n    yMin = p.cy - outerR;\n    yMax = p.cy + outerR;\n    halfGap = p.gap / 2;\n    return {\n      shape: [\n        {\n          mask: {\n            id: maskId,\n            _: [\n              {\n                circle: {\n                  cx: p.cx,\n                  cy: p.cy,\n                  r: outerR,\n                  'stroke-width': 0,\n                  fill: '#fff'\n                }\n              }, {\n                rect: {\n                  x: xMin,\n                  y: -halfGap,\n                  width: p.outerDia,\n                  height: p.gap,\n                  'stroke-width': 0,\n                  fill: '#000'\n                }\n              }, {\n                rect: {\n                  x: -halfGap,\n                  y: yMin,\n                  width: p.gap,\n                  height: p.outerDia,\n                  'stroke-width': 0,\n                  fill: '#000'\n                }\n              }\n            ]\n          }\n        }, {\n          circle: {\n            cx: p.cx,\n            cy: p.cy,\n            r: r,\n            fill: 'none',\n            'stroke-width': thx,\n            mask: \"url(#\" + maskId + \")\"\n          }\n        }\n      ],\n      bbox: [xMin, yMin, xMax, yMax]\n    };\n  };\n\n  module.exports = {\n    circle: circle,\n    rect: rect,\n    polygon: polygon,\n    vector: vector,\n    lowerLeftRect: lowerLeftRect,\n    outline: outline,\n    moire: moire,\n    thermal: thermal\n  };\n\n}).call(this);\n\n},{\"./unique-id\":13}],11:[function(require,module,exports){\n(function() {\n  var ASSUMED_UNITS, HALF_PI, Macro, Plotter, THREEHALF_PI, TWO_PI, arcEps, tool, unique;\n\n  unique = require('./unique-id');\n\n  Macro = require('./macro-tool');\n\n  tool = require('./standard-tool');\n\n  HALF_PI = Math.PI / 2;\n\n  THREEHALF_PI = 3 * HALF_PI;\n\n  TWO_PI = 2 * Math.PI;\n\n  arcEps = 0.0000001;\n\n  ASSUMED_UNITS = 'in';\n\n  Plotter = (function() {\n    function Plotter(file, Reader, Parser) {\n      if (file == null) {\n        file = '';\n      }\n      if (Reader != null) {\n        this.reader = new Reader(file);\n      }\n      if (Parser != null) {\n        this.parser = new Parser;\n      }\n      this.macros = {};\n      this.tools = {};\n      this.currentTool = '';\n      this.defs = [];\n      this.group = {\n        g: {\n          _: []\n        }\n      };\n      this.polarity = 'D';\n      this.current = [];\n      this.stepRepeat = {\n        x: 1,\n        y: 1,\n        i: 0,\n        j: 0\n      };\n      this.srOverClear = false;\n      this.srOverCurrent = [];\n      this.units = null;\n      this.mode = null;\n      this.quad = null;\n      this.lastOp = null;\n      this.region = false;\n      this.done = false;\n      this.pos = {\n        x: 0,\n        y: 0\n      };\n      this.path = [];\n      this.attr = {\n        'stroke-linecap': 'round',\n        'stroke-linejoin': 'round',\n        'stroke-width': 0,\n        stroke: '#000'\n      };\n      this.bbox = {\n        xMin: Infinity,\n        yMin: Infinity,\n        xMax: -Infinity,\n        yMax: -Infinity\n      };\n      this.layerBbox = {\n        xMin: Infinity,\n        yMin: Infinity,\n        xMax: -Infinity,\n        yMax: -Infinity\n      };\n    }\n\n    Plotter.prototype.addTool = function(code, params) {\n      var obj, t;\n      if (this.tools[code] != null) {\n        throw new Error(\"cannot reassign tool \" + code);\n      }\n      if (params.macro != null) {\n        t = this.macros[params.macro].run(code, params.mods);\n      } else {\n        t = tool(code, params);\n      }\n      this.tools[code] = {\n        trace: t.trace,\n        pad: (function() {\n          var _i, _len, _ref, _results;\n          _ref = t.pad;\n          _results = [];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            obj = _ref[_i];\n            _results.push(obj);\n          }\n          return _results;\n        })(),\n        flash: function(x, y) {\n          return {\n            use: {\n              x: x,\n              y: y,\n              'xlink:href': '#' + t.padId\n            }\n          };\n        },\n        bbox: function(x, y) {\n          if (x == null) {\n            x = 0;\n          }\n          if (y == null) {\n            y = 0;\n          }\n          return {\n            xMin: x + t.bbox[0],\n            yMin: y + t.bbox[1],\n            xMax: x + t.bbox[2],\n            yMax: y + t.bbox[3]\n          };\n        }\n      };\n      return this.changeTool(code);\n    };\n\n    Plotter.prototype.changeTool = function(code) {\n      var _ref;\n      this.finishPath();\n      if (this.region) {\n        throw new Error(\"cannot change tool when in region mode\");\n      }\n      if (this.tools[code] == null) {\n        if (!((_ref = this.parser) != null ? _ref.fmat : void 0)) {\n          throw new Error(\"tool \" + code + \" is not defined\");\n        }\n      } else {\n        return this.currentTool = code;\n      }\n    };\n\n    Plotter.prototype.command = function(c) {\n      var code, m, params, state, val, _ref, _ref1, _ref2;\n      if (c.macro != null) {\n        m = new Macro(c.macro);\n        this.macros[m.name] = m;\n        return;\n      }\n      _ref = c.set;\n      for (state in _ref) {\n        val = _ref[state];\n        if (state === 'units' && (this.units != null) && (((_ref1 = this.parser) != null ? _ref1.fmat : void 0) == null)) {\n          throw new Error('cannot redefine units');\n        } else if (state === 'notation' && (this.notation != null)) {\n          throw new Error('cannot redefine notation');\n        }\n        if (state === 'region') {\n          this.finishPath();\n        }\n        if (state === 'currentTool') {\n          this.changeTool(val);\n        } else {\n          this[state] = val;\n        }\n      }\n      if (c.tool != null) {\n        _ref2 = c.tool;\n        for (code in _ref2) {\n          params = _ref2[code];\n          this.addTool(code, params);\n        }\n      }\n      if (c.op != null) {\n        this.operate(c.op);\n      }\n      if (c[\"new\"] != null) {\n        this.finishLayer();\n        if (c[\"new\"].layer != null) {\n          return this.polarity = c[\"new\"].layer;\n        } else if (c[\"new\"].sr != null) {\n          this.finishSR();\n          return this.stepRepeat = c[\"new\"].sr;\n        }\n      }\n    };\n\n    Plotter.prototype.plot = function() {\n      var block, _ref;\n      while (!this.done) {\n        block = this.reader.nextBlock();\n        if (block === false) {\n          if (((_ref = this.parser) != null ? _ref.fmat : void 0) == null) {\n            throw new Error('end of file encountered before required M02 command');\n          } else {\n            throw new Error('end of drill file encountered before M00/M30 command');\n          }\n        } else {\n          this.command(this.parser.parseCommand(block));\n        }\n      }\n      return this.finish();\n    };\n\n    Plotter.prototype.finish = function() {\n      this.finishPath();\n      this.finishLayer();\n      this.finishSR();\n      this.group.g.fill = 'currentColor';\n      this.group.g.stroke = 'currentColor';\n      return this.group.g.transform = \"translate(0,\" + (this.bbox.yMin + this.bbox.yMax) + \") scale(1,-1)\";\n    };\n\n    Plotter.prototype.finishSR = function() {\n      var layer, m, maskId, u, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;\n      if (this.srOverClear && this.srOverCurrent) {\n        maskId = \"gerber-sr-mask_\" + (unique());\n        m = {\n          mask: {\n            color: '#000',\n            id: maskId,\n            _: []\n          }\n        };\n        m.mask._.push({\n          rect: {\n            fill: '#fff',\n            x: this.bbox.xMin,\n            y: this.bbox.yMin,\n            width: this.bbox.xMax - this.bbox.xMin,\n            height: this.bbox.yMax - this.bbox.yMin\n          }\n        });\n        for (x = _i = 0, _ref = this.stepRepeat.x * this.stepRepeat.i, _ref1 = this.stepRepeat.i; _ref1 > 0 ? _i < _ref : _i > _ref; x = _i += _ref1) {\n          for (y = _j = 0, _ref2 = this.stepRepeat.y * this.stepRepeat.j, _ref3 = this.stepRepeat.j; _ref3 > 0 ? _j < _ref2 : _j > _ref2; y = _j += _ref3) {\n            _ref4 = this.srOverCurrent;\n            for (_k = 0, _len = _ref4.length; _k < _len; _k++) {\n              layer = _ref4[_k];\n              u = {\n                use: {}\n              };\n              if (x !== 0) {\n                u.use.x = x;\n              }\n              if (y !== 0) {\n                u.use.y = y;\n              }\n              u.use['xlink:href'] = '#' + ((_ref5 = layer.C) != null ? _ref5 : layer.D);\n              if (layer.D != null) {\n                u.use.fill = '#fff';\n              }\n              m.mask._.push(u);\n            }\n          }\n        }\n        this.srOverClear = false;\n        this.srOverCurrent = [];\n        this.defs.push(m);\n        return this.group.g.mask = \"url(#\" + maskId + \")\";\n      }\n    };\n\n    Plotter.prototype.finishLayer = function() {\n      var c, h, id, obj, srId, u, w, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2;\n      this.finishPath();\n      if (!this.current.length) {\n        return;\n      }\n      if (this.stepRepeat.x > 1 || this.stepRepeat.y > 1) {\n        srId = \"gerber-sr_\" + (unique());\n        this.current = [\n          {\n            g: {\n              id: srId,\n              _: this.current\n            }\n          }\n        ];\n        if (this.srOverClear || this.stepRepeat.i < this.layerBbox.xMax - this.layerBbox.xMin || this.stepRepeat.j < this.layerBbox.yMax - this.layerBbox.yMin) {\n          obj = {};\n          obj[this.polarity] = srId;\n          this.srOverCurrent.push(obj);\n          if (this.polarity === 'C') {\n            this.srOverClear = true;\n            this.defs.push(this.current[0]);\n          }\n        }\n        for (x = _i = 0, _ref = this.stepRepeat.x; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {\n          for (y = _j = 0, _ref1 = this.stepRepeat.y; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {\n            if (!(x === 0 && y === 0)) {\n              u = {\n                use: {\n                  'xlink:href': '#' + srId\n                }\n              };\n              if (x !== 0) {\n                u.use.x = x * this.stepRepeat.i;\n              }\n              if (y !== 0) {\n                u.use.y = y * this.stepRepeat.j;\n              }\n              this.current.push(u);\n            }\n          }\n        }\n        this.layerBbox.xMax += (this.stepRepeat.x - 1) * this.stepRepeat.i;\n        this.layerBbox.yMax += (this.stepRepeat.y - 1) * this.stepRepeat.j;\n      }\n      this.addBbox(this.layerBbox, this.bbox);\n      this.layerBbox = {\n        xMin: Infinity,\n        yMin: Infinity,\n        xMax: -Infinity,\n        yMax: -Infinity\n      };\n      if (this.polarity === 'D') {\n        if (this.group.g.mask != null) {\n          this.current.unshift(this.group);\n        }\n        if ((this.group.g.mask == null) && this.group.g._.length) {\n          _ref2 = this.current;\n          for (_k = 0, _len = _ref2.length; _k < _len; _k++) {\n            c = _ref2[_k];\n            this.group.g._.push(c);\n          }\n        } else {\n          this.group = {\n            g: {\n              _: this.current\n            }\n          };\n        }\n      } else if (this.polarity === 'C' && !this.srOverClear) {\n        id = \"gerber-mask_\" + (unique());\n        w = this.bbox.xMax - this.bbox.xMin;\n        h = this.bbox.yMax - this.bbox.yMin;\n        this.current.unshift({\n          rect: {\n            x: this.bbox.xMin,\n            y: this.bbox.yMin,\n            width: w,\n            height: h,\n            fill: '#fff'\n          }\n        });\n        this.defs.push({\n          mask: {\n            id: id,\n            color: '#000',\n            _: this.current\n          }\n        });\n        this.group.g.mask = \"url(#\" + id + \")\";\n      }\n      return this.current = [];\n    };\n\n    Plotter.prototype.finishPath = function() {\n      var key, p, val, _ref;\n      if (this.path.length) {\n        p = {\n          path: {}\n        };\n        if (this.region) {\n          this.path.push('Z');\n        } else {\n          _ref = this.tools[this.currentTool].trace;\n          for (key in _ref) {\n            val = _ref[key];\n            p.path[key] = val;\n          }\n        }\n        p.path.d = this.path;\n        this.current.push(p);\n        return this.path = [];\n      }\n    };\n\n    Plotter.prototype.operate = function(op) {\n      var bbox, ex, ey, shape, sx, sy, t, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;\n      if (op[\"do\"] === 'last') {\n        op[\"do\"] = this.lastOp;\n        console.warn('modal operation codes are deprecated');\n      } else {\n        this.lastOp = op[\"do\"];\n      }\n      sx = this.pos.x;\n      sy = this.pos.y;\n      if (this.notation === 'I') {\n        this.pos.x += (_ref = op.x) != null ? _ref : 0;\n        this.pos.y += (_ref1 = op.y) != null ? _ref1 : 0;\n      } else {\n        this.pos.x = (_ref2 = op.x) != null ? _ref2 : this.pos.x;\n        this.pos.y = (_ref3 = op.y) != null ? _ref3 : this.pos.y;\n      }\n      ex = this.pos.x;\n      ey = this.pos.y;\n      t = this.tools[this.currentTool];\n      if (this.units == null) {\n        if (this.backupUnits != null) {\n          this.units = this.backupUnits;\n          console.warn(\"Warning: units set to '\" + this.units + \"' according to deprecated command G7\" + (this.units === 'in' ? 0 : 1));\n        } else {\n          this.units = ASSUMED_UNITS;\n          console.warn(\"Warning: no units set; assuming inches\");\n        }\n      }\n      if (this.notation == null) {\n        if (((_ref4 = this.parser) != null ? _ref4.fmat : void 0) != null) {\n          this.notation = 'A';\n        } else {\n          throw new Error('format has not been set');\n        }\n      }\n      if (op[\"do\"] === 'move' && this.path.length) {\n        return this.path.push('M', ex, ey);\n      } else if (op[\"do\"] === 'flash') {\n        this.finishPath();\n        if (this.region) {\n          throw new Error('cannot flash while in region mode');\n        }\n        if (t.pad) {\n          _ref5 = t.pad;\n          for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n            shape = _ref5[_i];\n            this.defs.push(shape);\n          }\n          t.pad = false;\n        }\n        this.current.push(t.flash(ex, ey));\n        return this.addBbox(t.bbox(ex, ey), this.layerBbox);\n      } else if (op[\"do\"] === 'int') {\n        if (!this.region && !t.trace) {\n          throw new Error(\"\" + this.currentTool + \" is not a strokable tool\");\n        }\n        if (this.path.length === 0) {\n          this.path.push('M', sx, sy);\n          bbox = !this.region ? t.bbox(sx, sy) : {\n            xMin: sx,\n            yMin: sy,\n            xMax: sx,\n            yMax: sy\n          };\n          this.addBbox(bbox, this.layerBbox);\n        }\n        if (this.mode == null) {\n          this.mode = 'i';\n          console.warn('Warning: no interpolation mode set. Assuming linear interpolation (G01)');\n        }\n        if (this.mode === 'i') {\n          return this.drawLine(sx, sy, ex, ey);\n        } else {\n          if (op.i == null) {\n            op.i = 0;\n          }\n          if (op.j == null) {\n            op.j = 0;\n          }\n          return this.drawArc(sx, sy, ex, ey, op.i, op.j);\n        }\n      }\n    };\n\n    Plotter.prototype.drawLine = function(sx, sy, ex, ey) {\n      var bbox, exm, exp, eym, eyp, halfHeight, halfWidth, sxm, sxp, sym, syp, t, theta;\n      t = this.tools[this.currentTool];\n      bbox = !this.region ? t.bbox(ex, ey) : {\n        xMin: ex,\n        yMin: ey,\n        xMax: ex,\n        yMax: ey\n      };\n      this.addBbox(bbox, this.layerBbox);\n      if (this.region || t.trace['stroke-width'] >= 0) {\n        return this.path.push('L', ex, ey);\n      } else {\n        halfWidth = t.pad[0].rect.width / 2;\n        halfHeight = t.pad[0].rect.height / 2;\n        sxm = sx - halfWidth;\n        sxp = sx + halfWidth;\n        sym = sy - halfHeight;\n        syp = sy + halfHeight;\n        exm = ex - halfWidth;\n        exp = ex + halfWidth;\n        eym = ey - halfHeight;\n        eyp = ey + halfHeight;\n        theta = Math.atan2(ey - sy, ex - sx);\n        if ((0 <= theta && theta < HALF_PI)) {\n          return this.path.push('M', sxm, sym, sxp, sym, exp, eym, exp, eyp, exm, eyp, sxm, syp, 'Z');\n        } else if ((HALF_PI <= theta && theta < Math.PI)) {\n          return this.path.push('M', sxm, sym, sxp, sym, sxp, syp, exp, eyp, exm, eyp, exm, eym, 'Z');\n        } else if ((-Math.PI <= theta && theta < -HALF_PI)) {\n          return this.path.push('M', sxp, sym, sxp, syp, sxm, syp, exm, eyp, exm, eym, exp, eym, 'Z');\n        } else if ((-HALF_PI <= theta && theta < 0)) {\n          return this.path.push('M', sxm, sym, exm, eym, exp, eym, exp, eyp, sxp, syp, sxm, syp, 'Z');\n        }\n      }\n    };\n\n    Plotter.prototype.drawArc = function(sx, sy, ex, ey, i, j) {\n      var c, cand, cen, dist, large, r, rTool, sweep, t, theta, thetaE, thetaS, validCen, xMax, xMin, xn, xp, yMax, yMin, yn, yp, _i, _j, _len, _len1, _ref, _ref1, _ref2;\n      arcEps = 1.01 * Math.pow(10, -(((_ref = (_ref1 = this.parser) != null ? _ref1.format.places[1] : void 0) != null ? _ref : 6) - 1));\n      t = this.tools[this.currentTool];\n      if (!this.region && !t.trace['stroke-width']) {\n        throw Error(\"cannot stroke an arc with non-circular tool \" + this.currentTool);\n      }\n      if (this.quad == null) {\n        throw new Error('arc quadrant mode has not been set');\n      }\n      r = Math.sqrt(Math.pow(i, 2) + Math.pow(j, 2));\n      sweep = this.mode === 'cw' ? 0 : 1;\n      large = 0;\n      validCen = [];\n      cand = [[sx + i, sy + j]];\n      if (this.quad === 's') {\n        cand.push([sx - i, sy - j], [sx - i, sy + j], [sx + i, sy - j]);\n      }\n      for (_i = 0, _len = cand.length; _i < _len; _i++) {\n        c = cand[_i];\n        dist = Math.sqrt(Math.pow(c[0] - ex, 2) + Math.pow(c[1] - ey, 2));\n        if ((Math.abs(r - dist)) < arcEps) {\n          validCen.push({\n            x: c[0],\n            y: c[1]\n          });\n        }\n      }\n      thetaE = 0;\n      thetaS = 0;\n      cen = null;\n      for (_j = 0, _len1 = validCen.length; _j < _len1; _j++) {\n        c = validCen[_j];\n        thetaE = Math.atan2(ey - c.y, ex - c.x);\n        if (thetaE < 0) {\n          thetaE += TWO_PI;\n        }\n        thetaS = Math.atan2(sy - c.y, sx - c.x);\n        if (thetaS < 0) {\n          thetaS += TWO_PI;\n        }\n        if (this.mode === 'cw' && thetaS < thetaE) {\n          thetaS += TWO_PI;\n        } else if (this.mode === 'ccw' && thetaE < thetaS) {\n          thetaE += TWO_PI;\n        }\n        theta = Math.abs(thetaE - thetaS);\n        if (this.quad === 's' && theta <= HALF_PI) {\n          cen = c;\n        } else if (this.quad === 'm') {\n          if (theta >= Math.PI) {\n            large = 1;\n          }\n          cen = {\n            x: c.x,\n            y: c.y\n          };\n        }\n        if (cen != null) {\n          break;\n        }\n      }\n      if (cen == null) {\n        console.warn(\"start \" + sx + \",\" + sy + \" \" + this.mode + \" to end \" + ex + \",\" + ey + \" with center offset \" + i + \",\" + j + \" is an impossible arc in \" + (this.quad === 's' ? 'single' : 'multi') + \" quadrant mode with epsilon set to \" + arcEps);\n        return;\n      }\n      rTool = this.region ? 0 : t.bbox().xMax;\n      if (this.mode === 'cw') {\n        _ref2 = [thetaS, thetaE], thetaE = _ref2[0], thetaS = _ref2[1];\n      }\n      xp = thetaS > 0 ? TWO_PI : 0;\n      yp = HALF_PI + (thetaS > HALF_PI ? TWO_PI : 0);\n      xn = Math.PI + (thetaS > Math.PI ? TWO_PI : 0);\n      yn = THREEHALF_PI + (thetaS > THREEHALF_PI ? TWO_PI : 0);\n      if ((thetaS <= xn && xn <= thetaE)) {\n        xMin = cen.x - r - rTool;\n      } else {\n        xMin = (Math.min(sx, ex)) - rTool;\n      }\n      if ((thetaS <= xp && xp <= thetaE)) {\n        xMax = cen.x + r + rTool;\n      } else {\n        xMax = (Math.max(sx, ex)) + rTool;\n      }\n      if ((thetaS <= yn && yn <= thetaE)) {\n        yMin = cen.y - r - rTool;\n      } else {\n        yMin = (Math.min(sy, ey)) - rTool;\n      }\n      if ((thetaS <= yp && yp <= thetaE)) {\n        yMax = cen.y + r + rTool;\n      } else {\n        yMax = (Math.max(sy, ey)) + rTool;\n      }\n      if (this.quad === 'm' && (Math.abs(sx - ex) < arcEps) && (Math.abs(sy - ey) < arcEps)) {\n        this.path.push('A', r, r, 0, 0, sweep, ex + 2 * i, ey + 2 * j);\n        xMin = cen.x - r - rTool;\n        yMin = cen.y - r - rTool;\n        xMax = cen.x + r + rTool;\n        yMax = cen.y + r + rTool;\n      }\n      this.path.push('A', r, r, 0, large, sweep, ex, ey);\n      return this.addBbox({\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      }, this.layerBbox);\n    };\n\n    Plotter.prototype.addBbox = function(bbox, target) {\n      if (bbox.xMin < target.xMin) {\n        target.xMin = bbox.xMin;\n      }\n      if (bbox.yMin < target.yMin) {\n        target.yMin = bbox.yMin;\n      }\n      if (bbox.xMax > target.xMax) {\n        target.xMax = bbox.xMax;\n      }\n      if (bbox.yMax > target.yMax) {\n        return target.yMax = bbox.yMax;\n      }\n    };\n\n    return Plotter;\n\n  })();\n\n  module.exports = Plotter;\n\n}).call(this);\n\n},{\"./macro-tool\":8,\"./standard-tool\":12,\"./unique-id\":13}],12:[function(require,module,exports){\n(function() {\n  var shapes, standardTool, unique;\n\n  unique = require('./unique-id');\n\n  shapes = require('./pad-shapes');\n\n  standardTool = function(tool, p) {\n    var hole, id, mask, maskId, pad, result, shape;\n    result = {\n      pad: [],\n      trace: false\n    };\n    p.cx = 0;\n    p.cy = 0;\n    id = \"tool-\" + tool + \"-pad-\" + (unique());\n    shape = '';\n    if ((p.dia != null) && (p.verticies == null)) {\n      if ((p.obround != null) || (p.width != null) || (p.height != null) || (p.degrees != null)) {\n        throw new Error(\"incompatible parameters for tool \" + tool);\n      }\n      if (p.dia < 0) {\n        throw new RangeError(\"\" + tool + \" circle diameter out of range (\" + p.dia + \"<0)\");\n      }\n      shape = 'circle';\n      if (p.hole == null) {\n        result.trace = {\n          'stroke-width': p.dia,\n          fill: 'none'\n        };\n      }\n    } else if ((p.width != null) && (p.height != null)) {\n      if ((p.dia != null) || (p.verticies != null) || (p.degrees != null)) {\n        throw new Error(\"incompatible parameters for tool \" + tool);\n      }\n      if (p.width <= 0) {\n        throw new RangeError(\"\" + tool + \" rect width out of range (\" + p.width + \"<=0)\");\n      }\n      if (p.height <= 0) {\n        throw new RangeError(\"\" + tool + \" rect height out of range (\" + p.height + \"<=0)\");\n      }\n      shape = 'rect';\n      if (!((p.hole != null) || p.obround)) {\n        result.trace = {};\n      }\n    } else if ((p.dia != null) && (p.verticies != null)) {\n      if ((p.obround != null) || (p.width != null) || (p.height != null)) {\n        throw new Error(\"incompatible parameters for tool \" + tool);\n      }\n      if (p.verticies < 3 || p.verticies > 12) {\n        throw new RangeError(\"\" + tool + \" polygon points out of range (\" + p.verticies + \"<3 or >12)]\");\n      }\n      shape = 'polygon';\n    } else {\n      throw new Error('unidentified standard tool shape');\n    }\n    pad = shapes[shape](p);\n    if (p.hole != null) {\n      hole = null;\n      if ((p.hole.dia != null) && (p.hole.width == null) && (p.hole.height == null)) {\n        if (!(p.hole.dia >= 0)) {\n          throw new RangeError(\"\" + tool + \" hole diameter out of range (\" + p.hole.dia + \"<0)\");\n        }\n        hole = shapes.circle({\n          cx: p.cx,\n          cy: p.cy,\n          dia: p.hole.dia\n        });\n        hole = hole.shape;\n        hole.circle.fill = '#000';\n      } else if ((p.hole.width != null) && (p.hole.height != null)) {\n        if (!(p.hole.width >= 0)) {\n          throw new RangeError(\"\" + tool + \" hole width out of range (\" + p.hole.width + \"<0)\");\n        }\n        if (!(p.hole.height >= 0)) {\n          throw new RangeError(\"\" + tool + \" hole height out of range\");\n        }\n        hole = shapes.rect({\n          cx: p.cx,\n          cy: p.cy,\n          width: p.hole.width,\n          height: p.hole.height\n        });\n        hole = hole.shape;\n        hole.rect.fill = '#000';\n      } else {\n        throw new Error(\"\" + tool + \" has invalid hole parameters\");\n      }\n      maskId = id + '-mask';\n      mask = {\n        mask: {\n          id: id + \"-mask\",\n          _: [\n            {\n              rect: {\n                x: pad.bbox[0],\n                y: pad.bbox[1],\n                width: pad.bbox[2] - pad.bbox[0],\n                height: pad.bbox[3] - pad.bbox[1],\n                fill: '#fff'\n              }\n            }, hole\n          ]\n        }\n      };\n      pad.shape[shape].mask = \"url(#\" + maskId + \")\";\n      result.pad.push(mask);\n    }\n    if (id) {\n      pad.shape[shape].id = id;\n    }\n    result.pad.push(pad.shape);\n    result.bbox = pad.bbox;\n    result.padId = id;\n    return result;\n  };\n\n  module.exports = standardTool;\n\n}).call(this);\n\n},{\"./pad-shapes\":10,\"./unique-id\":13}],13:[function(require,module,exports){\n(function() {\n  var generateUniqueId, id;\n\n  id = 1000;\n\n  generateUniqueId = function() {\n    return id++;\n  };\n\n  module.exports = generateUniqueId;\n\n}).call(this);\n\n},{}],14:[function(require,module,exports){\nvar convertGerber, gerberToSvg;\n\ngerberToSvg = require('gerber-to-svg');\n\nconvertGerber = function(filename, gerber) {\n  var e, e2, obj, string;\n  if (typeof gerber === 'object') {\n    obj = gerber;\n  } else {\n    try {\n      obj = gerberToSvg(gerber, {\n        object: true\n      });\n    } catch (_error) {\n      e = _error;\n      try {\n        obj = gerberToSvg(gerber, {\n          drill: true,\n          object: true\n        });\n      } catch (_error) {\n        e2 = _error;\n        obj = {};\n      }\n    }\n  }\n  if (obj.svg != null) {\n    string = gerberToSvg(obj);\n  } else {\n    string = '';\n  }\n  return {\n    filename: filename,\n    svgObj: obj,\n    svgString: string\n  };\n};\n\nself.addEventListener('message', function(e) {\n  var filename, gerber;\n  gerber = e.data.gerber;\n  filename = e.data.filename;\n  return self.postMessage(convertGerber(filename, gerber));\n}, false);\n\n\n\n},{\"gerber-to-svg\":6}]},{},[14])"],{type:"text/javascript"}))),e=new Worker(window.URL.createObjectURL(new Blob(["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n;(function () {\n\n  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  function InvalidCharacterError(message) {\n    this.message = message;\n  }\n  InvalidCharacterError.prototype = new Error;\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n  // encoder\n  // [https://gist.github.com/999166] by [https://github.com/nignag]\n  object.btoa || (\n  object.btoa = function (input) {\n    var str = String(input);\n    for (\n      // initialize result and counter\n      var block, charCode, idx = 0, map = chars, output = '';\n      // if the next str index does not exist:\n      //   change the mapping table to \"=\"\n      //   check if d has no fractional digits\n      str.charAt(idx | 0) || (map = '=', idx % 1);\n      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n      output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n    ) {\n      charCode = str.charCodeAt(idx += 3/4);\n      if (charCode > 0xFF) {\n        throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n      }\n      block = block << 8 | charCode;\n    }\n    return output;\n  });\n\n  // decoder\n  // [https://gist.github.com/1020396] by [https://github.com/atk]\n  object.atob || (\n  object.atob = function (input) {\n    var str = String(input).replace(/=+$/, '');\n    if (str.length % 4 == 1) {\n      throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    }\n    for (\n      // initialize result and counters\n      var bc = 0, bs, buffer, idx = 0, output = '';\n      // get next character\n      buffer = str.charAt(idx++);\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n        // and if not first of each 4 characters,\n        // convert the first 8 bits to one ascii character\n        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  });\n\n}());\n\n},{}],2:[function(require,module,exports){\nvar Base64;\n\nBase64 = require('Base64');\n\nif (typeof self.btoa !== 'function') {\n  self.btoa = Base64.btoa;\n}\n\nself.addEventListener('message', function(e) {\n  var name, string;\n  string = e.data.string;\n  name = e.data.name;\n  return self.postMessage({\n    name: name,\n    string: btoa(string)\n  });\n});\n\n\n\n},{\"Base64\":1}]},{},[2])"],{type:"text/javascript"}))),c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)
}return g(b,a),b.prototype.initialize=function(){return this.attachConverterHandler(),this.attachEncoderHandler(),this.on("change:svg change:style",this.encode)},b.prototype.encode=function(a){var b,c,d;return a.set("svg64",!1),c=a.get("svg"),d=a.get("style"),null!=d&&(b=c.match(/^.*?>/)[0].length,c=c.slice(0,b)+d+c.slice(b)),e.postMessage({name:a.get("name"),string:c})},b.prototype.convert=function(a,b){return d.postMessage({filename:a,gerber:b})},b.prototype.attachEncoderHandler=function(){var a,b;return b=this,a=function(a){var c;return(c=b.findWhere({name:a.data.name}))?c.set("svg64",a.data.string):void 0},e.addEventListener("message",a,!1)},b.prototype.attachConverterHandler=function(){var a,b;return b=this,a=function(a){var c;return(c=b.findWhere({name:a.data.filename}))?(c.set("svgObj",a.data.svgObj),c.set("svg",a.data.svgString),c.trigger("processEnd",c)):void 0},d.addEventListener("message",a,!1)},b}(Backbone.Collection),b.exports=c},{}],"/Users/mc/projects/svgerber/src/color-options.coffee":[function(a,b){b.exports={cf:{bare:{bg:"#C87533",txt:"white"},gold:{bg:"goldenrod",txt:"white"},"Ni/Au":{bg:"whitesmoke",txt:"black"},hasl:{bg:"silver",txt:"black"}},sm:{red:{bg:"darkred",txt:"white"},orange:{bg:"darkorange",txt:"black"},yellow:{bg:"#FFFF66",txt:"black"},green:{bg:"darkgreen",txt:"white"},blue:{bg:"navy",txt:"white"},purple:{bg:"indigo",txt:"white"},black:{bg:"black",txt:"white"},white:{bg:"white",txt:"black"}},ss:{red:{bg:"red",txt:"white"},yellow:{bg:"yellow",txt:"black"},green:{bg:"green",txt:"white"},blue:{bg:"blue",txt:"white"},black:{bg:"black",txt:"white"},white:{bg:"white",txt:"black"}}}},{}],"/Users/mc/projects/svgerber/src/github-api-url.coffee":[function(a,b){b.exports=function(a){var b,c,d,e,f,g;return a=null!=(g=a.match(/github\.com\S+/))?g[0].split("/"):void 0,(null!=a?a.length:void 0)?(b="https://api.github.com/repos",d=a[1],f=a[2],c=a[4],e=a.slice(5).join("/"),a=""+b+"/"+d+"/"+f+"/contents/"+e+"?ref="+c):!1}},{}],"/Users/mc/projects/svgerber/src/layer-options.coffee":[function(a,b){b.exports=[{val:"tcu",desc:"top copper",match:/\.(gtl)|(cmp)$/i,side:"top",mult:!1},{val:"tsm",desc:"top soldermask",match:/\.(gts)|(stc)$/i,side:"top",mult:!1},{val:"tss",desc:"top silkscreen",match:/\.(gto)|(plc)$/i,side:"top",mult:!1},{val:"tsp",desc:"top solderpaste",match:/\.(gtp)|(crc)$/i,side:"top",mult:!1},{val:"bcu",desc:"bottom copper",match:/\.(gbl)|(sol)$/i,side:"bottom",mult:!1},{val:"bsm",desc:"bottom soldermask",match:/\.(gbs)|(sts)$/i,side:"bottom",mult:!1},{val:"bss",desc:"bottom silkscreen",match:/\.(gbo)|(pls)$/i,side:"bottom",mult:!1},{val:"bsp",desc:"bottom solderpaste",match:/\.(gbp)|(crs)$/i,side:"bottom",mult:!1},{val:"icu",desc:"inner copper",match:/\.(gp\d+)|(g\d+l)$/i,side:"none",mult:!0},{val:"out",desc:"board outline",match:/(\.(gko)|(mil)$)|edge/i,side:"both",mult:!1},{val:"drw",desc:"gerber drawing",match:/\.gbr$/i,side:"none",mult:!0},{val:"drl",desc:"drill hits",match:/(\.xln$)|(\.drl$)|(\.txt$)|(\.drd$)/i,side:"both",mult:!0}]},{}],"/Users/mc/projects/svgerber/src/models/board.coffee":[function(a,b){var c,d,e,f,g={}.hasOwnProperty,h=function(a,b){function c(){this.constructor=a}for(var d in b)g.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};e=a("./render"),d=a("../collections/layers"),f=a("../layer-options"),c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return h(b,a),b.prototype.defaults=_.extend({boardLayers:{},style:'<style type="text/css"> .Board--board { color: dimgrey; } .Board--cu { color: lightgrey; } .Board--cf { color: goldenrod; } .Board--sm { color: darkgreen; opacity: 0.75; } .Board--ss { color: white; } .Board--sp { color: silver; } .Board--out { color: black; } </style>'},e.prototype.defaults),b.prototype.initialize=function(){var a;return a=this.get("layers"),this.listenTo(a,"change:type change:svg change:gerber remove",_.debounce(this.handleLayersChange,10))},b.prototype.getBoardLayers=function(){var a,b;return b=this.get("name"),a=this.get("layers").filter(function(a){var c;return c=_.find(f,{val:a.get("type")}),(null!=c?c.side:void 0)===b||"both"===(null!=c?c.side:void 0)}),this.set("boardLayers",_.map(a,function(a){return{type:a.get("type"),svgObj:a.get("svgObj")}})),this.trigger("buildNeeded",this)},b.prototype.handleLayersChange=function(){var a,b,c;return a=this.get("layers"),a.validateLayers()&&(b=null!=(c=a.filter(function(a){return null!=a.get("svgObj")}))?c:[],a.length===b.length)?this.getBoardLayers():void 0},b}(e),b.exports=c},{"../collections/layers":"/Users/mc/projects/svgerber/src/collections/layers.coffee","../layer-options":"/Users/mc/projects/svgerber/src/layer-options.coffee","./render":"/Users/mc/projects/svgerber/src/models/render.coffee"}],"/Users/mc/projects/svgerber/src/models/layer.coffee":[function(a,b){var c,d,e,f={}.hasOwnProperty,g=function(a,b){function c(){this.constructor=a}for(var d in b)f.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d=a("./render"),e=a("../layer-options"),c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return g(b,a),b.prototype.defaults=_.extend({gerber:"",type:"oth",svgObj:null},d.prototype.defaults),b.prototype.initialize=function(){return this.setLayerType(),this.once("change:svgObj",function(){return this.unset("gerber")}),this.once("change:svg",function(){return this.get("svg").length?void 0:this.set("type","oth")})},b.prototype.setLayerType=function(){var a,b,c,d;for(b="drw",c=0,d=e.length;d>c;c++)if(a=e[c],a.match.test(this.get("name"))){b=a.val;break}return this.set("type",b)},b.prototype.validate=function(a){var b;return"oth"===a.type||_.find(e,{val:a.type}).mult||(b=this.collection.where({type:a.type}),1===b.length)?null:"duplicate layer selection"},b}(d),b.exports=c},{"../layer-options":"/Users/mc/projects/svgerber/src/layer-options.coffee","./render":"/Users/mc/projects/svgerber/src/models/render.coffee"}],"/Users/mc/projects/svgerber/src/models/render.coffee":[function(a,b){var c,d={}.hasOwnProperty,e=function(a,b){function c(){this.constructor=a}for(var e in b)d.call(b,e)&&(a[e]=b[e]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return e(b,a),b.prototype.defaults={name:"",svg:"",svgObj:null,svg64:!1},b}(Backbone.Model),b.exports=c},{}],"/Users/mc/projects/svgerber/src/routers/router.coffee":[function(a,b){var c;c=$("#main-nav").height(),b.exports=Backbone.Router.extend({initialize:function(){return this.route(/.*/,this.scroll)},scroll:function(){var a,b;return b=Backbone.history.fragment,a="."+b+"-anchor",$("html, body").animate({scrollTop:b?$(a).offset().top-1.15*c:0},300)}})},{}],"/Users/mc/projects/svgerber/src/views/app-view.coffee":[function(a,b){var c,d,e,f,g,h,i,j,k,l,m,n;l=a("../github-api-url"),f=a("./filelist-item"),h=a("./layer-view"),d=a("./board-view"),e=a("./color-picker"),i=a("./modal-view"),j=a("./unsupported-view"),g=a("../collections/layers"),m=new g,c=a("../collections/boards"),k=new c,k.add([{name:"top",layers:m},{name:"bottom",layers:m}]),n=new i,b.exports=Backbone.View.extend({el:"#svgerber-app",events:{"drop #dropzone":"handleFileSelect","dragover #dropzone":function(a){return a.preventDefault(),a.stopPropagation(),a.originalEvent.dataTransfer.dropEffect="copy"},"change #upload-select":"handleFileSelect","click #sample-btn":"loadSamples","click #url-paste-btn":"showPaste","click #url-submit-btn":"processUrls","click #url-cancel-btn":"hidePaste"},initialize:function(){return this.checkSupport(),this.listenTo(m,"add",this.addFilelistItem),this.listenTo(m,"processEnd",this.addBoardLayer),this.listenTo(k,"change:svg",this.addBoardRender),this.listenTo(k,"change:svg",this.handleColorPicker),this.listenTo(m,"add remove",this.handleNavIcons),this.$el.append(n.render().el),this.listenTo(m,"openModal",this.handleOpenModal),this.listenTo(k,"openModal",this.handleOpenModal)},checkSupport:function(){var a;return"undefined"==typeof document.createElement("svg").getAttributeNS||"undefined"==typeof Worker?(a=new j,this.$el.append(a.render().el)):void 0},restart:function(){return m.remove(m.models)},addFilelistItem:function(a){var b;return b=new f({model:a}),$("#filelist").append(b.render().el)},addBoardLayer:function(a){var b;return a.get("svg").length?(b=new h({model:a}),$("#layer-output").append(b.render().el)):void 0},addBoardRender:function(a){var b,c;return b=$("#board-output").find(".LayerHeading").text(),a.get("svg").length&&null==b.match(a.get("name"))?(c=new d({model:a}),$("#board-output").append(c.render().el)):void 0},handleOpenModal:function(a){return n.openModal(a)},handleColorPicker:function(a){var b,c,d;return c=$("#board-output").siblings(".ColorPicker").length,b=$("#board-output").children().length,!c&&b?(d=new e({collection:a}),$("#board-output").after(d.render().el)):void 0},handleFileSelect:function(a){var b,c,d,e,f,g,h;for(a.preventDefault(),a.stopPropagation(),c=null!=(g=a.originalEvent)&&null!=(h=g.dataTransfer)?h.files:void 0,null==c&&(c=a.target.files),d=function(a){var b;return m.add({name:a.name},{validate:!0}),b=new FileReader,b.onloadend=function(b){return b.stopPropagation(),b.preventDefault(),b.target.readyState===FileReader.DONE?m.findWhere({name:a.name}).set("gerber",b.target.result):void 0},b.readAsText(a)},e=0,f=c.length;f>e;e++)b=c[e],d(b);return!1},loadSamples:function(){var a,b,c,d,e;for(b=["clockblock-hub-B_Cu.gbl","clockblock-hub-B_Mask.gbs","clockblock-hub-B_SilkS.gbo","clockblock-hub-Edge_Cuts.gbr","clockblock-hub-F_Cu.gtl","clockblock-hub-F_Mask.gts","clockblock-hub-F_Paste.gtp","clockblock-hub-F_SilkS.gto","clockblock-hub-NPTH.drl","clockblock-hub.drl"],this.restart(),e=[],c=0,d=b.length;d>c;c++)a=b[c],e.push(function(a){return m.add({name:a},{validate:!0}),$.ajax({type:"GET",url:"./"+a,dataType:"text",success:function(b){return m.findWhere({name:a}).set("gerber",b)}})}(a));return e},showPaste:function(){return $("#url-paste-form").removeClass("is-hidden")},hidePaste:function(){return $("#url-paste").val(""),$("#url-paste-form").addClass("is-hidden")},processUrls:function(){var a,b,c,d;for(b=$("#url-paste").val().split("\n"),c=0,d=b.length;d>c;c++)a=b[c],a=l(a),a&&$.ajax({type:"GET",url:a,contentType:"application/vnd.github.VERSION.raw",dataType:"json",success:function(a){return m.add({name:a.name},{validate:!0}),m.findWhere({name:a.name}).set("gerber",a.content)}});return this.hidePaste()},handleNavIcons:function(){return 0===m.length?($("#nav-filelist, #nav-output, #nav-layers").addClass("is-disabled"),this.changeIcon($(".Nav--brand"),"octicon-jump-up"),$("#nav-top").off("click",this.restart)):($("#nav-filelist, #nav-output, #nav-layers").removeClass("is-disabled"),this.changeIcon($(".Nav--brand"),"octicon-sync"),$("#nav-top").on("click",this.restart))},changeIcon:function(a,b){return a.removeClass(function(a,b){var c;return null!=(c=b.match(/octicon-\S+/g))?c.join(" "):void 0}).addClass(b)}})},{"../collections/boards":"/Users/mc/projects/svgerber/src/collections/boards.coffee","../collections/layers":"/Users/mc/projects/svgerber/src/collections/layers.coffee","../github-api-url":"/Users/mc/projects/svgerber/src/github-api-url.coffee","./board-view":"/Users/mc/projects/svgerber/src/views/board-view.coffee","./color-picker":"/Users/mc/projects/svgerber/src/views/color-picker.coffee","./filelist-item":"/Users/mc/projects/svgerber/src/views/filelist-item.coffee","./layer-view":"/Users/mc/projects/svgerber/src/views/layer-view.coffee","./modal-view":"/Users/mc/projects/svgerber/src/views/modal-view.coffee","./unsupported-view":"/Users/mc/projects/svgerber/src/views/unsupported-view.coffee"}],"/Users/mc/projects/svgerber/src/views/board-view.coffee":[function(a,b){var c,d,e={}.hasOwnProperty,f=function(a,b){function c(){this.constructor=a}for(var d in b)e.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d=a("./render-view"),c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return f(b,a),b.prototype.className="BoardContainer",b.prototype.initialize=function(){return b.__super__.initialize.call(this),this.listenTo(this.model,"change:svg change:style",this.render)},b.prototype.render=function(){var a;return b.__super__.render.call(this),a=this.model.get("svg"),this.$(".LayerTitle").html("board "+this.model.get("name")),this.$("svg").prepend(this.model.get("style")),a.length?this:(this.model.trigger("renderRemove"),this.remove())},b}(d),b.exports=c},{"./render-view":"/Users/mc/projects/svgerber/src/views/render-view.coffee"}],"/Users/mc/projects/svgerber/src/views/color-picker.coffee":[function(a,b){var c;c=a("../color-options"),b.exports=Backbone.View.extend({tagName:"div",className:"ColorPicker",template:_.template($("#color-picker-template").html()),events:{"click .ColorPicker--btn":"handleColorChange","click #show-color-picker-btn":"toggleColorPicker"},initialize:function(){return this.listenTo(this.collection.collection,"renderRemove",this.handleBoardRemoval)},render:function(){return this.$el.html(this.template({cfColors:c.cf,smColors:c.sm,ssColors:c.ss})),this.$el.find(".ColorPicker--box").addClass("is-retracted"),this.$el.find(".ColorPicker--btn").each(function(){var a,b,d,e;return a=$(this),d=a.parent().attr("id").slice(6,8),e=a.html(),b=c[d][e],a.css("background-color",b.bg).css("color",b.txt)}),this.getCurrentColors(),this},getCurrentColors:function(){var a,b,d,e,f,g,h,i,j,k,l,m;for(a=this.collection.collection.pluck("style"),i=a[0],l=["cf","sm","ss"],m=[],j=0,k=l.length;k>j;j++)d=l[j],h=new RegExp(".Board--"+d+" { color: .*?;"),e=i.match(h),b=e[0].slice(20,-1),g=c[d],f=_.findKey(g,_.find(g,function(a){return a.bg===b})),m.push(this.$el.find("#board-"+d+"-color-buttons").children().each(function(){var a;return(a=$(this)).html()===f?a.prop("disabled",!0):void 0}));return m},handleColorChange:function(a){var b;return b=$(a.currentTarget),b.prop("disabled",!0).siblings().prop("disabled",!1),_.delay(function(a){var d,e,f,g,h;switch(e=b.parent().attr("id").slice(6,8),g=b.html(),d=c[e][g].bg,e){case"cf":f=".Board--cf { color: "+d+"; }",h=/\.Board--cf {.*?}/;break;case"sm":f=".Board--sm { color: "+d+"; opacity: 0.75; }",h=/\.Board--sm {.*?}/;break;case"ss":f=".Board--ss { color: "+d+"; }",h=/\.Board--ss {.*?}/}return a.collection.collection.each(function(a){return a.set("style",a.get("style").replace(h,f))})},10,this)},handleBoardRemoval:function(){var a;return a=!1,this.collection.collection.each(function(b){return b.get("svg").length?a=!0:void 0}),a?void 0:this.remove()},toggleColorPicker:function(){var a,b;return b=$(".ColorPicker--box"),a=$("#show-color-picker-btn").children(".octicon"),b.hasClass("is-retracted")?(b.removeClass("is-retracted"),this.changeIcon(a,"octicon-chevron-up")):b.length?(b.addClass("is-retracted"),this.changeIcon(a,"octicon-chevron-down")):void 0},changeIcon:function(a,b){return a.removeClass(function(a,b){var c;return null!=(c=b.match(/octicon-\S+/g))?c.join(" "):void 0}).addClass(b)}})},{"../color-options":"/Users/mc/projects/svgerber/src/color-options.coffee"}],"/Users/mc/projects/svgerber/src/views/filelist-item.coffee":[function(a,b){var c;c=a("../layer-options"),b.exports=Backbone.View.extend({tagName:"li",className:"UploadList--item",template:_.template($("#filelist-item-template").html()),events:{"click .UploadList--itemDelete":"removeLayer","change .UploadList--SelectMenu":"changeLayerType"},initialize:function(){return this.listenTo(this.model,"remove",this.remove),this.listenTo(this.model,"valid invalid",this.renderValidation),this.listenToOnce(this.model,"processEnd",this.renderProcessing)},renderValidation:function(){var a;return a=this.$el.find(".UploadList--selectIcon"),this.model.validationError?(this.$el.removeClass("is-valid").addClass("is-invalid"),this.changeIcon(a,"octicon-circle-slash")):(this.$el.removeClass("is-invalid").addClass("is-valid"),this.changeIcon(a,"octicon-chevron-right"))},renderProcessing:function(){return null==this.model.get("svgObj")?this.$el.addClass("is-processing"):(this.$el.removeClass("is-processing"),this.model.get("svg")?void 0:(this.$el.addClass("is-unprocessable"),this.$el.find(".UploadList--text").html("did not process"),this.$el.find("select.UploadList--SelectMenu").remove()))},render:function(){return this.$el.html(this.template({filename:this.model.get("name"),type:this.model.get("type"),options:c})),this.$el.find("option[value='"+this.model.get("type")+"']").prop("selected",!0),this.renderValidation(),this.renderProcessing(),this},removeLayer:function(){var a;return this.undelegateEvents(),a=this.model,this.$el.animate({height:0},{duration:100,queue:!1,easing:"linear",complete:function(){return a.collection.remove(a)}})},changeLayerType:function(){return this.model.set("type",this.$el.find("option:selected").attr("value"))},changeIcon:function(a,b){return a.removeClass(function(a,b){var c;return null!=(c=b.match(/octicon-\S+/g))?c.join(" "):void 0}).addClass(b)}})},{"../layer-options":"/Users/mc/projects/svgerber/src/layer-options.coffee"}],"/Users/mc/projects/svgerber/src/views/layer-view.coffee":[function(a,b){var c,d,e,f={}.hasOwnProperty,g=function(a,b){function c(){this.constructor=a}for(var d in b)f.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d=a("./render-view"),e=a("../layer-options"),c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return g(b,a),b.prototype.className="LayerContainer",b.prototype.initialize=function(){return b.__super__.initialize.call(this),this.listenTo(this.model,"change:type",this.renderTitle)},b.prototype.renderTitle=function(){return this.$(".LayerTitle").html(_.find(e,{val:this.model.get("type")}).desc)},b.prototype.render=function(){return b.__super__.render.call(this),this.renderTitle(),this},b}(d),b.exports=c},{"../layer-options":"/Users/mc/projects/svgerber/src/layer-options.coffee","./render-view":"/Users/mc/projects/svgerber/src/views/render-view.coffee"}],"/Users/mc/projects/svgerber/src/views/modal-view.coffee":[function(a,b){var c,d,e=function(a,b){return function(){return a.apply(b,arguments)}},f={}.hasOwnProperty,g=function(a,b){function c(){this.constructor=a}for(var d in b)f.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d="undefined"!=typeof document.createElement("a").download,c=function(a){function b(){return this.resize=e(this.resize,this),b.__super__.constructor.apply(this,arguments)}return g(b,a),b.prototype.tagName="div",b.prototype.className="Modal",b.prototype.template=_.template($("#modal-template").html()),b.prototype.events={click:"handleClick"},b.prototype.initialize=function(){return this.closeModal()},b.prototype.render=function(a){var b;return b=null!=a?a.get("svg64"):void 0,this.$el.html(this.template({name:null!=a?a.get("name"):void 0,src:null!=b?"data:image/svg+xml;base64,"+b:"",canDownload:d})),this.resize(),this},b.prototype.resize=function(){var a,b,c,d,e;return a=this.$el.height(),e=this.$el.width(),b=this.$(".Modal--img"),c=b.height(),d=b.width(),e/d>a/c?b.height(.9*a):b.width(.9*e)},b.prototype.openModal=function(a){return this.$el.removeClass("is-hidden"),this.render(a)},b.prototype.closeModal=function(){return this.$el.addClass("is-hidden")},b.prototype.handleClick=function(){return this.closeModal()},b}(Backbone.View),b.exports=c},{}],"/Users/mc/projects/svgerber/src/views/render-view.coffee":[function(a,b){var c,d,e={}.hasOwnProperty,f=function(a,b){function c(){this.constructor=a}for(var d in b)e.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d="undefined"!=typeof document.createElement("a").download,c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return f(b,a),b.prototype.tagName="div",b.prototype.template=_.template($("#board-layer-template").html()),b.prototype.events={"click .Btn--download":"handleDownloadClick","click .LayerDrawing":"handleClick"},b.prototype.initialize=function(){return this.listenTo(this.model,"change:svg64",this.handleDownloadLink),this.listenTo(this.model,"remove",this.remove)},b.prototype.handleDownloadClick=function(a){return d?void 0:(a.preventDefault(),a.stopPropagation(),this.handleClick())},b.prototype.handleClick=function(){return this.model.trigger("openModal",this.model)},b.prototype.render=function(){return this.$el.html(this.template({name:this.model.get("name"),img:this.model.get("svg")})),this},b.prototype.handleDownloadLink=function(){var a,b;return a=this.$(".Btn--download"),b=this.model.get("svg64"),b?(d&&a.attr("href","data:image/svg+xml;base64,"+b),a.removeClass("is-disabled")):a.addClass("is-disabled")},b}(Backbone.View),b.exports=c},{}],"/Users/mc/projects/svgerber/src/views/unsupported-view.coffee":[function(a,b){var c,d,e={}.hasOwnProperty,f=function(a,b){function c(){this.constructor=a}for(var d in b)e.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d="undefined"!=typeof document.createElement("a").download,c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return f(b,a),b.prototype.tagName="div",b.prototype.className="Unsupported",b.prototype.template=_.template($("#unsupported-template").html()),b.prototype.events={"click .Unsupported--btn":"tryAnyway"},b.prototype.render=function(){return this.$el.html(this.template()),this},b.prototype.tryAnyway=function(){return this.$el.remove()},b}(Backbone.View),b.exports=c},{}]},{},["./src/index.coffee"]);