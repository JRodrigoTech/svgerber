!function e(n,r,t){function o(s,i){if(!r[s]){if(!n[s]){var l="function"==typeof require&&require;if(!i&&l)return l(s,!0);if(a)return a(s,!0);var c=new Error("Cannot find module '"+s+"'");throw c.code="MODULE_NOT_FOUND",c}var u=r[s]={exports:{}};n[s][0].call(u.exports,function(e){var r=n[s][1][e];return o(r?r:e)},u,u.exports,e,n,r,t)}return r[s].exports}for(var a="function"==typeof require&&require,s=0;s<t.length;s++)o(t[s]);return o}({"./src/index.coffee":[function(e,n,r){var t,o,a,s,i,l;o=e("Base64"),"function"!=typeof window.btoa&&(window.btoa=o.btoa),"function"!=typeof window.atob&&(window.atob=o.atob),("undefined"==typeof document.createElement("svg").getAttributeNS||"undefined"==typeof Worker||"undefined"==typeof FileReader)&&(l=new(e("./views/unsupported-view")),$("body").append(l.render().el)),t=e("./views/app-view"),s=new t,a=e("./routers/router"),i=new a,Backbone.history.start()},{"./routers/router":"/Users/mc/cloned/svgerber/src/routers/router.coffee","./views/app-view":"/Users/mc/cloned/svgerber/src/views/app-view.coffee","./views/unsupported-view":"/Users/mc/cloned/svgerber/src/views/unsupported-view.coffee",Base64:"/Users/mc/cloned/svgerber/node_modules/Base64/base64.js"}],"/Users/mc/cloned/svgerber/node_modules/Base64/base64.js":[function(e,n,r){!function(){function e(e){this.message=e}var n="undefined"!=typeof r?r:this,t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";e.prototype=new Error,e.prototype.name="InvalidCharacterError",n.btoa||(n.btoa=function(n){for(var r,o,a=String(n),s=0,i=t,l="";a.charAt(0|s)||(i="=",s%1);l+=i.charAt(63&r>>8-s%1*8)){if(o=a.charCodeAt(s+=.75),o>255)throw new e("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");r=r<<8|o}return l}),n.atob||(n.atob=function(n){var r=String(n).replace(/=+$/,"");if(r.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var o,a,s=0,i=0,l="";a=r.charAt(i++);~a&&(o=s%4?64*o+a:a,s++%4)?l+=String.fromCharCode(255&o>>(-2*s&6)):0)a=t.indexOf(a);return l})}()},{}],"/Users/mc/cloned/svgerber/src/collections/boards.coffee":[function(e,n,r){var t,o,a,s,i=function(e,n){function r(){this.constructor=e}for(var t in n)l.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},l={}.hasOwnProperty;a=e("./renders"),t=e("../models/board"),s=new Worker(window.URL.createObjectURL(new Blob(["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array ? array.length : 0;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n\n},{}],2:[function(require,module,exports){\nvar baseCallback = require('../internal/baseCallback'),\n    basePullAt = require('../internal/basePullAt');\n\n/**\n * Removes all elements from `array` that `predicate` returns truthy for\n * and returns an array of the removed elements. The predicate is bound to\n * `thisArg` and invoked with three arguments: (value, index, array).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * **Note:** Unlike `_.filter`, this method mutates `array`.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to modify.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {Array} Returns the new array of removed elements.\n * @example\n *\n * var array = [1, 2, 3, 4];\n * var evens = _.remove(array, function(n) {\n *   return n % 2 == 0;\n * });\n *\n * console.log(array);\n * // => [1, 3]\n *\n * console.log(evens);\n * // => [2, 4]\n */\nfunction remove(array, predicate, thisArg) {\n  var result = [];\n  if (!(array && array.length)) {\n    return result;\n  }\n  var index = -1,\n      indexes = [],\n      length = array.length;\n\n  predicate = baseCallback(predicate, thisArg, 3);\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result.push(value);\n      indexes.push(index);\n    }\n  }\n  basePullAt(array, indexes);\n  return result;\n}\n\nmodule.exports = remove;\n\n},{\"../internal/baseCallback\":5,\"../internal/basePullAt\":19}],3:[function(require,module,exports){\nvar baseEach = require('../internal/baseEach'),\n    createFind = require('../internal/createFind');\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n * invoked with three arguments: (value, index|key, collection).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias detect\n * @category Collection\n * @param {Array|Object|string} collection The collection to search.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.result(_.find(users, function(chr) {\n *   return chr.age < 40;\n * }), 'user');\n * // => 'barney'\n *\n * // using the `_.matches` callback shorthand\n * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');\n * // => 'pebbles'\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.result(_.find(users, 'active', false), 'user');\n * // => 'fred'\n *\n * // using the `_.property` callback shorthand\n * _.result(_.find(users, 'active'), 'user');\n * // => 'barney'\n */\nvar find = createFind(baseEach);\n\nmodule.exports = find;\n\n},{\"../internal/baseEach\":6,\"../internal/createFind\":25}],4:[function(require,module,exports){\n/**\n * A specialized version of `_.some` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n\n},{}],5:[function(require,module,exports){\nvar baseMatches = require('./baseMatches'),\n    baseMatchesProperty = require('./baseMatchesProperty'),\n    bindCallback = require('./bindCallback'),\n    identity = require('../utility/identity'),\n    property = require('../utility/property');\n\n/**\n * The base implementation of `_.callback` which supports specifying the\n * number of arguments to provide to `func`.\n *\n * @private\n * @param {*} [func=_.identity] The value to convert to a callback.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction baseCallback(func, thisArg, argCount) {\n  var type = typeof func;\n  if (type == 'function') {\n    return thisArg === undefined\n      ? func\n      : bindCallback(func, thisArg, argCount);\n  }\n  if (func == null) {\n    return identity;\n  }\n  if (type == 'object') {\n    return baseMatches(func);\n  }\n  return thisArg === undefined\n    ? property(func)\n    : baseMatchesProperty(func, thisArg);\n}\n\nmodule.exports = baseCallback;\n\n},{\"../utility/identity\":50,\"../utility/property\":51,\"./baseMatches\":15,\"./baseMatchesProperty\":16,\"./bindCallback\":22}],6:[function(require,module,exports){\nvar baseForOwn = require('./baseForOwn'),\n    createBaseEach = require('./createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object|string} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n\n},{\"./baseForOwn\":10,\"./createBaseEach\":23}],7:[function(require,module,exports){\n/**\n * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\n * without support for callback shorthands and `this` binding, which iterates\n * over `collection` using the provided `eachFunc`.\n *\n * @private\n * @param {Array|Object|string} collection The collection to search.\n * @param {Function} predicate The function invoked per iteration.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @param {boolean} [retKey] Specify returning the key of the found element\n *  instead of the element itself.\n * @returns {*} Returns the found element or its key, else `undefined`.\n */\nfunction baseFind(collection, predicate, eachFunc, retKey) {\n  var result;\n  eachFunc(collection, function(value, key, collection) {\n    if (predicate(value, key, collection)) {\n      result = retKey ? key : value;\n      return false;\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFind;\n\n},{}],8:[function(require,module,exports){\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for callback shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {Function} predicate The function invoked per iteration.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromRight) {\n  var length = array.length,\n      index = fromRight ? length : -1;\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n\n},{}],9:[function(require,module,exports){\nvar createBaseFor = require('./createBaseFor');\n\n/**\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\n * each property. Iteratee functions may exit iteration early by explicitly\n * returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n},{\"./createBaseFor\":24}],10:[function(require,module,exports){\nvar baseFor = require('./baseFor'),\n    keys = require('../object/keys');\n\n/**\n * The base implementation of `_.forOwn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n},{\"../object/keys\":46,\"./baseFor\":9}],11:[function(require,module,exports){\nvar toObject = require('./toObject');\n\n/**\n * The base implementation of `get` without support for string paths\n * and default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path of the property to get.\n * @param {string} [pathKey] The key representation of path.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path, pathKey) {\n  if (object == null) {\n    return;\n  }\n  if (pathKey !== undefined && pathKey in toObject(object)) {\n    path = [pathKey];\n  }\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[path[index++]];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n},{\"./toObject\":39}],12:[function(require,module,exports){\nvar baseIsEqualDeep = require('./baseIsEqualDeep'),\n    isObject = require('../lang/isObject'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` without support for `this` binding\n * `customizer` functions.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparing values.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\n}\n\nmodule.exports = baseIsEqual;\n\n},{\"../lang/isObject\":44,\"./baseIsEqualDeep\":13,\"./isObjectLike\":36}],13:[function(require,module,exports){\nvar equalArrays = require('./equalArrays'),\n    equalByTag = require('./equalByTag'),\n    equalObjects = require('./equalObjects'),\n    isArray = require('../lang/isArray'),\n    isTypedArray = require('../lang/isTypedArray');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing objects.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = objToString.call(object);\n    if (objTag == argsTag) {\n      objTag = objectTag;\n    } else if (objTag != objectTag) {\n      objIsArr = isTypedArray(object);\n    }\n  }\n  if (!othIsArr) {\n    othTag = objToString.call(other);\n    if (othTag == argsTag) {\n      othTag = objectTag;\n    } else if (othTag != objectTag) {\n      othIsArr = isTypedArray(other);\n    }\n  }\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !(objIsArr || objIsObj)) {\n    return equalByTag(object, other, objTag);\n  }\n  if (!isLoose) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  // For more information on detecting circular references see https://es5.github.io/#JO.\n  stackA || (stackA = []);\n  stackB || (stackB = []);\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] == object) {\n      return stackB[length] == other;\n    }\n  }\n  // Add `object` and `other` to the stack of traversed objects.\n  stackA.push(object);\n  stackB.push(other);\n\n  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\n\n  stackA.pop();\n  stackB.pop();\n\n  return result;\n}\n\nmodule.exports = baseIsEqualDeep;\n\n},{\"../lang/isArray\":42,\"../lang/isTypedArray\":45,\"./equalArrays\":26,\"./equalByTag\":27,\"./equalObjects\":28}],14:[function(require,module,exports){\nvar baseIsEqual = require('./baseIsEqual'),\n    toObject = require('./toObject');\n\n/**\n * The base implementation of `_.isMatch` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Array} matchData The propery names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparing objects.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = toObject(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var result = customizer ? customizer(objValue, srcValue, key) : undefined;\n      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n\n},{\"./baseIsEqual\":12,\"./toObject\":39}],15:[function(require,module,exports){\nvar baseIsMatch = require('./baseIsMatch'),\n    getMatchData = require('./getMatchData'),\n    toObject = require('./toObject');\n\n/**\n * The base implementation of `_.matches` which does not clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    var key = matchData[0][0],\n        value = matchData[0][1];\n\n    return function(object) {\n      if (object == null) {\n        return false;\n      }\n      return object[key] === value && (value !== undefined || (key in toObject(object)));\n    };\n  }\n  return function(object) {\n    return baseIsMatch(object, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n\n},{\"./baseIsMatch\":14,\"./getMatchData\":30,\"./toObject\":39}],16:[function(require,module,exports){\nvar baseGet = require('./baseGet'),\n    baseIsEqual = require('./baseIsEqual'),\n    baseSlice = require('./baseSlice'),\n    isArray = require('../lang/isArray'),\n    isKey = require('./isKey'),\n    isStrictComparable = require('./isStrictComparable'),\n    last = require('../array/last'),\n    toObject = require('./toObject'),\n    toPath = require('./toPath');\n\n/**\n * The base implementation of `_.matchesProperty` which does not clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to compare.\n * @returns {Function} Returns the new function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  var isArr = isArray(path),\n      isCommon = isKey(path) && isStrictComparable(srcValue),\n      pathKey = (path + '');\n\n  path = toPath(path);\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    var key = pathKey;\n    object = toObject(object);\n    if ((isArr || !isCommon) && !(key in object)) {\n      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n      if (object == null) {\n        return false;\n      }\n      key = last(path);\n      object = toObject(object);\n    }\n    return object[key] === srcValue\n      ? (srcValue !== undefined || (key in object))\n      : baseIsEqual(srcValue, object[key], undefined, true);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n\n},{\"../array/last\":1,\"../lang/isArray\":42,\"./baseGet\":11,\"./baseIsEqual\":12,\"./baseSlice\":20,\"./isKey\":34,\"./isStrictComparable\":37,\"./toObject\":39,\"./toPath\":40}],17:[function(require,module,exports){\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n},{}],18:[function(require,module,exports){\nvar baseGet = require('./baseGet'),\n    toPath = require('./toPath');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction basePropertyDeep(path) {\n  var pathKey = (path + '');\n  path = toPath(path);\n  return function(object) {\n    return baseGet(object, path, pathKey);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n\n},{\"./baseGet\":11,\"./toPath\":40}],19:[function(require,module,exports){\nvar isIndex = require('./isIndex');\n\n/** Used for native method references. */\nvar arrayProto = Array.prototype;\n\n/** Native method references. */\nvar splice = arrayProto.splice;\n\n/**\n * The base implementation of `_.pullAt` without support for individual\n * index arguments and capturing the removed elements.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {number[]} indexes The indexes of elements to remove.\n * @returns {Array} Returns `array`.\n */\nfunction basePullAt(array, indexes) {\n  var length = array ? indexes.length : 0;\n  while (length--) {\n    var index = indexes[length];\n    if (index != previous && isIndex(index)) {\n      var previous = index;\n      splice.call(array, index, 1);\n    }\n  }\n  return array;\n}\n\nmodule.exports = basePullAt;\n\n},{\"./isIndex\":33}],20:[function(require,module,exports){\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  start = start == null ? 0 : (+start || 0);\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = (end === undefined || end > length) ? length : (+end || 0);\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n\n},{}],21:[function(require,module,exports){\n/**\n * Converts `value` to a string if it's not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  if (typeof value == 'string') {\n    return value;\n  }\n  return value == null ? '' : (value + '');\n}\n\nmodule.exports = baseToString;\n\n},{}],22:[function(require,module,exports){\nvar identity = require('../utility/identity');\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (thisArg === undefined) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\nmodule.exports = bindCallback;\n\n},{\"../utility/identity\":50}],23:[function(require,module,exports){\nvar getLength = require('./getLength'),\n    isLength = require('./isLength'),\n    toObject = require('./toObject');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    var length = collection ? getLength(collection) : 0;\n    if (!isLength(length)) {\n      return eachFunc(collection, iteratee);\n    }\n    var index = fromRight ? length : -1,\n        iterable = toObject(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n\n},{\"./getLength\":29,\"./isLength\":35,\"./toObject\":39}],24:[function(require,module,exports){\nvar toObject = require('./toObject');\n\n/**\n * Creates a base function for `_.forIn` or `_.forInRight`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var iterable = toObject(object),\n        props = keysFunc(object),\n        length = props.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var key = props[index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n},{\"./toObject\":39}],25:[function(require,module,exports){\nvar baseCallback = require('./baseCallback'),\n    baseFind = require('./baseFind'),\n    baseFindIndex = require('./baseFindIndex'),\n    isArray = require('../lang/isArray');\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(eachFunc, fromRight) {\n  return function(collection, predicate, thisArg) {\n    predicate = baseCallback(predicate, thisArg, 3);\n    if (isArray(collection)) {\n      var index = baseFindIndex(collection, predicate, fromRight);\n      return index > -1 ? collection[index] : undefined;\n    }\n    return baseFind(collection, predicate, eachFunc);\n  };\n}\n\nmodule.exports = createFind;\n\n},{\"../lang/isArray\":42,\"./baseCallback\":5,\"./baseFind\":7,\"./baseFindIndex\":8}],26:[function(require,module,exports){\nvar arraySome = require('./arraySome');\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing arrays.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var index = -1,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\n    return false;\n  }\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index],\n        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;\n\n    if (result !== undefined) {\n      if (result) {\n        continue;\n      }\n      return false;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (isLoose) {\n      if (!arraySome(other, function(othValue) {\n            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n          })) {\n        return false;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalArrays;\n\n},{\"./arraySome\":4}],27:[function(require,module,exports){\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    stringTag = '[object String]';\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} value The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag) {\n  switch (tag) {\n    case boolTag:\n    case dateTag:\n      // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n      return +object == +other;\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case numberTag:\n      // Treat `NaN` vs. `NaN` as equal.\n      return (object != +object)\n        ? other != +other\n        : object == +other;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings primitives and string\n      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n      return object == (other + '');\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n\n},{}],28:[function(require,module,exports){\nvar keys = require('../object/keys');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing values.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isLoose) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  var skipCtor = isLoose;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key],\n        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;\n\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {\n      return false;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (!skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalObjects;\n\n},{\"../object/keys\":46}],29:[function(require,module,exports){\nvar baseProperty = require('./baseProperty');\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\nmodule.exports = getLength;\n\n},{\"./baseProperty\":17}],30:[function(require,module,exports){\nvar isStrictComparable = require('./isStrictComparable'),\n    pairs = require('../object/pairs');\n\n/**\n * Gets the propery names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = pairs(object),\n      length = result.length;\n\n  while (length--) {\n    result[length][2] = isStrictComparable(result[length][1]);\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n\n},{\"../object/pairs\":48,\"./isStrictComparable\":37}],31:[function(require,module,exports){\nvar isNative = require('../lang/isNative');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n},{\"../lang/isNative\":43}],32:[function(require,module,exports){\nvar getLength = require('./getLength'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\nmodule.exports = isArrayLike;\n\n},{\"./getLength\":29,\"./isLength\":35}],33:[function(require,module,exports){\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\nmodule.exports = isIndex;\n\n},{}],34:[function(require,module,exports){\nvar isArray = require('../lang/isArray'),\n    toObject = require('./toObject');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  var type = typeof value;\n  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {\n    return true;\n  }\n  if (isArray(value)) {\n    return false;\n  }\n  var result = !reIsDeepProp.test(value);\n  return result || (object != null && value in toObject(object));\n}\n\nmodule.exports = isKey;\n\n},{\"../lang/isArray\":42,\"./toObject\":39}],35:[function(require,module,exports){\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n},{}],36:[function(require,module,exports){\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n},{}],37:[function(require,module,exports){\nvar isObject = require('../lang/isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n\n},{\"../lang/isObject\":44}],38:[function(require,module,exports){\nvar isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isIndex = require('./isIndex'),\n    isLength = require('./isLength'),\n    keysIn = require('../object/keysIn');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = !!length && isLength(length) &&\n    (isArray(object) || isArguments(object));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = shimKeys;\n\n},{\"../lang/isArguments\":41,\"../lang/isArray\":42,\"../object/keysIn\":47,\"./isIndex\":33,\"./isLength\":35}],39:[function(require,module,exports){\nvar isObject = require('../lang/isObject');\n\n/**\n * Converts `value` to an object if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\nmodule.exports = toObject;\n\n},{\"../lang/isObject\":44}],40:[function(require,module,exports){\nvar baseToString = require('./baseToString'),\n    isArray = require('../lang/isArray');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `value` to property path array if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Array} Returns the property path array.\n */\nfunction toPath(value) {\n  if (isArray(value)) {\n    return value;\n  }\n  var result = [];\n  baseToString(value).replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n}\n\nmodule.exports = toPath;\n\n},{\"../lang/isArray\":42,\"./baseToString\":21}],41:[function(require,module,exports){\nvar isArrayLike = require('../internal/isArrayLike'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  return isObjectLike(value) && isArrayLike(value) && objToString.call(value) == argsTag;\n}\n\nmodule.exports = isArguments;\n\n},{\"../internal/isArrayLike\":32,\"../internal/isObjectLike\":36}],42:[function(require,module,exports){\nvar getNative = require('../internal/getNative'),\n    isLength = require('../internal/isLength'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\nmodule.exports = isArray;\n\n},{\"../internal/getNative\":31,\"../internal/isLength\":35,\"../internal/isObjectLike\":36}],43:[function(require,module,exports){\nvar escapeRegExp = require('../string/escapeRegExp'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  escapeRegExp(fnToString.call(hasOwnProperty))\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (objToString.call(value) == funcTag) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isNative;\n\n},{\"../internal/isObjectLike\":36,\"../string/escapeRegExp\":49}],44:[function(require,module,exports){\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n},{}],45:[function(require,module,exports){\nvar isLength = require('../internal/isLength'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nfunction isTypedArray(value) {\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n}\n\nmodule.exports = isTypedArray;\n\n},{\"../internal/isLength\":35,\"../internal/isObjectLike\":36}],46:[function(require,module,exports){\nvar getNative = require('../internal/getNative'),\n    isArrayLike = require('../internal/isArrayLike'),\n    isObject = require('../lang/isObject'),\n    shimKeys = require('../internal/shimKeys');\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = getNative(Object, 'keys');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object == null ? null : object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\nmodule.exports = keys;\n\n},{\"../internal/getNative\":31,\"../internal/isArrayLike\":32,\"../internal/shimKeys\":38,\"../lang/isObject\":44}],47:[function(require,module,exports){\nvar isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isIndex = require('../internal/isIndex'),\n    isLength = require('../internal/isLength'),\n    isObject = require('../lang/isObject');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || isArguments(object)) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keysIn;\n\n},{\"../internal/isIndex\":33,\"../internal/isLength\":35,\"../lang/isArguments\":41,\"../lang/isArray\":42,\"../lang/isObject\":44}],48:[function(require,module,exports){\nvar keys = require('./keys'),\n    toObject = require('../internal/toObject');\n\n/**\n * Creates a two dimensional array of the key-value pairs for `object`,\n * e.g. `[[key1, value1], [key2, value2]]`.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the new array of key-value pairs.\n * @example\n *\n * _.pairs({ 'barney': 36, 'fred': 40 });\n * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\n */\nfunction pairs(object) {\n  object = toObject(object);\n\n  var index = -1,\n      props = keys(object),\n      length = props.length,\n      result = Array(length);\n\n  while (++index < length) {\n    var key = props[index];\n    result[index] = [key, object[key]];\n  }\n  return result;\n}\n\nmodule.exports = pairs;\n\n},{\"../internal/toObject\":39,\"./keys\":46}],49:[function(require,module,exports){\nvar baseToString = require('../internal/baseToString');\n\n/**\n * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).\n * In addition to special characters the forward slash is escaped to allow for\n * easier `eval` use and `Function` compilation.\n */\nvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n    reHasRegExpChars = RegExp(reRegExpChars.source);\n\n/**\n * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n *\n * @static\n * @memberOf _\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n */\nfunction escapeRegExp(string) {\n  string = baseToString(string);\n  return (string && reHasRegExpChars.test(string))\n    ? string.replace(reRegExpChars, '\\\\$&')\n    : string;\n}\n\nmodule.exports = escapeRegExp;\n\n},{\"../internal/baseToString\":21}],50:[function(require,module,exports){\n/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n},{}],51:[function(require,module,exports){\nvar baseProperty = require('../internal/baseProperty'),\n    basePropertyDeep = require('../internal/basePropertyDeep'),\n    isKey = require('../internal/isKey');\n\n/**\n * Creates a function that returns the property value at `path` on a\n * given object.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': { 'c': 2 } } },\n *   { 'a': { 'b': { 'c': 1 } } }\n * ];\n *\n * _.map(objects, _.property('a.b.c'));\n * // => [2, 1]\n *\n * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n\n},{\"../internal/baseProperty\":17,\"../internal/basePropertyDeep\":18,\"../internal/isKey\":34}],52:[function(require,module,exports){\nvar Point, Segment, find, remove;\n\nfind = require('lodash/collection/find');\n\nremove = require('lodash/array/remove');\n\nPoint = (function() {\n  function Point(x1, y1) {\n    this.x = x1;\n    this.y = y1;\n    this.segments = [];\n  }\n\n  Point.prototype.addSegment = function(seg, rel) {\n    return this.segments.push({\n      seg: seg,\n      rel: rel\n    });\n  };\n\n  return Point;\n\n})();\n\nSegment = (function() {\n  function Segment(start1, end1) {\n    this.start = start1;\n    this.end = end1;\n    this.start.addSegment(this, 'start');\n    this.end.addSegment(this, 'end');\n  }\n\n  Segment.prototype.addArc = function(radius, largeArc, sweep1) {\n    this.radius = radius;\n    this.largeArc = largeArc;\n    this.sweep = sweep1;\n  };\n\n  Segment.prototype.drawTo = function(point) {\n    var sw, toEnd, toStart;\n    if (point === this.start) {\n      toStart = true;\n    } else if (point === this.end) {\n      toEnd = true;\n    }\n    if ((this.radius == null) && (toStart || toEnd)) {\n      return ['L', point.x, point.y];\n    } else if ((this.radius != null) && toEnd) {\n      return ['A', this.radius, this.radius, 0, this.largeArc, this.sweep, point.x, point.y];\n    } else if ((this.radius != null) && toStart) {\n      sw = this.sweep === 1 ? 0 : 1;\n      return ['A', this.radius, this.radius, 0, this.largeArc, sw, point.x, point.y];\n    } else {\n      return [];\n    }\n  };\n\n  return Segment;\n\n})();\n\nmodule.exports = function(outline) {\n  var end, i, j, len, lrgArc, newEnd, newPath, newStart, nextPoint, nextPointRel, nextSeg, nextSegObj, nextSegRel, p, pathStart, points, r, ref, seg, start, startPoint, sweep, x, y;\n  if (outline[0] !== 'M') {\n    console.log(\"didn't start with 'M'\");\n    return [];\n  }\n  pathStart = null;\n  points = [];\n  i = 0;\n  while (i < outline.length - 1) {\n    if (outline[i] === 'M' || outline[i] === 'L') {\n      x = outline[i + 1];\n      y = outline[i + 2];\n      i += 3;\n    } else if (outline[i] === 'A') {\n      x = outline[i + 6];\n      y = outline[i + 7];\n      i += 8;\n    } else if (outline[i] === 'Z') {\n      i++;\n      continue;\n    }\n    if (i >= outline.length) {\n      break;\n    } else {\n      start = find(points, {\n        x: x,\n        y: y\n      });\n      if (start == null) {\n        newStart = true;\n        start = new Point(x, y);\n      }\n    }\n    if (outline[i] === 'L') {\n      x = outline[i + 1];\n      y = outline[i + 2];\n      r = null;\n    } else if (outline[i] === 'A') {\n      x = outline[i + 6];\n      y = outline[i + 7];\n      r = outline[i + 2];\n      lrgArc = outline[i + 4];\n      sweep = outline[i + 5];\n    } else if (outline[i] === 'M') {\n      continue;\n    }\n    if (outline[i] === 'Z') {\n      end = pathStart;\n      pathStart = null;\n    } else {\n      if (pathStart == null) {\n        pathStart = start;\n      }\n      end = find(points, {\n        x: x,\n        y: y\n      });\n      if (end == null) {\n        newEnd = true;\n        end = new Point(x, y);\n      }\n    }\n    seg = new Segment(start, end);\n    if (r != null) {\n      seg.addArc(r, lrgArc, sweep);\n    }\n    if (newStart) {\n      newStart = false;\n      points.push(start);\n    }\n    if (newEnd) {\n      newEnd = false;\n      points.push(end);\n    }\n  }\n  newPath = [];\n  while (points.length) {\n    startPoint = points.pop();\n    nextSegObj = startPoint.segments.pop();\n    nextPoint = null;\n    newPath.push('M', startPoint.x, startPoint.y);\n    while (nextPoint !== startPoint) {\n      remove(points, function(p) {\n        return p === nextPoint;\n      });\n      nextSeg = nextSegObj.seg;\n      nextSegRel = nextSegObj.rel;\n      nextPointRel = nextSegRel === 'start' ? 'end' : 'start';\n      nextPoint = nextSeg[nextPointRel];\n      ref = nextSeg.drawTo(nextPoint);\n      for (j = 0, len = ref.length; j < len; j++) {\n        p = ref[j];\n        newPath.push(p);\n      }\n      remove(nextPoint.segments, function(sO) {\n        return sO.seg === nextSeg;\n      });\n      nextSegObj = nextPoint.segments.pop();\n    }\n  }\n  return newPath;\n};\n\n\n\n},{\"lodash/array/remove\":2,\"lodash/collection/find\":3}],53:[function(require,module,exports){\nvar boardOutline, reCOPPER, reDRILL, reEDGE, reMASK, rePASTE, reSILK, unique, uniqueId;\n\nboardOutline = require('./build-board-outline.coffee');\n\nunique = 0;\n\nuniqueId = function() {\n  return unique++;\n};\n\nreCOPPER = /cu/;\n\nreMASK = /sm/;\n\nreSILK = /ss/;\n\nrePASTE = /sp/;\n\nreEDGE = /out/;\n\nreDRILL = /drl/;\n\nmodule.exports = function(name, layers) {\n  var addVboxToBbox, attr, bbox, bboxRect, copper, cuFinishId, d, defs, draw, drill, e, edge, edgeBbox, getVboxFromBbox, group, i, j, k, key, l, layer, layerId, len, len1, len2, len3, len4, ly, m, mask, mechId, mechMask, n, newPathData, node, oldSW, paste, path, ref, ref1, ref2, ref3, scale, silk, smId, smPos, svg, trans, u, units, val, vb, vbScale, vbox, xml;\n  if (layers == null) {\n    layers = [];\n  }\n  copper = null;\n  mask = null;\n  silk = null;\n  paste = null;\n  edge = null;\n  drill = [];\n  attr = {};\n  defs = [];\n  draw = [];\n  bbox = [Infinity, Infinity, -Infinity, -Infinity];\n  edgeBbox = null;\n  units = 'px';\n  scale = null;\n  addVboxToBbox = function(v) {\n    var xMax, yMax;\n    xMax = v[2] + v[0];\n    yMax = v[3] + v[1];\n    if (v[0] < bbox[0]) {\n      bbox[0] = v[0];\n    }\n    if (v[1] < bbox[1]) {\n      bbox[1] = v[1];\n    }\n    if (xMax > bbox[2]) {\n      bbox[2] = xMax;\n    }\n    if (yMax > bbox[3]) {\n      return bbox[3] = yMax;\n    }\n  };\n  getVboxFromBbox = function(bb) {\n    return [bb[0], bb[1], bb[2] - bb[0], bb[3] - bb[1]];\n  };\n  for (i = 0, len = layers.length; i < len; i++) {\n    layer = layers[i];\n    ly = layer.type;\n    xml = layer.svgObj;\n    if (xml.svg == null) {\n      continue;\n    }\n    addVboxToBbox(xml.svg.viewBox);\n    u = (ref = xml.svg.width.match(/(in)|(mm)/)) != null ? ref[0] : void 0;\n    if (units === 'px') {\n      units = u;\n    } else if (u !== units) {\n      return {};\n    }\n    vbScale = parseFloat(xml.svg.width) / xml.svg.viewBox[2];\n    if (scale == null) {\n      scale = vbScale;\n    } else if (Math.abs(vbScale - scale) > 0.0000001) {\n      return {};\n    }\n    ref1 = xml.svg;\n    for (key in ref1) {\n      val = ref1[key];\n      if ((attr[key] == null) && key !== '_') {\n        attr[key] = val;\n      }\n    }\n    layerId = name + \"-\" + ly + \"_\" + (uniqueId());\n    ref2 = xml.svg._;\n    for (j = 0, len1 = ref2.length; j < len1; j++) {\n      node = ref2[j];\n      if (node.defs != null) {\n        ref3 = node.defs._;\n        for (k = 0, len2 = ref3.length; k < len2; k++) {\n          d = ref3[k];\n          defs.push(d);\n        }\n      } else if (node.g != null) {\n        delete node.g.transform;\n        node.g.id = layerId;\n        defs.push(node);\n      }\n    }\n    if (reCOPPER.test(ly)) {\n      copper = layerId;\n    } else if (reMASK.test(ly)) {\n      mask = layerId;\n    } else if (reSILK.test(ly)) {\n      silk = layerId;\n    } else if (rePASTE.test(ly)) {\n      paste = layerId;\n    } else if (reDRILL.test(ly)) {\n      drill.push(layerId);\n    } else if (reEDGE.test(ly)) {\n      edge = layerId;\n      group = defs[defs.length - 1].g._;\n      for (l = 0, len3 = group.length; l < len3; l++) {\n        n = group[l];\n        if ((n.path != null) && n.path['stroke-width']) {\n          path = n.path;\n          break;\n        }\n      }\n      newPathData = [];\n      try {\n        newPathData = boardOutline(path.d);\n      } catch (_error) {\n        e = _error;\n      }\n      if (newPathData.length) {\n        oldSW = path['stroke-width'];\n        path['stroke-width'] = 0;\n        path.fill = '#fff';\n        path['fill-rule'] = 'evenodd';\n        path.d = newPathData;\n        vb = xml.svg.viewBox;\n        vb[0] += oldSW / 2;\n        vb[1] += oldSW / 2;\n        vb[2] -= oldSW;\n        vb[3] -= oldSW;\n        edgeBbox = [vb[0], vb[1], vb[2] + vb[0], vb[3] + vb[1]];\n      }\n    }\n    xml = null;\n  }\n  if (copper == null) {\n    return {};\n  }\n  if (edgeBbox != null) {\n    bbox = edgeBbox;\n  }\n  vbox = getVboxFromBbox(bbox);\n  bboxRect = function(cls, fill) {\n    if (cls == null) {\n      cls = 'Board--cover';\n    }\n    if (fill == null) {\n      fill = 'currentColor';\n    }\n    return {\n      rect: {\n        \"class\": cls,\n        fill: fill,\n        x: vbox[0],\n        y: vbox[1],\n        width: vbox[2],\n        height: vbox[3]\n      }\n    };\n  };\n  draw.push(bboxRect('Board--board'));\n  draw.push({\n    use: {\n      \"class\": 'Board--cu',\n      'xlink:href': \"#\" + copper\n    }\n  });\n  if (mask != null) {\n    cuFinishId = name + \"-sm_\" + (uniqueId());\n    defs.push({\n      mask: {\n        id: cuFinishId,\n        color: '#fff',\n        _: [\n          {\n            use: {\n              'xlink:href': \"#\" + copper\n            }\n          }\n        ]\n      }\n    });\n    draw.push({\n      use: {\n        \"class\": 'Board--cf',\n        mask: \"url(#\" + cuFinishId + \")\",\n        'xlink:href': \"#\" + mask\n      }\n    });\n    smId = name + \"-sm_\" + (uniqueId());\n    defs.push({\n      mask: {\n        id: smId,\n        color: '#000',\n        _: [\n          bboxRect(null, '#fff'), {\n            use: {\n              'xlink:href': \"#\" + mask\n            }\n          }\n        ]\n      }\n    });\n    smPos = {\n      g: {\n        mask: \"url(#\" + smId + \")\",\n        _: [bboxRect('Board--sm')]\n      }\n    };\n    if (silk != null) {\n      smPos.g._.push({\n        use: {\n          \"class\": 'Board--ss',\n          'xlink:href': \"#\" + silk\n        }\n      });\n    }\n    draw.push(smPos);\n  }\n  if (paste != null) {\n    draw.push({\n      use: {\n        \"class\": 'Board--sp',\n        'xlink:href': \"#\" + paste\n      }\n    });\n  }\n  if ((edge != null) && (edgeBbox == null)) {\n    draw.push({\n      use: {\n        \"class\": 'Board--out',\n        'xlink:href': \"#\" + edge\n      }\n    });\n  }\n  mechId = null;\n  if (drill.length || (edgeBbox != null)) {\n    mechId = name + \"-mech_\" + (uniqueId());\n    mechMask = {\n      mask: {\n        id: mechId,\n        color: '#000',\n        _: []\n      }\n    };\n    mechMask.mask._.push(edgeBbox != null ? {\n      use: {\n        'xlink:href': \"#\" + edge\n      }\n    } : bboxRect(null, '#fff'));\n    for (m = 0, len4 = drill.length; m < len4; m++) {\n      d = drill[m];\n      mechMask.mask._.push({\n        use: {\n          'xlink:href': \"#\" + d\n        }\n      });\n    }\n    defs.push(mechMask);\n  }\n  if (name === 'bottom') {\n    trans = \"translate(\" + (bbox[2] + bbox[0]) + \",\" + (bbox[3] + bbox[1]) + \") scale(-1,-1)\";\n  } else {\n    trans = \"translate(0,\" + (bbox[3] + bbox[1]) + \") scale(1,-1)\";\n  }\n  draw = {\n    g: {\n      transform: trans,\n      _: draw\n    }\n  };\n  if (mechId) {\n    draw.g.mask = \"url(#\" + mechId + \")\";\n  }\n  svg = attr;\n  svg[\"class\"] = 'Board';\n  svg.viewBox = getVboxFromBbox(bbox);\n  svg.width = \"\" + (svg.viewBox[2] * scale) + units;\n  svg.height = \"\" + (svg.viewBox[3] * scale) + units;\n  svg._ = [];\n  if (defs.length) {\n    svg._.push({\n      defs: {\n        _: defs\n      }\n    });\n  }\n  if (draw.g._.length) {\n    svg._.push(draw);\n  }\n  return {\n    svg: svg\n  };\n};\n\n\n\n},{\"./build-board-outline.coffee\":52}],54:[function(require,module,exports){\nvar build;\n\nbuild = require('../build-board.coffee');\n\nself.addEventListener('message', function(e) {\n  var boardObj, layers, name;\n  name = e.data.name;\n  layers = e.data.layers;\n  boardObj = build(name, layers);\n  return self.postMessage({\n    name: name,\n    svgObj: boardObj\n  });\n}, false);\n\n\n\n},{\"../build-board.coffee\":53}]},{},[54])"],{
type:"text/javascript"}))),o=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return i(n,e),n.prototype.model=t,n.prototype.initialize=function(){return this.attachBuilderHandler(),this.on("buildNeeded",this.buildBoard),n.__super__.initialize.call(this)},n.prototype.buildBoard=function(e){return s.postMessage({name:e.get("name"),layers:e.get("boardLayers")})},n.prototype.attachBuilderHandler=function(){var e,n;return e=this,n=function(n){return e.convert(n.data.name,n.data.svgObj)},s.addEventListener("message",n,!1)},n}(a),n.exports=o},{"../models/board":"/Users/mc/cloned/svgerber/src/models/board.coffee","./renders":"/Users/mc/cloned/svgerber/src/collections/renders.coffee"}],"/Users/mc/cloned/svgerber/src/collections/layers.coffee":[function(e,n,r){var t,o,a,s=function(e,n){function r(){this.constructor=e}for(var t in n)i.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},i={}.hasOwnProperty;t=e("../models/layer"),a=e("./renders"),o=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return s(n,e),n.prototype.model=t,n.prototype.initialize=function(){return this.on("change:type",this.validateLayers),this.on("change:gerber",function(e){var n;return n=e.get("gerber"),n?this.convert(e.get("name"),n):void 0}),n.__super__.initialize.call(this)},n.prototype.validateLayers=function(){var e;return e=!0,this.forEach(function(n){return n.isValid()?n.trigger("valid"):e=!1,!0}),e},n}(a),n.exports=o},{"../models/layer":"/Users/mc/cloned/svgerber/src/models/layer.coffee","./renders":"/Users/mc/cloned/svgerber/src/collections/renders.coffee"}],"/Users/mc/cloned/svgerber/src/collections/renders.coffee":[function(e,n,r){var t,o,a,s=function(e,n){function r(){this.constructor=e}for(var t in n)i.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},i={}.hasOwnProperty;o=new Worker(window.URL.createObjectURL(new Blob(["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function() {\n  var getSvgCoord;\n\n  getSvgCoord = require('./svg-coord').get;\n\n  module.exports = function(coord, format) {\n    var key, parse, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, result, val;\n    if (coord == null) {\n      return {};\n    }\n    if (!((format.zero != null) && (format.places != null))) {\n      throw new Error('format undefined');\n    }\n    parse = {};\n    result = {};\n    parse.x = (ref = coord.match(/X[+-]?[\\d\\.]+/)) != null ? (ref1 = ref[0]) != null ? ref1.slice(1) : void 0 : void 0;\n    parse.y = (ref2 = coord.match(/Y[+-]?[\\d\\.]+/)) != null ? (ref3 = ref2[0]) != null ? ref3.slice(1) : void 0 : void 0;\n    parse.i = (ref4 = coord.match(/I[+-]?[\\d\\.]+/)) != null ? (ref5 = ref4[0]) != null ? ref5.slice(1) : void 0 : void 0;\n    parse.j = (ref6 = coord.match(/J[+-]?[\\d\\.]+/)) != null ? (ref7 = ref6[0]) != null ? ref7.slice(1) : void 0 : void 0;\n    for (key in parse) {\n      val = parse[key];\n      if (val != null) {\n        result[key] = getSvgCoord(val, format);\n      }\n    }\n    return result;\n  };\n\n}).call(this);\n\n},{\"./svg-coord\":14}],2:[function(require,module,exports){\n(function() {\n  var ABS_COMMAND, DrillParser, INCH_COMMAND, INC_COMMAND, METRIC_COMMAND, PLACES_BACKUP, Parser, ZERO_BACKUP, getSvgCoord, parseCoord, reCOORD,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Parser = require('./parser');\n\n  parseCoord = require('./coord-parser');\n\n  getSvgCoord = require('./svg-coord').get;\n\n  INCH_COMMAND = {\n    'FMAT,1': 'M70',\n    'FMAT,2': 'M72'\n  };\n\n  METRIC_COMMAND = 'M71';\n\n  ABS_COMMAND = 'G90';\n\n  INC_COMMAND = 'G91';\n\n  reCOORD = /[XY]{1,2}/;\n\n  ZERO_BACKUP = 'L';\n\n  PLACES_BACKUP = [2, 4];\n\n  DrillParser = (function(superClass) {\n    extend(DrillParser, superClass);\n\n    function DrillParser() {\n      this.fmat = 'FMAT,2';\n      DrillParser.__super__.constructor.call(this, arguments[0]);\n    }\n\n    DrillParser.prototype.parseCommand = function(block) {\n      var base, base1, base2, base3, code, command, dia, k, ref, ref1, ref2, v;\n      command = {};\n      if (block[0] === ';') {\n        return command;\n      }\n      if (block === 'FMAT,1') {\n        this.fmat = block;\n      } else if (block === 'M30' || block === 'M00') {\n        command.set = {\n          done: true\n        };\n      } else if (block === INCH_COMMAND[this.fmat] || block.match(/INCH/)) {\n        if ((base = this.format).places == null) {\n          base.places = [2, 4];\n        }\n        command.set = {\n          units: 'in'\n        };\n      } else if (block === METRIC_COMMAND || block.match(/METRIC/)) {\n        if ((base1 = this.format).places == null) {\n          base1.places = [3, 3];\n        }\n        command.set = {\n          units: 'mm'\n        };\n      } else if (block === ABS_COMMAND) {\n        command.set = {\n          notation: 'A'\n        };\n      } else if (block === INC_COMMAND) {\n        command.set = {\n          notation: 'I'\n        };\n      } else if ((code = (ref = block.match(/T\\d+/)) != null ? ref[0] : void 0)) {\n        while (code[1] === '0') {\n          code = code[0] + code.slice(2);\n        }\n        if ((dia = (ref1 = block.match(/C[\\d\\.]+(?=.*$)/)) != null ? ref1[0] : void 0)) {\n          dia = dia.slice(1);\n          command.tool = {};\n          command.tool[code] = {\n            dia: getSvgCoord(dia, {\n              places: this.format.places\n            })\n          };\n        } else {\n          command.set = {\n            currentTool: code\n          };\n        }\n      }\n      if (block.match(/TZ/)) {\n        if ((base2 = this.format).zero == null) {\n          base2.zero = 'L';\n        }\n      } else if (block.match(/LZ/)) {\n        if ((base3 = this.format).zero == null) {\n          base3.zero = 'T';\n        }\n      }\n      if (block.match(reCOORD)) {\n        command.op = {\n          \"do\": 'flash'\n        };\n        if (this.format.zero == null) {\n          console.warn('no drill file zero suppression specified. assuming leading zero suppression (same as no zero suppression)');\n          this.format.zero = ZERO_BACKUP;\n        }\n        if (this.format.places == null) {\n          console.warn('no drill file units specified; assuming 2:4 inches format');\n          this.format.places = PLACES_BACKUP;\n        }\n        ref2 = parseCoord(block, this.format);\n        for (k in ref2) {\n          v = ref2[k];\n          command.op[k] = v;\n        }\n      }\n      return command;\n    };\n\n    return DrillParser;\n\n  })(Parser);\n\n  module.exports = DrillParser;\n\n}).call(this);\n\n},{\"./coord-parser\":1,\"./parser\":11,\"./svg-coord\":14}],3:[function(require,module,exports){\n(function() {\n  var DrillReader;\n\n  DrillReader = (function() {\n    function DrillReader(drillFile) {\n      this.line = 0;\n      this.blocks = drillFile.split(/\\r?\\n/);\n    }\n\n    DrillReader.prototype.nextBlock = function() {\n      if (this.line < this.blocks.length) {\n        return this.blocks[++this.line - 1];\n      } else {\n        return false;\n      }\n    };\n\n    return DrillReader;\n\n  })();\n\n  module.exports = DrillReader;\n\n}).call(this);\n\n},{}],4:[function(require,module,exports){\n(function() {\n  var GerberParser, Parser, getSvgCoord, parseCoord, reCOORD,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Parser = require('./parser');\n\n  parseCoord = require('./coord-parser');\n\n  getSvgCoord = require('./svg-coord').get;\n\n  reCOORD = /([XYIJ][+-]?\\d+){1,4}/g;\n\n  GerberParser = (function(superClass) {\n    extend(GerberParser, superClass);\n\n    function GerberParser() {\n      return GerberParser.__super__.constructor.apply(this, arguments);\n    }\n\n    GerberParser.prototype.parseFormat = function(p, c) {\n      var base, base1, nota, places, zero;\n      zero = p[2] === 'L' || p[2] === 'T' ? p[2] : null;\n      nota = p[3] === 'A' || p[3] === 'I' ? p[3] : null;\n      if (p[4] === 'X' && p[7] === 'Y' && p.slice(5, 7) === p.slice(8, 10) && p[5] < 8 && p[6] < 8) {\n        places = [+p[5], +p[6]];\n      }\n      if ((places == null) || (nota == null) || (zero == null)) {\n        throw new Error('invalid format specification');\n      }\n      if ((base = this.format).zero == null) {\n        base.zero = zero;\n      }\n      if ((base1 = this.format).places == null) {\n        base1.places = places;\n      }\n      if (c.set == null) {\n        c.set = {};\n      }\n      return c.set.notation = nota;\n    };\n\n    GerberParser.prototype.parseToolDef = function(p, c) {\n      var code, hole, m, mods, ref, ref1, shape;\n      if (c.tool == null) {\n        c.tool = {};\n      }\n      code = (ref = p.match(/^ADD\\d{2,}/)) != null ? ref[0].slice(2) : void 0;\n      ref1 = p.slice(2 + code.length).split(','), shape = ref1[0], mods = ref1[1];\n      mods = mods != null ? mods.split('X') : void 0;\n      while (code[1] === '0') {\n        code = code[0] + code.slice(2);\n      }\n      switch (shape) {\n        case 'C':\n          if (mods.length > 2) {\n            hole = {\n              width: getSvgCoord(mods[1], {\n                places: this.format.places\n              }),\n              height: getSvgCoord(mods[2], {\n                places: this.format.places\n              })\n            };\n          } else if (mods.length > 1) {\n            hole = {\n              dia: getSvgCoord(mods[1], {\n                places: this.format.places\n              })\n            };\n          }\n          c.tool[code] = {\n            dia: getSvgCoord(mods[0], {\n              places: this.format.places\n            })\n          };\n          if (hole != null) {\n            return c.tool[code].hole = hole;\n          }\n          break;\n        case 'R':\n        case 'O':\n          if (mods.length > 3) {\n            hole = {\n              width: getSvgCoord(mods[2], {\n                places: this.format.places\n              }),\n              height: getSvgCoord(mods[3], {\n                places: this.format.places\n              })\n            };\n          } else if (mods.length > 2) {\n            hole = {\n              dia: getSvgCoord(mods[2], {\n                places: this.format.places\n              })\n            };\n          }\n          c.tool[code] = {\n            width: getSvgCoord(mods[0], {\n              places: this.format.places\n            }),\n            height: getSvgCoord(mods[1], {\n              places: this.format.places\n            })\n          };\n          if (shape === 'O') {\n            c.tool[code].obround = true;\n          }\n          if (hole != null) {\n            return c.tool[code].hole = hole;\n          }\n          break;\n        case 'P':\n          if (mods.length > 4) {\n            hole = {\n              width: getSvgCoord(mods[3], {\n                places: this.format.places\n              }),\n              height: getSvgCoord(mods[4], {\n                places: this.format.places\n              })\n            };\n          } else if (mods.length > 3) {\n            hole = {\n              dia: getSvgCoord(mods[3], {\n                places: this.format.places\n              })\n            };\n          }\n          c.tool[code] = {\n            dia: getSvgCoord(mods[0], {\n              places: this.format.places\n            }),\n            verticies: +mods[1]\n          };\n          if (mods.length > 2) {\n            c.tool[code].degrees = +mods[2];\n          }\n          if (hole != null) {\n            return c.tool[code].hole = hole;\n          }\n          break;\n        default:\n          mods = (function() {\n            var k, len, ref2, results;\n            ref2 = mods != null ? mods : [];\n            results = [];\n            for (k = 0, len = ref2.length; k < len; k++) {\n              m = ref2[k];\n              results.push(+m);\n            }\n            return results;\n          })();\n          return c.tool[code] = {\n            macro: shape,\n            mods: mods\n          };\n      }\n    };\n\n    GerberParser.prototype.parseCommand = function(block) {\n      var axis, c, code, coord, i, j, k, len, m, op, p, param, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tool, u, val, x, y;\n      if (block == null) {\n        block = {};\n      }\n      c = {};\n      if (param = block.param) {\n        for (k = 0, len = param.length; k < len; k++) {\n          p = param[k];\n          switch (code = p.slice(0, 2)) {\n            case 'FS':\n              this.parseFormat(p, c);\n              break;\n            case 'MO':\n              u = p.slice(2, 4);\n              if (c.set == null) {\n                c.set = {};\n              }\n              if (u === 'IN') {\n                c.set.units = 'in';\n              } else if (u === 'MM') {\n                c.set.units = 'mm';\n              } else {\n                throw new Error(p + \" is an invalid units setting\");\n              }\n              break;\n            case 'AD':\n              this.parseToolDef(p, c);\n              break;\n            case 'AM':\n              return {\n                macro: param\n              };\n            case 'LP':\n              if (c[\"new\"] == null) {\n                c[\"new\"] = {};\n              }\n              if (p[2] === 'D' || p[2] === 'C') {\n                c[\"new\"].layer = p[2];\n              }\n              if (c[\"new\"].layer == null) {\n                throw new Error('invalid level polarity');\n              }\n              break;\n            case 'SR':\n              if (c[\"new\"] == null) {\n                c[\"new\"] = {};\n              }\n              x = (ref = (ref1 = p.match(/X[+-]?[\\d\\.]+/)) != null ? ref1[0].slice(1) : void 0) != null ? ref : 1;\n              y = (ref2 = (ref3 = p.match(/Y[+-]?[\\d\\.]+/)) != null ? ref3[0].slice(1) : void 0) != null ? ref2 : 1;\n              i = (ref4 = p.match(/I[+-]?[\\d\\.]+/)) != null ? ref4[0].slice(1) : void 0;\n              j = (ref5 = p.match(/J[+-]?[\\d\\.]+/)) != null ? ref5[0].slice(1) : void 0;\n              if ((x < 1 || y < 1) || (x > 1 && ((i == null) || i < 0)) || (y > 1 && ((j == null) || j < 0))) {\n                throw new Error('invalid step repeat');\n              }\n              c[\"new\"].sr = {\n                x: +x,\n                y: +y\n              };\n              if (i != null) {\n                c[\"new\"].sr.i = getSvgCoord(i, {\n                  places: this.format.places\n                });\n              }\n              if (j != null) {\n                c[\"new\"].sr.j = getSvgCoord(j, {\n                  places: this.format.places\n                });\n              }\n          }\n        }\n      } else if (block = block.block) {\n        if (block === 'M02') {\n          return {\n            set: {\n              done: true\n            }\n          };\n        } else if (block[0] === 'G') {\n          switch (code = (ref6 = block.slice(1).match(/^\\d{1,2}/)) != null ? ref6[0] : void 0) {\n            case '4':\n            case '04':\n              return {};\n            case '1':\n            case '01':\n            case '2':\n            case '02':\n            case '3':\n            case '03':\n              code = code[code.length - 1];\n              m = code === '1' ? 'i' : code === '2' ? 'cw' : 'ccw';\n              c.set = {\n                mode: m\n              };\n              break;\n            case '36':\n            case '37':\n              c.set = {\n                region: code === '36'\n              };\n              break;\n            case '70':\n            case '71':\n              c.set = {\n                backupUnits: code === '70' ? 'in' : 'mm'\n              };\n              break;\n            case '74':\n            case '75':\n              c.set = {\n                quad: code === '74' ? 's' : 'm'\n              };\n          }\n        }\n        coord = parseCoord((ref7 = block.match(reCOORD)) != null ? ref7[0] : void 0, this.format);\n        if (op = ((ref8 = block.match(/D0?[123]$/)) != null ? ref8[0] : void 0) || Object.keys(coord).length) {\n          if (op != null) {\n            op = op[op.length - 1];\n          }\n          op = (function() {\n            switch (op) {\n              case '1':\n                return 'int';\n              case '2':\n                return 'move';\n              case '3':\n                return 'flash';\n              default:\n                return 'last';\n            }\n          })();\n          c.op = {\n            \"do\": op\n          };\n          for (axis in coord) {\n            val = coord[axis];\n            c.op[axis] = val;\n          }\n        } else if (tool = (ref9 = block.match(/D\\d+$/)) != null ? ref9[0] : void 0) {\n          c.set = {\n            currentTool: tool\n          };\n        }\n      }\n      return c;\n    };\n\n    return GerberParser;\n\n  })(Parser);\n\n  module.exports = GerberParser;\n\n}).call(this);\n\n},{\"./coord-parser\":1,\"./parser\":11,\"./svg-coord\":14}],5:[function(require,module,exports){\n(function() {\n  var GerberReader;\n\n  GerberReader = (function() {\n    function GerberReader(gerberFile) {\n      this.gerberFile = gerberFile != null ? gerberFile : '';\n      this.line = 0;\n      this.charIndex = 0;\n      this.end = this.gerberFile.length;\n    }\n\n    GerberReader.prototype.nextBlock = function() {\n      var char, current, parameter;\n      if (this.index >= this.end) {\n        return false;\n      }\n      current = '';\n      parameter = false;\n      if (this.line === 0) {\n        this.line++;\n      }\n      while (!(this.charIndex >= this.end)) {\n        char = this.gerberFile[this.charIndex++];\n        if (char === '%') {\n          if (!parameter) {\n            parameter = [];\n          } else {\n            return {\n              param: parameter\n            };\n          }\n        } else if (char === '*') {\n          if (parameter) {\n            parameter.push(current);\n            current = '';\n          } else {\n            return {\n              block: current\n            };\n          }\n        } else if (char === '\\n') {\n          this.line++;\n        } else if ((' ' <= char && char <= '~')) {\n          current += char;\n        }\n      }\n      return false;\n    };\n\n    GerberReader.prototype.getLine = function() {\n      return this.line;\n    };\n\n    return GerberReader;\n\n  })();\n\n  module.exports = GerberReader;\n\n}).call(this);\n\n},{}],6:[function(require,module,exports){\n(function (global){\n(function() {\n  var DEFAULT_OPTS, DrillParser, DrillReader, GerberParser, GerberReader, Plotter, builder, coordFactor;\n\n  builder = require('./obj-to-xml');\n\n  Plotter = require('./plotter');\n\n  DrillReader = require('./drill-reader');\n\n  DrillParser = require('./drill-parser');\n\n  GerberReader = require('./gerber-reader');\n\n  GerberParser = require('./gerber-parser');\n\n  coordFactor = require('./svg-coord').factor;\n\n  DEFAULT_OPTS = {\n    drill: false,\n    pretty: false,\n    object: false,\n    warnArr: null,\n    places: null,\n    zero: null,\n    notation: null,\n    units: null\n  };\n\n  module.exports = function(file, options) {\n    var a, error, height, key, oldWarn, opts, p, parser, parserOpts, plotterOpts, reader, ref, root, val, width, xml, xmlObject;\n    if (options == null) {\n      options = {};\n    }\n    opts = {};\n    for (key in DEFAULT_OPTS) {\n      val = DEFAULT_OPTS[key];\n      opts[key] = val;\n    }\n    for (key in options) {\n      val = options[key];\n      opts[key] = val;\n    }\n    if (typeof file === 'object') {\n      if (file.svg != null) {\n        return builder(file, {\n          pretty: opts.pretty\n        });\n      } else {\n        throw new Error('non SVG object cannot be converted to an SVG string');\n      }\n    }\n    parserOpts = null;\n    if ((opts.places != null) || (opts.zero != null)) {\n      parserOpts = {\n        places: opts.places,\n        zero: opts.zero\n      };\n    }\n    if (opts.drill) {\n      reader = new DrillReader(file);\n      parser = new DrillParser(parserOpts);\n    } else {\n      reader = new GerberReader(file);\n      parser = new GerberParser(parserOpts);\n    }\n    plotterOpts = null;\n    if ((opts.notation != null) || (opts.units != null)) {\n      plotterOpts = {\n        notation: opts.notation,\n        units: opts.units\n      };\n    }\n    p = new Plotter(reader, parser, plotterOpts);\n    oldWarn = null;\n    root = null;\n    if (Array.isArray(opts.warnArr)) {\n      root = typeof window !== \"undefined\" && window !== null ? window : global;\n      if (root.console == null) {\n        root.console = {};\n      }\n      oldWarn = root.console.warn;\n      root.console.warn = function(chunk) {\n        return opts.warnArr.push(chunk.toString());\n      };\n    }\n    try {\n      xmlObject = p.plot();\n    } catch (_error) {\n      error = _error;\n      throw new Error(\"Error at line \" + p.reader.line + \" - \" + error.message);\n    } finally {\n      if ((oldWarn != null) && (root != null)) {\n        root.console.warn = oldWarn;\n      }\n    }\n    if (!(p.bbox.xMin >= p.bbox.xMax)) {\n      width = p.bbox.xMax - p.bbox.xMin;\n    } else {\n      p.bbox.xMin = 0;\n      p.bbox.xMax = 0;\n      width = 0;\n    }\n    if (!(p.bbox.yMin >= p.bbox.yMax)) {\n      height = p.bbox.yMax - p.bbox.yMin;\n    } else {\n      p.bbox.yMin = 0;\n      p.bbox.yMax = 0;\n      height = 0;\n    }\n    xml = {\n      svg: {\n        xmlns: 'http://www.w3.org/2000/svg',\n        version: '1.1',\n        'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n        width: \"\" + (width / coordFactor) + p.units,\n        height: \"\" + (height / coordFactor) + p.units,\n        viewBox: [p.bbox.xMin, p.bbox.yMin, width, height],\n        _: []\n      }\n    };\n    ref = p.attr;\n    for (a in ref) {\n      val = ref[a];\n      xml.svg[a] = val;\n    }\n    if (p.defs.length) {\n      xml.svg._.push({\n        defs: {\n          _: p.defs\n        }\n      });\n    }\n    if (p.group.g._.length) {\n      xml.svg._.push(p.group);\n    }\n    if (!opts.object) {\n      return builder(xml, {\n        pretty: opts.pretty\n      });\n    } else {\n      return xml;\n    }\n  };\n\n}).call(this);\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./drill-parser\":2,\"./drill-reader\":3,\"./gerber-parser\":4,\"./gerber-reader\":5,\"./obj-to-xml\":9,\"./plotter\":12,\"./svg-coord\":14}],7:[function(require,module,exports){\n(function() {\n  var NUMBER, OPERATOR, TOKEN, isNumber, parse, tokenize;\n\n  OPERATOR = /[\\+\\-\\/xX\\(\\)]/;\n\n  NUMBER = /[\\$\\d\\.]+/;\n\n  TOKEN = new RegExp(\"(\" + OPERATOR.source + \")|(\" + NUMBER.source + \")\", 'g');\n\n  tokenize = function(arith) {\n    var results;\n    return results = arith.match(TOKEN);\n  };\n\n  isNumber = function(token) {\n    return NUMBER.test(token);\n  };\n\n  parse = function(arith) {\n    var consume, index, parseExpression, parseMultiplication, parsePrimary, peek, tokens;\n    tokens = tokenize(arith);\n    index = 0;\n    peek = function() {\n      return tokens[index];\n    };\n    consume = function(t) {\n      if (t === peek()) {\n        return index++;\n      }\n    };\n    parsePrimary = function() {\n      var exp, t;\n      t = peek();\n      consume(t);\n      if (isNumber(t)) {\n        exp = {\n          type: 'n',\n          val: t\n        };\n      } else if (t === '(') {\n        exp = parseExpression();\n        if (peek() !== ')') {\n          throw new Error(\"expected ')'\");\n        } else {\n          consume(')');\n        }\n      } else {\n        throw new Error(t + \" is unexpected in an arithmetic string\");\n      }\n      return exp;\n    };\n    parseMultiplication = function() {\n      var exp, rhs, t;\n      exp = parsePrimary();\n      t = peek();\n      while (t === 'x' || t === '/' || t === 'X') {\n        consume(t);\n        if (t === 'X') {\n          console.warn(\"Warning: uppercase 'X' as multiplication symbol is incorrect; macros should use lowercase 'x' to multiply\");\n          t = 'x';\n        }\n        rhs = parsePrimary();\n        exp = {\n          type: t,\n          left: exp,\n          right: rhs\n        };\n        t = peek();\n      }\n      return exp;\n    };\n    parseExpression = function() {\n      var exp, rhs, t;\n      exp = parseMultiplication();\n      t = peek();\n      while (t === '+' || t === '-') {\n        consume(t);\n        rhs = parseMultiplication();\n        exp = {\n          type: t,\n          left: exp,\n          right: rhs\n        };\n        t = peek();\n      }\n      return exp;\n    };\n    return parseExpression();\n  };\n\n  module.exports = {\n    tokenize: tokenize,\n    isNumber: isNumber,\n    parse: parse\n  };\n\n}).call(this);\n\n},{}],8:[function(require,module,exports){\n(function() {\n  var MacroTool, calc, getSvgCoord, shapes, unique;\n\n  shapes = require('./pad-shapes');\n\n  calc = require('./macro-calc');\n\n  unique = require('./unique-id');\n\n  getSvgCoord = require('./svg-coord').get;\n\n  MacroTool = (function() {\n    function MacroTool(blocks, numberFormat) {\n      this.modifiers = {};\n      this.name = blocks[0].slice(2);\n      this.blocks = blocks.slice(1);\n      this.shapes = [];\n      this.masks = [];\n      this.lastExposure = null;\n      this.bbox = [null, null, null, null];\n      this.format = {\n        places: numberFormat\n      };\n    }\n\n    MacroTool.prototype.run = function(tool, modifiers) {\n      var b, group, i, j, k, l, len, len1, len2, len3, m, n, pad, padId, ref, ref1, ref2, s, shape;\n      if (modifiers == null) {\n        modifiers = [];\n      }\n      this.lastExposure = null;\n      this.shapes = [];\n      this.masks = [];\n      this.bbox = [null, null, null, null];\n      this.modifiers = {};\n      for (i = j = 0, len = modifiers.length; j < len; i = ++j) {\n        m = modifiers[i];\n        this.modifiers[\"$\" + (i + 1)] = m;\n      }\n      ref = this.blocks;\n      for (k = 0, len1 = ref.length; k < len1; k++) {\n        b = ref[k];\n        this.runBlock(b);\n      }\n      padId = \"tool-\" + tool + \"-pad-\" + (unique());\n      pad = [];\n      ref1 = this.masks;\n      for (l = 0, len2 = ref1.length; l < len2; l++) {\n        m = ref1[l];\n        pad.push(m);\n      }\n      if (this.shapes.length > 1) {\n        group = {\n          id: padId,\n          _: []\n        };\n        ref2 = this.shapes;\n        for (n = 0, len3 = ref2.length; n < len3; n++) {\n          s = ref2[n];\n          group._.push(s);\n        }\n        pad = [\n          {\n            g: group\n          }\n        ];\n      } else if (this.shapes.length === 1) {\n        shape = Object.keys(this.shapes[0])[0];\n        this.shapes[0][shape].id = padId;\n        pad.push(this.shapes[0]);\n      }\n      return {\n        pad: pad,\n        padId: padId,\n        bbox: this.bbox,\n        trace: false\n      };\n    };\n\n    MacroTool.prototype.runBlock = function(block) {\n      var a, args, i, j, len, mod, ref, val;\n      switch (block[0]) {\n        case '$':\n          mod = (ref = block.match(/^\\$\\d+(?=\\=)/)) != null ? ref[0] : void 0;\n          val = block.slice(1 + mod.length);\n          return this.modifiers[mod] = this.getNumber(val);\n        case '1':\n        case '2':\n        case '20':\n        case '21':\n        case '22':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n          args = block.split(',');\n          for (i = j = 0, len = args.length; j < len; i = ++j) {\n            a = args[i];\n            args[i] = this.getNumber(a);\n          }\n          return this.primitive(args);\n        default:\n          if (block[0] !== '0') {\n            throw new Error(\"'\" + block + \"' unrecognized tool macro block\");\n          }\n      }\n    };\n\n    MacroTool.prototype.primitive = function(args) {\n      var group, i, j, k, key, l, len, len1, len2, len3, len4, m, mask, maskId, n, o, points, q, ref, ref1, ref2, ref3, ref4, ref5, results, rot, rotation, s, shape;\n      mask = false;\n      rotation = false;\n      shape = null;\n      switch (args[0]) {\n        case 1:\n          shape = shapes.circle({\n            dia: getSvgCoord(args[2], this.format),\n            cx: getSvgCoord(args[3], this.format),\n            cy: getSvgCoord(args[4], this.format)\n          });\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox);\n          }\n          break;\n        case 2:\n        case 20:\n          shape = shapes.vector({\n            width: getSvgCoord(args[2], this.format),\n            x1: getSvgCoord(args[3], this.format),\n            y1: getSvgCoord(args[4], this.format),\n            x2: getSvgCoord(args[5], this.format),\n            y2: getSvgCoord(args[6], this.format)\n          });\n          if (args[7]) {\n            shape.shape.line.transform = \"rotate(\" + args[7] + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[7]);\n          }\n          break;\n        case 21:\n          shape = shapes.rect({\n            cx: getSvgCoord(args[4], this.format),\n            cy: getSvgCoord(args[5], this.format),\n            width: getSvgCoord(args[2], this.format),\n            height: getSvgCoord(args[3], this.format)\n          });\n          if (args[6]) {\n            shape.shape.rect.transform = \"rotate(\" + args[6] + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[6]);\n          }\n          break;\n        case 22:\n          shape = shapes.lowerLeftRect({\n            x: getSvgCoord(args[4], this.format),\n            y: getSvgCoord(args[5], this.format),\n            width: getSvgCoord(args[2], this.format),\n            height: getSvgCoord(args[3], this.format)\n          });\n          if (args[6]) {\n            shape.shape.rect.transform = \"rotate(\" + args[6] + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[6]);\n          }\n          break;\n        case 4:\n          points = [];\n          for (i = j = 3, ref = 3 + 2 * args[2]; j <= ref; i = j += 2) {\n            points.push([getSvgCoord(args[i], this.format), getSvgCoord(args[i + 1], this.format)]);\n          }\n          shape = shapes.outline({\n            points: points\n          });\n          if (rot = args[args.length - 1]) {\n            shape.shape.polygon.transform = \"rotate(\" + rot + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[args.length - 1]);\n          }\n          break;\n        case 5:\n          if (args[6] !== 0 && (args[3] !== 0 || args[4] !== 0)) {\n            throw new RangeError('polygon center must be 0,0 if rotated in macro');\n          }\n          shape = shapes.polygon({\n            cx: getSvgCoord(args[3], this.format),\n            cy: getSvgCoord(args[4], this.format),\n            dia: getSvgCoord(args[5], this.format),\n            verticies: args[2],\n            degrees: args[6]\n          });\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox);\n          }\n          break;\n        case 6:\n          if (args[9] !== 0 && (args[1] !== 0 || args[2] !== 0)) {\n            throw new RangeError('moiré center must be 0,0 if rotated in macro');\n          }\n          shape = shapes.moire({\n            cx: getSvgCoord(args[1], this.format),\n            cy: getSvgCoord(args[2], this.format),\n            outerDia: getSvgCoord(args[3], this.format),\n            ringThx: getSvgCoord(args[4], this.format),\n            ringGap: getSvgCoord(args[5], this.format),\n            maxRings: args[6],\n            crossThx: getSvgCoord(args[7], this.format),\n            crossLength: getSvgCoord(args[8], this.format)\n          });\n          if (args[9]) {\n            ref1 = shape.shape;\n            for (k = 0, len = ref1.length; k < len; k++) {\n              s = ref1[k];\n              if (s.line != null) {\n                s.line.transform = \"rotate(\" + args[9] + \")\";\n              }\n            }\n          }\n          this.addBbox(shape.bbox, args[9]);\n          break;\n        case 7:\n          if (args[9] !== 0 && (args[1] !== 0 || args[2] !== 0)) {\n            throw new RangeError('thermal center must be 0,0 if rotated in macro');\n          }\n          shape = shapes.thermal({\n            cx: getSvgCoord(args[1], this.format),\n            cy: getSvgCoord(args[2], this.format),\n            outerDia: getSvgCoord(args[3], this.format),\n            innerDia: getSvgCoord(args[4], this.format),\n            gap: getSvgCoord(args[5], this.format)\n          });\n          if (args[6]) {\n            ref2 = shape.shape;\n            for (l = 0, len1 = ref2.length; l < len1; l++) {\n              s = ref2[l];\n              if (s.mask != null) {\n                ref3 = s.mask._;\n                for (n = 0, len2 = ref3.length; n < len2; n++) {\n                  m = ref3[n];\n                  if (m.rect != null) {\n                    m.rect.transform = \"rotate(\" + args[6] + \")\";\n                  }\n                }\n              }\n            }\n          }\n          this.addBbox(shape.bbox, args[6]);\n          break;\n        default:\n          throw new Error(args[0] + \" is not a valid primitive code\");\n      }\n      if (mask) {\n        for (key in shape.shape) {\n          shape.shape[key].fill = '#000';\n        }\n        if (this.lastExposure !== 0) {\n          this.lastExposure = 0;\n          maskId = \"macro-\" + this.name + \"-mask-\" + (unique());\n          m = {\n            mask: {\n              id: maskId\n            }\n          };\n          m.mask._ = [\n            {\n              rect: {\n                x: this.bbox[0],\n                y: this.bbox[1],\n                width: this.bbox[2] - this.bbox[0],\n                height: this.bbox[3] - this.bbox[1],\n                fill: '#fff'\n              }\n            }\n          ];\n          if (this.shapes.length === 1) {\n            for (key in this.shapes[0]) {\n              this.shapes[0][key].mask = \"url(#\" + maskId + \")\";\n            }\n          } else if (this.shapes.length > 1) {\n            group = {\n              mask: \"url(#\" + maskId + \")\",\n              _: []\n            };\n            ref4 = this.shapes;\n            for (o = 0, len3 = ref4.length; o < len3; o++) {\n              s = ref4[o];\n              group._.push(s);\n            }\n            this.shapes = [\n              {\n                g: group\n              }\n            ];\n          }\n          this.masks.push(m);\n        }\n        return this.masks[this.masks.length - 1].mask._.push(shape.shape);\n      } else {\n        this.lastExposure = 1;\n        if (!Array.isArray(shape.shape)) {\n          return this.shapes.push(shape.shape);\n        } else {\n          ref5 = shape.shape;\n          results = [];\n          for (q = 0, len4 = ref5.length; q < len4; q++) {\n            s = ref5[q];\n            if (s.mask != null) {\n              results.push(this.masks.push(s));\n            } else {\n              results.push(this.shapes.push(s));\n            }\n          }\n          return results;\n        }\n      }\n    };\n\n    MacroTool.prototype.addBbox = function(bbox, rotation) {\n      var b, c, j, len, p, points, s, x, y;\n      if (rotation == null) {\n        rotation = 0;\n      }\n      if (!rotation) {\n        if (this.bbox[0] === null || bbox[0] < this.bbox[0]) {\n          this.bbox[0] = bbox[0];\n        }\n        if (this.bbox[1] === null || bbox[1] < this.bbox[1]) {\n          this.bbox[1] = bbox[1];\n        }\n        if (this.bbox[2] === null || bbox[2] > this.bbox[2]) {\n          this.bbox[2] = bbox[2];\n        }\n        if (this.bbox[3] === null || bbox[3] > this.bbox[3]) {\n          return this.bbox[3] = bbox[3];\n        }\n      } else {\n        s = Math.sin(rotation * Math.PI / 180);\n        c = Math.cos(rotation * Math.PI / 180);\n        if (Math.abs(s) < 0.000000001) {\n          s = 0;\n        }\n        if (Math.abs(c) < 0.000000001) {\n          c = 0;\n        }\n        points = [[bbox[0], bbox[1]], [bbox[2], bbox[1]], [bbox[2], bbox[3]], [bbox[0], bbox[3]]];\n        for (j = 0, len = points.length; j < len; j++) {\n          p = points[j];\n          x = (p[0] * c) - (p[1] * s);\n          y = (p[0] * s) + (p[1] * c);\n          if (this.bbox[0] === null || x < this.bbox[0]) {\n            this.bbox[0] = x;\n          }\n          if (this.bbox[1] === null || y < this.bbox[1]) {\n            this.bbox[1] = y;\n          }\n          if (this.bbox[2] === null || x > this.bbox[2]) {\n            this.bbox[2] = x;\n          }\n          if (this.bbox[3] === null || y > this.bbox[3]) {\n            this.bbox[3] = y;\n          }\n        }\n        return this.bbox = (function() {\n          var k, len1, ref, results;\n          ref = this.bbox;\n          results = [];\n          for (k = 0, len1 = ref.length; k < len1; k++) {\n            b = ref[k];\n            results.push(b === -0 ? 0 : b);\n          }\n          return results;\n        }).call(this);\n      }\n    };\n\n    MacroTool.prototype.getNumber = function(s) {\n      if (s.match(/^[+-]?[\\d.]+$/)) {\n        return Number(s);\n      } else if (s.match(/^\\$\\d+$/)) {\n        return Number(this.modifiers[s]);\n      } else {\n        return this.evaluate(calc.parse(s));\n      }\n    };\n\n    MacroTool.prototype.evaluate = function(op) {\n      switch (op.type) {\n        case 'n':\n          return this.getNumber(op.val);\n        case '+':\n          return this.evaluate(op.left) + this.evaluate(op.right);\n        case '-':\n          return this.evaluate(op.left) - this.evaluate(op.right);\n        case 'x':\n          return this.evaluate(op.left) * this.evaluate(op.right);\n        case '/':\n          return this.evaluate(op.left) / this.evaluate(op.right);\n      }\n    };\n\n    return MacroTool;\n\n  })();\n\n  module.exports = MacroTool;\n\n}).call(this);\n\n},{\"./macro-calc\":7,\"./pad-shapes\":10,\"./svg-coord\":14,\"./unique-id\":15}],9:[function(require,module,exports){\n(function() {\n  var CKEY, DTAB, objToXml, repeat;\n\n  repeat = function(pattern, count) {\n    var result;\n    result = '';\n    if (count === 0) {\n      return '';\n    }\n    while (count > 1) {\n      if (count & 1) {\n        result += pattern;\n      }\n      count >>= 1;\n      pattern += pattern;\n    }\n    return result + pattern;\n  };\n\n  CKEY = '_';\n\n  DTAB = '  ';\n\n  objToXml = function(obj, op) {\n    var children, dec, decimals, elem, i, ind, j, key, len, nl, o, pre, ref, ref1, ref2, tb, v, val, xml;\n    if (op == null) {\n      op = {};\n    }\n    pre = op.pretty;\n    ind = (ref = op.indent) != null ? ref : 0;\n    dec = (ref1 = op.maxDec) != null ? ref1 : false;\n    decimals = function(n) {\n      if (typeof n === 'number') {\n        return Number(n.toFixed(dec));\n      } else {\n        return n;\n      }\n    };\n    nl = pre ? '\\n' : '';\n    tb = nl ? (typeof pre === 'string' ? pre : DTAB) : '';\n    tb = repeat(tb, ind);\n    xml = '';\n    if (typeof obj === 'function') {\n      obj = obj();\n    }\n    if (Array.isArray(obj)) {\n      for (i = j = 0, len = obj.length; j < len; i = ++j) {\n        o = obj[i];\n        xml += (i !== 0 ? nl : '') + (objToXml(o, op));\n      }\n    } else if (typeof obj === 'object') {\n      children = false;\n      elem = Object.keys(obj)[0];\n      if (elem != null) {\n        xml = tb + \"<\" + elem;\n        if (typeof obj[elem] === 'function') {\n          obj[elem] = obj[elem]();\n        }\n        ref2 = obj[elem];\n        for (key in ref2) {\n          val = ref2[key];\n          if (typeof val === 'function') {\n            val = val();\n          }\n          if (key === CKEY) {\n            children = val;\n          } else {\n            if (Array.isArray(val)) {\n              if (dec) {\n                val = (function() {\n                  var k, len1, results;\n                  results = [];\n                  for (k = 0, len1 = val.length; k < len1; k++) {\n                    v = val[k];\n                    results.push(decimals(v));\n                  }\n                  return results;\n                })();\n              }\n              val = val.join(' ');\n            }\n            if (dec) {\n              val = decimals(val);\n            }\n            xml += \" \" + key + \"=\\\"\" + val + \"\\\"\";\n          }\n        }\n        if (children) {\n          xml += '>' + nl + objToXml(children, {\n            pretty: pre,\n            indent: ind + 1\n          });\n        }\n        if (obj[elem]._ != null) {\n          xml += \"\" + nl + tb + \"</\" + elem + \">\";\n        } else {\n          xml += '/>';\n        }\n      }\n    } else {\n      xml += obj + \" \";\n    }\n    return xml;\n  };\n\n  module.exports = objToXml;\n\n}).call(this);\n\n},{}],10:[function(require,module,exports){\n(function() {\n  var circle, lowerLeftRect, moire, outline, polygon, rect, thermal, unique, vector;\n\n  unique = require('./unique-id');\n\n  circle = function(p) {\n    var r;\n    if (p.dia == null) {\n      throw new Error('circle function requires diameter');\n    }\n    if (p.cx == null) {\n      throw new Error('circle function requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('circle function requires y center');\n    }\n    r = p.dia / 2;\n    return {\n      shape: {\n        circle: {\n          cx: p.cx,\n          cy: p.cy,\n          r: r\n        }\n      },\n      bbox: [p.cx - r, p.cy - r, p.cx + r, p.cy + r]\n    };\n  };\n\n  rect = function(p) {\n    var radius, rectangle, x, y;\n    if (p.width == null) {\n      throw new Error('rectangle requires width');\n    }\n    if (p.height == null) {\n      throw new Error('rectangle requires height');\n    }\n    if (p.cx == null) {\n      throw new Error('rectangle function requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('rectangle function requires y center');\n    }\n    x = p.cx - p.width / 2;\n    y = p.cy - p.height / 2;\n    rectangle = {\n      shape: {\n        rect: {\n          x: x,\n          y: y,\n          width: p.width,\n          height: p.height\n        }\n      },\n      bbox: [x, y, x + p.width, y + p.height]\n    };\n    if (p.obround) {\n      radius = 0.5 * Math.min(p.width, p.height);\n      rectangle.shape.rect.rx = radius;\n      rectangle.shape.rect.ry = radius;\n    }\n    return rectangle;\n  };\n\n  polygon = function(p) {\n    var i, j, points, r, ref, rx, ry, start, step, theta, x, xMax, xMin, y, yMax, yMin;\n    if (p.dia == null) {\n      throw new Error('polygon requires diameter');\n    }\n    if (p.verticies == null) {\n      throw new Error('polygon requires verticies');\n    }\n    if (p.cx == null) {\n      throw new Error('polygon function requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('polygon function requires y center');\n    }\n    start = p.degrees != null ? p.degrees * Math.PI / 180 : 0;\n    step = 2 * Math.PI / p.verticies;\n    r = p.dia / 2;\n    points = '';\n    xMin = null;\n    yMin = null;\n    xMax = null;\n    yMax = null;\n    for (i = j = 0, ref = p.verticies; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      theta = start + (i * step);\n      rx = r * Math.cos(theta);\n      ry = r * Math.sin(theta);\n      if (Math.abs(rx) < 0.000000001) {\n        rx = 0;\n      }\n      if (Math.abs(ry) < 0.000000001) {\n        ry = 0;\n      }\n      x = p.cx + rx;\n      y = p.cy + ry;\n      if (x < xMin || xMin === null) {\n        xMin = x;\n      }\n      if (x > xMax || xMax === null) {\n        xMax = x;\n      }\n      if (y < yMin || yMin === null) {\n        yMin = y;\n      }\n      if (y > yMax || yMax === null) {\n        yMax = y;\n      }\n      points += \" \" + x + \",\" + y;\n    }\n    return {\n      shape: {\n        polygon: {\n          points: points.slice(1)\n        }\n      },\n      bbox: [xMin, yMin, xMax, yMax]\n    };\n  };\n\n  vector = function(p) {\n    var theta, xDelta, yDelta;\n    if (p.x1 == null) {\n      throw new Error('vector function requires start x');\n    }\n    if (p.y1 == null) {\n      throw new Error('vector function requires start y');\n    }\n    if (p.x2 == null) {\n      throw new Error('vector function requires end x');\n    }\n    if (p.y2 == null) {\n      throw new Error('vector function requires end y');\n    }\n    if (p.width == null) {\n      throw new Error('vector function requires width');\n    }\n    theta = Math.abs(Math.atan((p.y2 - p.y1) / (p.x2 - p.x1)));\n    xDelta = p.width / 2 * Math.sin(theta);\n    yDelta = p.width / 2 * Math.cos(theta);\n    if (xDelta < 0.0000001) {\n      xDelta = 0;\n    }\n    if (yDelta < 0.0000001) {\n      yDelta = 0;\n    }\n    return {\n      shape: {\n        line: {\n          x1: p.x1,\n          x2: p.x2,\n          y1: p.y1,\n          y2: p.y2,\n          'stroke-width': p.width,\n          'stroke-linecap': 'butt'\n        }\n      },\n      bbox: [(Math.min(p.x1, p.x2)) - xDelta, (Math.min(p.y1, p.y2)) - yDelta, (Math.max(p.x1, p.x2)) + xDelta, (Math.max(p.y1, p.y2)) + yDelta]\n    };\n  };\n\n  lowerLeftRect = function(p) {\n    if (p.width == null) {\n      throw new Error('lower left rect requires width');\n    }\n    if (p.height == null) {\n      throw new Error('lower left rect requires height');\n    }\n    if (p.x == null) {\n      throw new Error('lower left rectangle requires x');\n    }\n    if (p.y == null) {\n      throw new Error('lower left rectangle requires y');\n    }\n    return {\n      shape: {\n        rect: {\n          x: p.x,\n          y: p.y,\n          width: p.width,\n          height: p.height\n        }\n      },\n      bbox: [p.x, p.y, p.x + p.width, p.y + p.height]\n    };\n  };\n\n  outline = function(p) {\n    var j, len, point, pointString, ref, x, xLast, xMax, xMin, y, yLast, yMax, yMin;\n    if (!(Array.isArray(p.points) && p.points.length > 1)) {\n      throw new Error('outline function requires points array');\n    }\n    xMin = null;\n    yMin = null;\n    xMax = null;\n    yMax = null;\n    pointString = '';\n    ref = p.points;\n    for (j = 0, len = ref.length; j < len; j++) {\n      point = ref[j];\n      if (!(Array.isArray(point) && point.length === 2)) {\n        throw new Error('outline function requires points array');\n      }\n      x = point[0];\n      y = point[1];\n      if (x < xMin || xMin === null) {\n        xMin = x;\n      }\n      if (x > xMax || xMax === null) {\n        xMax = x;\n      }\n      if (y < yMin || yMin === null) {\n        yMin = y;\n      }\n      if (y > yMax || yMax === null) {\n        yMax = y;\n      }\n      pointString += \" \" + x + \",\" + y;\n    }\n    xLast = p.points[p.points.length - 1][0];\n    yLast = p.points[p.points.length - 1][1];\n    if (!(xLast === p.points[0][0] && yLast === p.points[0][1])) {\n      throw new RangeError('last point must match first point of outline');\n    }\n    return {\n      shape: {\n        polygon: {\n          points: pointString.slice(1)\n        }\n      },\n      bbox: [xMin, yMin, xMax, yMax]\n    };\n  };\n\n  moire = function(p) {\n    var r, rings, shape;\n    if (p.cx == null) {\n      throw new Error('moiré requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('moiré requires y center');\n    }\n    if (p.outerDia == null) {\n      throw new Error('moiré requires outer diameter');\n    }\n    if (p.ringThx == null) {\n      throw new Error('moiré requires ring thickness');\n    }\n    if (p.ringGap == null) {\n      throw new Error('moiré requires ring gap');\n    }\n    if (p.maxRings == null) {\n      throw new Error('moiré requires max rings');\n    }\n    if (p.crossLength == null) {\n      throw new Error('moiré requires crosshair length');\n    }\n    if (p.crossThx == null) {\n      throw new Error('moiré requires crosshair thickness');\n    }\n    shape = [\n      {\n        line: {\n          x1: p.cx - p.crossLength / 2,\n          y1: 0,\n          x2: p.cx + p.crossLength / 2,\n          y2: 0,\n          'stroke-width': p.crossThx,\n          'stroke-linecap': 'butt'\n        }\n      }, {\n        line: {\n          x1: 0,\n          y1: p.cy - p.crossLength / 2,\n          x2: 0,\n          y2: p.cy + p.crossLength / 2,\n          'stroke-width': p.crossThx,\n          'stroke-linecap': 'butt'\n        }\n      }\n    ];\n    r = (p.outerDia - p.ringThx) / 2;\n    rings = 0;\n    while (r >= p.ringThx && rings < p.maxRings) {\n      shape.push({\n        circle: {\n          cx: p.cx,\n          cy: p.cy,\n          r: r,\n          fill: 'none',\n          'stroke-width': p.ringThx\n        }\n      });\n      rings++;\n      r -= p.ringThx + p.ringGap;\n    }\n    r += 0.5 * p.ringThx;\n    if (r > 0 && rings < p.maxRings) {\n      shape.push({\n        circle: {\n          cx: p.cx,\n          cy: p.cy,\n          r: r\n        }\n      });\n    }\n    return {\n      shape: shape,\n      bbox: [Math.min(p.cx - p.crossLength / 2, p.cx - p.outerDia / 2), Math.min(p.cy - p.crossLength / 2, p.cy - p.outerDia / 2), Math.max(p.cx + p.crossLength / 2, p.cx + p.outerDia / 2), Math.max(p.cy + p.crossLength / 2, p.cy + p.outerDia / 2)]\n    };\n  };\n\n  thermal = function(p) {\n    var halfGap, maskId, outerR, r, thx, xMax, xMin, yMax, yMin;\n    if (p.cx == null) {\n      throw new Error('thermal requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('thermal requires y center');\n    }\n    if (p.outerDia == null) {\n      throw new Error('thermal requires outer diameter');\n    }\n    if (p.innerDia == null) {\n      throw new Error('thermal requires inner diameter');\n    }\n    if (p.gap == null) {\n      throw new Error('thermal requires gap');\n    }\n    maskId = \"thermal-mask-\" + (unique());\n    thx = (p.outerDia - p.innerDia) / 2;\n    outerR = p.outerDia / 2;\n    r = outerR - thx / 2;\n    xMin = p.cx - outerR;\n    xMax = p.cx + outerR;\n    yMin = p.cy - outerR;\n    yMax = p.cy + outerR;\n    halfGap = p.gap / 2;\n    return {\n      shape: [\n        {\n          mask: {\n            id: maskId,\n            _: [\n              {\n                circle: {\n                  cx: p.cx,\n                  cy: p.cy,\n                  r: outerR,\n                  fill: '#fff'\n                }\n              }, {\n                rect: {\n                  x: xMin,\n                  y: -halfGap,\n                  width: p.outerDia,\n                  height: p.gap,\n                  fill: '#000'\n                }\n              }, {\n                rect: {\n                  x: -halfGap,\n                  y: yMin,\n                  width: p.gap,\n                  height: p.outerDia,\n                  fill: '#000'\n                }\n              }\n            ]\n          }\n        }, {\n          circle: {\n            cx: p.cx,\n            cy: p.cy,\n            r: r,\n            fill: 'none',\n            'stroke-width': thx,\n            mask: \"url(#\" + maskId + \")\"\n          }\n        }\n      ],\n      bbox: [xMin, yMin, xMax, yMax]\n    };\n  };\n\n  module.exports = {\n    circle: circle,\n    rect: rect,\n    polygon: polygon,\n    vector: vector,\n    lowerLeftRect: lowerLeftRect,\n    outline: outline,\n    moire: moire,\n    thermal: thermal\n  };\n\n}).call(this);\n\n},{\"./unique-id\":15}],11:[function(require,module,exports){\n(function() {\n  var Parser;\n\n  Parser = (function() {\n    function Parser(formatOpts) {\n      var ref, ref1;\n      if (formatOpts == null) {\n        formatOpts = {};\n      }\n      this.format = {\n        zero: (ref = formatOpts.zero) != null ? ref : null,\n        places: (ref1 = formatOpts.places) != null ? ref1 : null\n      };\n      if (this.format.places != null) {\n        if ((!Array.isArray(this.format.places)) || this.format.places.length !== 2 || typeof this.format.places[0] !== 'number' || typeof this.format.places[1] !== 'number') {\n          throw new Error('parser places format must be an array of two numbers');\n        }\n      }\n      if (this.format.zero != null) {\n        if (typeof this.format.zero !== 'string' || (this.format.zero !== 'L' && this.format.zero !== 'T')) {\n          throw new Error(\"parser zero format must be either 'L' or 'T'\");\n        }\n      }\n    }\n\n    return Parser;\n\n  })();\n\n  module.exports = Parser;\n\n}).call(this);\n\n},{}],12:[function(require,module,exports){\n(function() {\n  var ASSUMED_UNITS, HALF_PI, Macro, Plotter, THREEHALF_PI, TWO_PI, coordFactor, tool, unique;\n\n  unique = require('./unique-id');\n\n  Macro = require('./macro-tool');\n\n  tool = require('./standard-tool');\n\n  coordFactor = require('./svg-coord').factor;\n\n  HALF_PI = Math.PI / 2;\n\n  THREEHALF_PI = 3 * HALF_PI;\n\n  TWO_PI = 2 * Math.PI;\n\n  ASSUMED_UNITS = 'in';\n\n  Plotter = (function() {\n    function Plotter(reader, parser, opts) {\n      var ref, ref1;\n      this.reader = reader;\n      this.parser = parser;\n      if (opts == null) {\n        opts = {};\n      }\n      this.units = (ref = opts.units) != null ? ref : null;\n      this.notation = (ref1 = opts.notation) != null ? ref1 : null;\n      this.macros = {};\n      this.tools = {};\n      this.currentTool = '';\n      this.defs = [];\n      this.group = {\n        g: {\n          _: []\n        }\n      };\n      this.polarity = 'D';\n      this.current = [];\n      this.stepRepeat = {\n        x: 1,\n        y: 1,\n        i: 0,\n        j: 0\n      };\n      this.srOverClear = false;\n      this.srOverCurrent = [];\n      this.mode = null;\n      this.quad = null;\n      this.lastOp = null;\n      this.region = false;\n      this.done = false;\n      this.pos = {\n        x: 0,\n        y: 0\n      };\n      this.path = [];\n      this.attr = {\n        'stroke-linecap': 'round',\n        'stroke-linejoin': 'round',\n        'stroke-width': 0,\n        stroke: '#000'\n      };\n      this.bbox = {\n        xMin: Infinity,\n        yMin: Infinity,\n        xMax: -Infinity,\n        yMax: -Infinity\n      };\n      this.layerBbox = {\n        xMin: Infinity,\n        yMin: Infinity,\n        xMax: -Infinity,\n        yMax: -Infinity\n      };\n    }\n\n    Plotter.prototype.addTool = function(code, params) {\n      var obj, t;\n      if (this.tools[code] != null) {\n        throw new Error(\"cannot reassign tool \" + code);\n      }\n      if (params.macro != null) {\n        t = this.macros[params.macro].run(code, params.mods);\n      } else {\n        t = tool(code, params);\n      }\n      this.tools[code] = {\n        trace: t.trace,\n        pad: (function() {\n          var k, len, ref, results;\n          ref = t.pad;\n          results = [];\n          for (k = 0, len = ref.length; k < len; k++) {\n            obj = ref[k];\n            results.push(obj);\n          }\n          return results;\n        })(),\n        flash: function(x, y) {\n          return {\n            use: {\n              x: x,\n              y: y,\n              'xlink:href': \"#\" + t.padId\n            }\n          };\n        },\n        flashed: false,\n        bbox: function(x, y) {\n          if (x == null) {\n            x = 0;\n          }\n          if (y == null) {\n            y = 0;\n          }\n          return {\n            xMin: x + t.bbox[0],\n            yMin: y + t.bbox[1],\n            xMax: x + t.bbox[2],\n            yMax: y + t.bbox[3]\n          };\n        }\n      };\n      return this.changeTool(code);\n    };\n\n    Plotter.prototype.changeTool = function(code) {\n      var ref;\n      this.finishPath();\n      if (this.region) {\n        throw new Error('cannot change tool when in region mode');\n      }\n      if (this.tools[code] == null) {\n        if (!((ref = this.parser) != null ? ref.fmat : void 0)) {\n          throw new Error(\"tool \" + code + \" is not defined\");\n        }\n      } else {\n        return this.currentTool = code;\n      }\n    };\n\n    Plotter.prototype.command = function(c) {\n      var code, m, params, ref, ref1, state, val;\n      if (c.macro != null) {\n        m = new Macro(c.macro, this.parser.format.places);\n        this.macros[m.name] = m;\n        return;\n      }\n      ref = c.set;\n      for (state in ref) {\n        val = ref[state];\n        if (state === 'region') {\n          this.finishPath();\n        }\n        switch (state) {\n          case 'currentTool':\n            this.changeTool(val);\n            break;\n          case 'units':\n          case 'notation':\n            if (this[state] == null) {\n              this[state] = val;\n            }\n            break;\n          default:\n            this[state] = val;\n        }\n      }\n      if (c.tool != null) {\n        ref1 = c.tool;\n        for (code in ref1) {\n          params = ref1[code];\n          this.addTool(code, params);\n        }\n      }\n      if (c.op != null) {\n        this.operate(c.op);\n      }\n      if (c[\"new\"] != null) {\n        this.finishLayer();\n        if (c[\"new\"].layer != null) {\n          return this.polarity = c[\"new\"].layer;\n        } else if (c[\"new\"].sr != null) {\n          this.finishSR();\n          return this.stepRepeat = c[\"new\"].sr;\n        }\n      }\n    };\n\n    Plotter.prototype.plot = function() {\n      var block, ref;\n      while (!this.done) {\n        block = this.reader.nextBlock();\n        if (block === false) {\n          if (((ref = this.parser) != null ? ref.fmat : void 0) == null) {\n            throw new Error('end of file encountered before required M02 command');\n          } else {\n            throw new Error('end of drill file encountered before M00/M30 command');\n          }\n        } else {\n          this.command(this.parser.parseCommand(block));\n        }\n      }\n      return this.finish();\n    };\n\n    Plotter.prototype.finish = function() {\n      this.finishPath();\n      this.finishLayer();\n      this.finishSR();\n      this.group.g.fill = 'currentColor';\n      this.group.g.stroke = 'currentColor';\n      return this.group.g.transform = \"translate(0,\" + (this.bbox.yMin + this.bbox.yMax) + \") scale(1,-1)\";\n    };\n\n    Plotter.prototype.finishSR = function() {\n      var k, l, layer, len, m, maskId, n, ref, ref1, ref2, ref3, ref4, ref5, u, x, y;\n      if (this.srOverClear && this.srOverCurrent) {\n        maskId = \"gerber-sr-mask_\" + (unique());\n        m = {\n          mask: {\n            color: '#000',\n            id: maskId,\n            _: []\n          }\n        };\n        m.mask._.push({\n          rect: {\n            fill: '#fff',\n            x: this.bbox.xMin,\n            y: this.bbox.yMin,\n            width: this.bbox.xMax - this.bbox.xMin,\n            height: this.bbox.yMax - this.bbox.yMin\n          }\n        });\n        for (x = k = 0, ref = this.stepRepeat.x * this.stepRepeat.i, ref1 = this.stepRepeat.i; ref1 > 0 ? k < ref : k > ref; x = k += ref1) {\n          for (y = l = 0, ref2 = this.stepRepeat.y * this.stepRepeat.j, ref3 = this.stepRepeat.j; ref3 > 0 ? l < ref2 : l > ref2; y = l += ref3) {\n            ref4 = this.srOverCurrent;\n            for (n = 0, len = ref4.length; n < len; n++) {\n              layer = ref4[n];\n              u = {\n                use: {}\n              };\n              if (x !== 0) {\n                u.use.x = x;\n              }\n              if (y !== 0) {\n                u.use.y = y;\n              }\n              u.use['xlink:href'] = '#' + ((ref5 = layer.C) != null ? ref5 : layer.D);\n              if (layer.D != null) {\n                u.use.fill = '#fff';\n              }\n              m.mask._.push(u);\n            }\n          }\n        }\n        this.srOverClear = false;\n        this.srOverCurrent = [];\n        this.defs.push(m);\n        return this.group.g.mask = \"url(#\" + maskId + \")\";\n      }\n    };\n\n    Plotter.prototype.finishLayer = function() {\n      var c, h, id, k, l, len, n, obj, ref, ref1, ref2, srId, u, w, x, y;\n      this.finishPath();\n      if (!this.current.length) {\n        return;\n      }\n      if (this.stepRepeat.x > 1 || this.stepRepeat.y > 1) {\n        srId = \"gerber-sr_\" + (unique());\n        this.current = [\n          {\n            g: {\n              id: srId,\n              _: this.current\n            }\n          }\n        ];\n        if (this.srOverClear || this.stepRepeat.i < this.layerBbox.xMax - this.layerBbox.xMin || this.stepRepeat.j < this.layerBbox.yMax - this.layerBbox.yMin) {\n          obj = {};\n          obj[this.polarity] = srId;\n          this.srOverCurrent.push(obj);\n          if (this.polarity === 'C') {\n            this.srOverClear = true;\n            this.defs.push(this.current[0]);\n          }\n        }\n        for (x = k = 0, ref = this.stepRepeat.x; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {\n          for (y = l = 0, ref1 = this.stepRepeat.y; 0 <= ref1 ? l < ref1 : l > ref1; y = 0 <= ref1 ? ++l : --l) {\n            if (!(x === 0 && y === 0)) {\n              u = {\n                use: {\n                  'xlink:href': \"#\" + srId\n                }\n              };\n              if (x !== 0) {\n                u.use.x = x * this.stepRepeat.i;\n              }\n              if (y !== 0) {\n                u.use.y = y * this.stepRepeat.j;\n              }\n              this.current.push(u);\n            }\n          }\n        }\n        this.layerBbox.xMax += (this.stepRepeat.x - 1) * this.stepRepeat.i;\n        this.layerBbox.yMax += (this.stepRepeat.y - 1) * this.stepRepeat.j;\n      }\n      this.addBbox(this.layerBbox, this.bbox);\n      this.layerBbox = {\n        xMin: Infinity,\n        yMin: Infinity,\n        xMax: -Infinity,\n        yMax: -Infinity\n      };\n      if (this.polarity === 'D') {\n        if (this.group.g.mask != null) {\n          this.current.unshift(this.group);\n        }\n        if ((this.group.g.mask == null) && this.group.g._.length) {\n          ref2 = this.current;\n          for (n = 0, len = ref2.length; n < len; n++) {\n            c = ref2[n];\n            this.group.g._.push(c);\n          }\n        } else {\n          this.group = {\n            g: {\n              _: this.current\n            }\n          };\n        }\n      } else if (this.polarity === 'C' && !this.srOverClear) {\n        id = \"gerber-mask_\" + (unique());\n        w = this.bbox.xMax - this.bbox.xMin;\n        h = this.bbox.yMax - this.bbox.yMin;\n        this.current.unshift({\n          rect: {\n            x: this.bbox.xMin,\n            y: this.bbox.yMin,\n            width: w,\n            height: h,\n            fill: '#fff'\n          }\n        });\n        this.defs.push({\n          mask: {\n            id: id,\n            color: '#000',\n            _: this.current\n          }\n        });\n        this.group.g.mask = \"url(#\" + id + \")\";\n      }\n      return this.current = [];\n    };\n\n    Plotter.prototype.finishPath = function() {\n      var key, p, ref, val;\n      if (this.path.length) {\n        p = {\n          path: {}\n        };\n        if (this.region) {\n          this.path.push('Z');\n        } else {\n          ref = this.tools[this.currentTool].trace;\n          for (key in ref) {\n            val = ref[key];\n            p.path[key] = val;\n          }\n        }\n        p.path.d = this.path;\n        this.current.push(p);\n        return this.path = [];\n      }\n    };\n\n    Plotter.prototype.operate = function(op) {\n      var bbox, ex, ey, k, len, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, shape, sx, sy, t;\n      if (op[\"do\"] === 'last') {\n        op[\"do\"] = this.lastOp;\n        console.warn('modal operation codes are deprecated');\n      } else {\n        this.lastOp = op[\"do\"];\n      }\n      sx = this.pos.x;\n      sy = this.pos.y;\n      if (this.notation === 'I') {\n        this.pos.x += (ref = op.x) != null ? ref : 0;\n        this.pos.y += (ref1 = op.y) != null ? ref1 : 0;\n      } else {\n        this.pos.x = (ref2 = op.x) != null ? ref2 : this.pos.x;\n        this.pos.y = (ref3 = op.y) != null ? ref3 : this.pos.y;\n      }\n      ex = this.pos.x;\n      ey = this.pos.y;\n      t = this.tools[this.currentTool];\n      if (this.units == null) {\n        if (this.backupUnits != null) {\n          this.units = this.backupUnits;\n          console.warn(\"units set to '\" + this.units + \"' according to deprecated command G7\" + (this.units === 'in' ? 0 : 1));\n        } else {\n          this.units = ASSUMED_UNITS;\n          console.warn('no units set; assuming inches');\n        }\n      }\n      if (this.notation == null) {\n        if (((ref4 = this.parser) != null ? ref4.fmat : void 0) != null) {\n          this.notation = 'A';\n        } else {\n          throw new Error('format has not been set');\n        }\n      }\n      if (op[\"do\"] === 'move' && this.path.length) {\n        return this.path.push('M', ex, ey);\n      } else if (op[\"do\"] === 'flash') {\n        this.finishPath();\n        if (this.region) {\n          throw new Error('cannot flash while in region mode');\n        }\n        if (!t.flashed) {\n          ref5 = t.pad;\n          for (k = 0, len = ref5.length; k < len; k++) {\n            shape = ref5[k];\n            this.defs.push(shape);\n          }\n          t.flashed = true;\n        }\n        this.current.push(t.flash(ex, ey));\n        return this.addBbox(t.bbox(ex, ey), this.layerBbox);\n      } else if (op[\"do\"] === 'int') {\n        if (!this.region && !t.trace) {\n          throw new Error(this.currentTool + \" is not a strokable tool\");\n        }\n        if (this.path.length === 0) {\n          this.path.push('M', sx, sy);\n          bbox = !this.region ? t.bbox(sx, sy) : {\n            xMin: sx,\n            yMin: sy,\n            xMax: sx,\n            yMax: sy\n          };\n          this.addBbox(bbox, this.layerBbox);\n        }\n        if (this.mode == null) {\n          this.mode = 'i';\n          console.warn('no interpolation mode set. Assuming linear (G01)');\n        }\n        if (this.mode === 'i') {\n          return this.drawLine(sx, sy, ex, ey);\n        } else {\n          return this.drawArc(sx, sy, ex, ey, (ref6 = op.i) != null ? ref6 : 0, (ref7 = op.j) != null ? ref7 : 0);\n        }\n      }\n    };\n\n    Plotter.prototype.drawLine = function(sx, sy, ex, ey) {\n      var bbox, exm, exp, eym, eyp, halfHeight, halfWidth, sxm, sxp, sym, syp, t, theta;\n      t = this.tools[this.currentTool];\n      bbox = !this.region ? t.bbox(ex, ey) : {\n        xMin: ex,\n        yMin: ey,\n        xMax: ex,\n        yMax: ey\n      };\n      this.addBbox(bbox, this.layerBbox);\n      if (this.region || t.trace['stroke-width'] >= 0) {\n        return this.path.push('L', ex, ey);\n      } else {\n        halfWidth = t.pad[0].rect.width / 2;\n        halfHeight = t.pad[0].rect.height / 2;\n        sxm = sx - halfWidth;\n        sxp = sx + halfWidth;\n        sym = sy - halfHeight;\n        syp = sy + halfHeight;\n        exm = ex - halfWidth;\n        exp = ex + halfWidth;\n        eym = ey - halfHeight;\n        eyp = ey + halfHeight;\n        theta = Math.atan2(ey - sy, ex - sx);\n        if ((0 <= theta && theta < HALF_PI)) {\n          return this.path.push('M', sxm, sym, sxp, sym, exp, eym, exp, eyp, exm, eyp, sxm, syp, 'Z');\n        } else if ((HALF_PI <= theta && theta <= Math.PI)) {\n          return this.path.push('M', sxm, sym, sxp, sym, sxp, syp, exp, eyp, exm, eyp, exm, eym, 'Z');\n        } else if ((-Math.PI <= theta && theta < -HALF_PI)) {\n          return this.path.push('M', sxp, sym, sxp, syp, sxm, syp, exm, eyp, exm, eym, exp, eym, 'Z');\n        } else if ((-HALF_PI <= theta && theta < 0)) {\n          return this.path.push('M', sxm, sym, exm, eym, exp, eym, exp, eyp, sxp, syp, sxm, syp, 'Z');\n        }\n      }\n    };\n\n    Plotter.prototype.drawArc = function(sx, sy, ex, ey, i, j) {\n      var arcEps, c, cand, cen, dist, k, l, large, len, len1, r, rTool, ref, ref1, ref2, sweep, t, theta, thetaE, thetaS, validCen, xMax, xMin, xn, xp, yMax, yMin, yn, yp, zeroLength;\n      arcEps = 1.5 * coordFactor * Math.pow(10, -1 * ((ref = (ref1 = this.parser) != null ? ref1.format.places[1] : void 0) != null ? ref : 7));\n      t = this.tools[this.currentTool];\n      if (!this.region && !t.trace['stroke-width']) {\n        throw Error(\"cannot stroke an arc with non-circular tool \" + this.currentTool);\n      }\n      if (this.quad == null) {\n        throw new Error('arc quadrant mode has not been set');\n      }\n      r = Math.sqrt(Math.pow(i, 2) + Math.pow(j, 2));\n      sweep = this.mode === 'cw' ? 0 : 1;\n      large = 0;\n      validCen = [];\n      cand = [[sx + i, sy + j]];\n      if (this.quad === 's') {\n        cand.push([sx - i, sy - j], [sx - i, sy + j], [sx + i, sy - j]);\n      }\n      for (k = 0, len = cand.length; k < len; k++) {\n        c = cand[k];\n        dist = Math.sqrt(Math.pow(c[0] - ex, 2) + Math.pow(c[1] - ey, 2));\n        if ((Math.abs(r - dist)) < arcEps) {\n          validCen.push({\n            x: c[0],\n            y: c[1]\n          });\n        }\n      }\n      thetaE = 0;\n      thetaS = 0;\n      cen = null;\n      for (l = 0, len1 = validCen.length; l < len1; l++) {\n        c = validCen[l];\n        thetaE = Math.atan2(ey - c.y, ex - c.x);\n        if (thetaE < 0) {\n          thetaE += TWO_PI;\n        }\n        thetaS = Math.atan2(sy - c.y, sx - c.x);\n        if (thetaS < 0) {\n          thetaS += TWO_PI;\n        }\n        if (this.mode === 'cw' && thetaS < thetaE) {\n          thetaS += TWO_PI;\n        } else if (this.mode === 'ccw' && thetaE < thetaS) {\n          thetaE += TWO_PI;\n        }\n        theta = Math.abs(thetaE - thetaS);\n        if (this.quad === 's' && theta <= HALF_PI) {\n          cen = c;\n        } else if (this.quad === 'm') {\n          if (theta >= Math.PI) {\n            large = 1;\n          }\n          cen = {\n            x: c.x,\n            y: c.y\n          };\n        }\n        if (cen != null) {\n          break;\n        }\n      }\n      if (cen == null) {\n        console.warn(\"start \" + sx + \",\" + sy + \" \" + this.mode + \" to end \" + ex + \",\" + ey + \" with center offset \" + i + \",\" + j + \" is an impossible arc in \" + (this.quad === 's' ? 'single' : 'multi') + \" quadrant mode with epsilon set to \" + arcEps);\n        return;\n      }\n      rTool = this.region ? 0 : t.bbox().xMax;\n      if (this.mode === 'cw') {\n        ref2 = [thetaS, thetaE], thetaE = ref2[0], thetaS = ref2[1];\n      }\n      xp = thetaS > 0 ? TWO_PI : 0;\n      yp = HALF_PI + (thetaS > HALF_PI ? TWO_PI : 0);\n      xn = Math.PI + (thetaS > Math.PI ? TWO_PI : 0);\n      yn = THREEHALF_PI + (thetaS > THREEHALF_PI ? TWO_PI : 0);\n      if ((thetaS <= xn && xn <= thetaE)) {\n        xMin = cen.x - r - rTool;\n      } else {\n        xMin = (Math.min(sx, ex)) - rTool;\n      }\n      if ((thetaS <= xp && xp <= thetaE)) {\n        xMax = cen.x + r + rTool;\n      } else {\n        xMax = (Math.max(sx, ex)) + rTool;\n      }\n      if ((thetaS <= yn && yn <= thetaE)) {\n        yMin = cen.y - r - rTool;\n      } else {\n        yMin = (Math.min(sy, ey)) - rTool;\n      }\n      if ((thetaS <= yp && yp <= thetaE)) {\n        yMax = cen.y + r + rTool;\n      } else {\n        yMax = (Math.max(sy, ey)) + rTool;\n      }\n      zeroLength = (Math.abs(sx - ex) < arcEps) && (Math.abs(sy - ey) < arcEps);\n      if (this.quad === 'm' && zeroLength) {\n        this.path.push('A', r, r, 0, 0, sweep, ex + 2 * i, ey + 2 * j);\n        xMin = cen.x - r - rTool;\n        yMin = cen.y - r - rTool;\n        xMax = cen.x + r + rTool;\n        yMax = cen.y + r + rTool;\n      }\n      this.path.push('A', r, r, 0, large, sweep, ex, ey);\n      if (this.quad === 's' && zeroLength) {\n        this.path.push('Z');\n      }\n      return this.addBbox({\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      }, this.layerBbox);\n    };\n\n    Plotter.prototype.addBbox = function(bbox, target) {\n      if (bbox.xMin < target.xMin) {\n        target.xMin = bbox.xMin;\n      }\n      if (bbox.yMin < target.yMin) {\n        target.yMin = bbox.yMin;\n      }\n      if (bbox.xMax > target.xMax) {\n        target.xMax = bbox.xMax;\n      }\n      if (bbox.yMax > target.yMax) {\n        return target.yMax = bbox.yMax;\n      }\n    };\n\n    return Plotter;\n\n  })();\n\n  module.exports = Plotter;\n\n}).call(this);\n\n},{\"./macro-tool\":8,\"./standard-tool\":13,\"./svg-coord\":14,\"./unique-id\":15}],13:[function(require,module,exports){\n(function() {\n  var shapes, standardTool, unique;\n\n  unique = require('./unique-id');\n\n  shapes = require('./pad-shapes');\n\n  standardTool = function(tool, p) {\n    var hole, id, mask, maskId, pad, result, shape;\n    result = {\n      pad: [],\n      trace: false\n    };\n    p.cx = 0;\n    p.cy = 0;\n    id = \"tool-\" + tool + \"-pad-\" + (unique());\n    shape = '';\n    if ((p.dia != null) && (p.verticies == null)) {\n      if ((p.obround != null) || (p.width != null) || (p.height != null) || (p.degrees != null)) {\n        throw new Error(\"incompatible parameters for tool \" + tool);\n      }\n      if (p.dia < 0) {\n        throw new RangeError(tool + \" circle diameter out of range (\" + p.dia + \"<0)\");\n      }\n      shape = 'circle';\n      if (p.hole == null) {\n        result.trace = {\n          'stroke-width': p.dia,\n          fill: 'none'\n        };\n      }\n    } else if ((p.width != null) && (p.height != null)) {\n      if ((p.dia != null) || (p.verticies != null) || (p.degrees != null)) {\n        throw new Error(\"incompatible parameters for tool \" + tool);\n      }\n      if (p.width < 0) {\n        throw new RangeError(tool + \" rect width out of range (\" + p.width + \"<0)\");\n      }\n      if (p.height < 0) {\n        throw new RangeError(tool + \" rect height out of range (\" + p.height + \"<0)\");\n      }\n      shape = 'rect';\n      if ((p.width === 0 || p.height === 0) && !p.obround) {\n        console.warn(\"zero-size rectangle tools are not allowed; converting \" + tool + \" to a zero-size circle\");\n        shape = 'circle';\n        p.dia = 0;\n      }\n      if (!((p.hole != null) || p.obround)) {\n        result.trace = {};\n      }\n    } else if ((p.dia != null) && (p.verticies != null)) {\n      if ((p.obround != null) || (p.width != null) || (p.height != null)) {\n        throw new Error(\"incompatible parameters for tool \" + tool);\n      }\n      if (p.verticies < 3 || p.verticies > 12) {\n        throw new RangeError(tool + \" polygon points out of range (\" + p.verticies + \"<3 or >12)]\");\n      }\n      shape = 'polygon';\n    } else {\n      throw new Error('unidentified standard tool shape');\n    }\n    pad = shapes[shape](p);\n    if (p.hole != null) {\n      hole = null;\n      if ((p.hole.dia != null) && (p.hole.width == null) && (p.hole.height == null)) {\n        if (!(p.hole.dia >= 0)) {\n          throw new RangeError(tool + \" hole diameter out of range (\" + p.hole.dia + \"<0)\");\n        }\n        hole = shapes.circle({\n          cx: p.cx,\n          cy: p.cy,\n          dia: p.hole.dia\n        });\n        hole = hole.shape;\n        hole.circle.fill = '#000';\n      } else if ((p.hole.width != null) && (p.hole.height != null)) {\n        if (!(p.hole.width >= 0)) {\n          throw new RangeError(tool + \" hole width out of range (\" + p.hole.width + \"<0)\");\n        }\n        if (!(p.hole.height >= 0)) {\n          throw new RangeError(tool + \" hole height out of range (\" + p.hole.height + \"<0)\");\n        }\n        hole = shapes.rect({\n          cx: p.cx,\n          cy: p.cy,\n          width: p.hole.width,\n          height: p.hole.height\n        });\n        hole = hole.shape;\n        hole.rect.fill = '#000';\n      } else {\n        throw new Error(tool + \" has invalid hole parameters\");\n      }\n      maskId = id + '-mask';\n      mask = {\n        mask: {\n          id: id + '-mask',\n          _: [\n            {\n              rect: {\n                x: pad.bbox[0],\n                y: pad.bbox[1],\n                width: pad.bbox[2] - pad.bbox[0],\n                height: pad.bbox[3] - pad.bbox[1],\n                fill: '#fff'\n              }\n            }, hole\n          ]\n        }\n      };\n      pad.shape[shape].mask = \"url(#\" + maskId + \")\";\n      result.pad.push(mask);\n    }\n    if (id) {\n      pad.shape[shape].id = id;\n    }\n    result.pad.push(pad.shape);\n    result.bbox = pad.bbox;\n    result.padId = id;\n    return result;\n  };\n\n  module.exports = standardTool;\n\n}).call(this);\n\n},{\"./pad-shapes\":10,\"./unique-id\":15}],14:[function(require,module,exports){\n(function() {\n  var SVG_COORD_E, getSvgCoord,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  SVG_COORD_E = 3;\n\n  getSvgCoord = function(numberString, format) {\n    var after, before, c, i, j, k, len, len1, ref, ref1, ref2, ref3, sign, subNumbers;\n    if (numberString != null) {\n      numberString = \"\" + numberString;\n    } else {\n      return NaN;\n    }\n    before = '';\n    after = '';\n    sign = '+';\n    if (numberString[0] === '-' || numberString[0] === '+') {\n      sign = numberString[0];\n      numberString = numberString.slice(1);\n    }\n    if ((indexOf.call(numberString, '.') >= 0) || (format.zero == null)) {\n      subNumbers = numberString.split('.');\n      if (subNumbers.length > 2) {\n        return NaN;\n      }\n      ref1 = [subNumbers[0], (ref = subNumbers[1]) != null ? ref : ''], before = ref1[0], after = ref1[1];\n    } else {\n      if (typeof (format != null ? (ref2 = format.places) != null ? ref2[0] : void 0 : void 0) !== 'number' || typeof (format != null ? (ref3 = format.places) != null ? ref3[1] : void 0 : void 0) !== 'number') {\n        return NaN;\n      }\n      if (format.zero === 'T') {\n        for (i = j = 0, len = numberString.length; j < len; i = ++j) {\n          c = numberString[i];\n          if (i < format.places[0]) {\n            before += c;\n          } else {\n            after += c;\n          }\n        }\n        while (before.length < format.places[0]) {\n          before += '0';\n        }\n      } else if (format.zero === 'L') {\n        for (i = k = 0, len1 = numberString.length; k < len1; i = ++k) {\n          c = numberString[i];\n          if (numberString.length - i <= format.places[1]) {\n            after += c;\n          } else {\n            before += c;\n          }\n        }\n        while (after.length < format.places[1]) {\n          after = '0' + after;\n        }\n      }\n    }\n    while (after.length < SVG_COORD_E) {\n      after += '0';\n    }\n    before = before + after.slice(0, SVG_COORD_E);\n    after = after.length > SVG_COORD_E ? \".\" + after.slice(SVG_COORD_E) : '';\n    return Number(sign + before + after);\n  };\n\n  module.exports = {\n    get: getSvgCoord,\n    factor: Math.pow(10, SVG_COORD_E)\n  };\n\n}).call(this);\n\n},{}],15:[function(require,module,exports){\n(function() {\n  var generateUniqueId, id;\n\n  id = 1000;\n\n  generateUniqueId = function() {\n    return id++;\n  };\n\n  module.exports = generateUniqueId;\n\n}).call(this);\n\n},{}],16:[function(require,module,exports){\nvar convertGerber, gerberToSvg;\n\ngerberToSvg = require('gerber-to-svg');\n\nconvertGerber = function(filename, gerber) {\n  var e, e2, obj, string, warnings;\n  warnings = [];\n  if (typeof gerber === 'object') {\n    obj = gerber;\n  } else {\n    try {\n      obj = gerberToSvg(gerber, {\n        object: true,\n        warnArr: warnings\n      });\n    } catch (_error) {\n      e = _error;\n      try {\n        warnings = [];\n        obj = gerberToSvg(gerber, {\n          drill: true,\n          object: true,\n          warnArr: warnings\n        });\n      } catch (_error) {\n        e2 = _error;\n        warnings = [];\n        obj = {};\n      }\n    }\n  }\n  if (obj.svg != null) {\n    string = gerberToSvg(obj);\n  } else {\n    string = '';\n  }\n  return {\n    filename: filename,\n    svgObj: obj,\n    svgString: string,\n    warnings: warnings\n  };\n};\n\nself.addEventListener('message', function(e) {\n  var filename, gerber;\n  gerber = e.data.gerber;\n  filename = e.data.filename;\n  return self.postMessage(convertGerber(filename, gerber));\n}, false);\n\n\n\n},{\"gerber-to-svg\":6}]},{},[16])"],{
type:"text/javascript"}))),a=new Worker(window.URL.createObjectURL(new Blob(["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n;(function () {\n\n  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  function InvalidCharacterError(message) {\n    this.message = message;\n  }\n  InvalidCharacterError.prototype = new Error;\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n  // encoder\n  // [https://gist.github.com/999166] by [https://github.com/nignag]\n  object.btoa || (\n  object.btoa = function (input) {\n    var str = String(input);\n    for (\n      // initialize result and counter\n      var block, charCode, idx = 0, map = chars, output = '';\n      // if the next str index does not exist:\n      //   change the mapping table to \"=\"\n      //   check if d has no fractional digits\n      str.charAt(idx | 0) || (map = '=', idx % 1);\n      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n      output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n    ) {\n      charCode = str.charCodeAt(idx += 3/4);\n      if (charCode > 0xFF) {\n        throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n      }\n      block = block << 8 | charCode;\n    }\n    return output;\n  });\n\n  // decoder\n  // [https://gist.github.com/1020396] by [https://github.com/atk]\n  object.atob || (\n  object.atob = function (input) {\n    var str = String(input).replace(/=+$/, '');\n    if (str.length % 4 == 1) {\n      throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    }\n    for (\n      // initialize result and counters\n      var bc = 0, bs, buffer, idx = 0, output = '';\n      // get next character\n      buffer = str.charAt(idx++);\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n        // and if not first of each 4 characters,\n        // convert the first 8 bits to one ascii character\n        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  });\n\n}());\n\n},{}],2:[function(require,module,exports){\nvar Base64;\n\nBase64 = require('Base64');\n\nif (typeof self.btoa !== 'function') {\n  self.btoa = Base64.btoa;\n}\n\nself.addEventListener('message', function(e) {\n  var name, string;\n  string = e.data.string;\n  name = e.data.name;\n  return self.postMessage({\n    name: name,\n    string: btoa(string)\n  });\n});\n\n\n\n},{\"Base64\":1}]},{},[2])"],{type:"text/javascript"}))),t=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return s(n,e),n.prototype.initialize=function(){return this.attachConverterHandler(),this.attachEncoderHandler(),this.on("change:svg change:style",this.encode)},n.prototype.encode=function(e){var n,r,t;return e.set("svg64",!1),r=e.get("svg"),t=e.get("style"),r?(null!=t&&(n=r.match(/^.*?>/)[0].length,r=r.slice(0,n)+t+r.slice(n)),a.postMessage({name:e.get("name"),string:r})):void 0},n.prototype.convert=function(e,n){return o.postMessage({filename:e,gerber:n})},n.prototype.attachEncoderHandler=function(){var e,n;return e=this,n=function(n){var r;return(r=e.findWhere({name:n.data.name}))?r.set("svg64",n.data.string):void 0},a.addEventListener("message",n,!1)},n.prototype.attachConverterHandler=function(){var e,n;return e=this,n=function(n){var r;return(r=e.findWhere({name:n.data.filename}))?(r.set("svgObj",n.data.svgObj),r.set("svg",n.data.svgString),r.set("warnings",n.data.warnings),r.trigger("processEnd",r)):void 0},o.addEventListener("message",n,!1)},n}(Backbone.Collection),n.exports=t},{}],"/Users/mc/cloned/svgerber/src/color-options.coffee":[function(e,n,r){n.exports={cf:{bare:{bg:"#C87533",txt:"white"},gold:{bg:"goldenrod",txt:"white"},"Ni/Au":{bg:"whitesmoke",txt:"black"},hasl:{bg:"silver",txt:"black"}},sm:{red:{bg:"darkred",txt:"white"},orange:{bg:"darkorange",txt:"black"},yellow:{bg:"#FFFF66",txt:"black"},green:{bg:"darkgreen",txt:"white"},blue:{bg:"navy",txt:"white"},purple:{bg:"indigo",txt:"white"},black:{bg:"black",txt:"white"},white:{bg:"white",txt:"black"}},ss:{red:{bg:"red",txt:"white"},yellow:{bg:"yellow",txt:"black"},green:{bg:"green",txt:"white"},blue:{bg:"blue",txt:"white"},black:{bg:"black",txt:"white"},white:{bg:"white",txt:"black"}}}},{}],"/Users/mc/cloned/svgerber/src/github-api-url.coffee":[function(e,n,r){n.exports=function(e){var n,r,t,o,a,s;return e=null!=(a=e.match(/github\.com\S+/))?a[0].split("/"):void 0,(null!=e?e.length:void 0)?(n="https://api.github.com/repos",t=e[1],s=e[2],r=e[4],o=e.slice(5).join("/"),e=n+"/"+t+"/"+s+"/contents/"+o+"?ref="+r):!1}},{}],"/Users/mc/cloned/svgerber/src/identify-layer.coffee":[function(e,n,r){var t,o,a,s,i,l;t=e("./layer-options"),l=/top/i,o=/bottom/i,i=/(silk)|(ss)/i,a=/(soldermask)|(sm)/i,s=/(paste)|(sp)|(pm)/i,n.exports=function(e){var n,r,c,u,p,h,f,d,b;for(b="",n=0,c=t.length;c>n;n++)if(u=t[n],u.match.test(e))return u.val;return e=e.split(".")[0],(r=null!=(p=e.match(l))&&null!=(h=p[0])?h.length:void 0)?b="t":(r=null!=(f=e.match(o))&&null!=(d=f[0])?d.length:void 0)&&(b="b"),i.test(e)?b+="ss":a.test(e)?b+="sm":s.test(e)?b+="sp":e.length===r&&(b+="cu"),_.find(t,{val:b})||(b="drw"),b}},{"./layer-options":"/Users/mc/cloned/svgerber/src/layer-options.coffee"}],"/Users/mc/cloned/svgerber/src/layer-options.coffee":[function(e,n,r){n.exports=[{val:"tcu",desc:"top copper",match:/\.(gtl)|(cmp)$/i,side:"top",mult:!1},{val:"tsm",desc:"top soldermask",match:/\.(gts)|(stc)$/i,side:"top",mult:!1},{val:"tss",desc:"top silkscreen",match:/\.(gto)|(plc)$/i,side:"top",mult:!1},{val:"tsp",desc:"top solderpaste",match:/\.(gtp)|(crc)$/i,side:"top",mult:!1},{val:"bcu",desc:"bottom copper",match:/\.(gbl)|(sol)$/i,side:"bottom",mult:!1},{val:"bsm",desc:"bottom soldermask",match:/\.(gbs)|(sts)$/i,side:"bottom",mult:!1},{val:"bss",desc:"bottom silkscreen",match:/\.(gbo)|(pls)$/i,side:"bottom",mult:!1},{val:"bsp",desc:"bottom solderpaste",match:/\.(gbp)|(crs)$/i,side:"bottom",mult:!1},{val:"icu",desc:"inner copper",match:/\.(gp\d+)|(g\d+l)$/i,side:"none",mult:!0},{val:"out",desc:"board outline",match:/(\.(gko)|(mil)$)|edge/i,side:"both",mult:!1},{val:"drw",desc:"gerber drawing",match:/\.gbr$/i,side:"none",mult:!0},{val:"drl",desc:"drill hits",match:/(\.xln$)|(\.drl$)|(\.txt$)|(\.drd$)/i,side:"both",mult:!0}]},{}],"/Users/mc/cloned/svgerber/src/models/board.coffee":[function(e,n,r){var t,o,a,s,i=function(e,n){function r(){this.constructor=e}for(var t in n)l.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},l={}.hasOwnProperty;a=e("./render"),o=e("../collections/layers"),s=e("../layer-options"),t=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return i(n,e),n.prototype.defaults=_.extend({boardLayers:{},style:'<style type="text/css"> .Board--board { color: dimgrey; } .Board--cu { color: lightgrey; } .Board--cf { color: goldenrod; } .Board--sm { color: darkgreen; opacity: 0.75; } .Board--ss { color: white; } .Board--sp { color: silver; } .Board--out { color: black; } </style>'},a.prototype.defaults),n.prototype.initialize=function(){var e;return e=this.get("layers"),this.listenTo(e,"change:type change:svg change:gerber remove",_.debounce(this.handleLayersChange,10))},n.prototype.getBoardLayers=function(){var e,n;return n=this.get("name"),e=this.get("layers").filter(function(e){var r;return r=_.find(s,{val:e.get("type")}),(null!=r?r.side:void 0)===n||"both"===(null!=r?r.side:void 0)}),this.set("boardLayers",_.map(e,function(e){return{type:e.get("type"),svgObj:e.get("svgObj")}})),this.trigger("buildNeeded",this)},n.prototype.handleLayersChange=function(){var e,n,r;return e=this.get("layers"),e.validateLayers()&&(n=null!=(r=e.filter(function(e){return null!=e.get("svgObj")}))?r:[],e.length===n.length)?this.getBoardLayers():void 0},n}(a),n.exports=t},{"../collections/layers":"/Users/mc/cloned/svgerber/src/collections/layers.coffee","../layer-options":"/Users/mc/cloned/svgerber/src/layer-options.coffee","./render":"/Users/mc/cloned/svgerber/src/models/render.coffee"}],"/Users/mc/cloned/svgerber/src/models/layer.coffee":[function(e,n,r){var t,o,a,s,i=function(e,n){function r(){this.constructor=e}for(var t in n)l.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},l={}.hasOwnProperty;o=e("./render"),s=e("../layer-options"),a=e("../identify-layer"),t=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return i(n,e),n.prototype.defaults=_.extend({gerber:"",type:"drw",svgObj:null},o.prototype.defaults),n.prototype.initialize=function(){return this.once("change:svgObj",function(){return this.unset("gerber"),this.setLayerType()}),this.once("change:warnings",function(){var e,n,r,t,o;for(e={},t=this.get("warnings"),n=0,r=t.length;r>n;n++)o=t[n],e[o]=null!=e[o]?e[o]+1:1;return this.set("warnings",_.map(e,function(e,n){return n+(e>1?" - x"+e:"")})),this.trigger("warningsConsolidated")})},n.prototype.setLayerType=function(){return this.set("type",Object.keys(this.get("svgObj")).length?a(this.get("name")):"oth")},n.prototype.validate=function(e,n){var r;return"oth"===e.type||_.find(s,{val:e.type}).mult||(r=this.collection.where({type:e.type}),1===r.length)?null:"duplicate layer selection"},n}(o),n.exports=t},{"../identify-layer":"/Users/mc/cloned/svgerber/src/identify-layer.coffee","../layer-options":"/Users/mc/cloned/svgerber/src/layer-options.coffee","./render":"/Users/mc/cloned/svgerber/src/models/render.coffee"}],"/Users/mc/cloned/svgerber/src/models/render.coffee":[function(e,n,r){var t,o=function(e,n){function r(){this.constructor=e}for(var t in n)a.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},a={}.hasOwnProperty;t=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return o(n,e),n.prototype.defaults={name:"",svg:"",svgObj:null,svg64:!1,warnings:[]},n}(Backbone.Model),n.exports=t},{}],"/Users/mc/cloned/svgerber/src/routers/router.coffee":[function(e,n,r){var t;t=$("#main-nav").height(),n.exports=Backbone.Router.extend({initialize:function(){return this.route(/.*/,this.scroll)},scroll:function(e){var n,r;return r=Backbone.history.fragment,n="."+r+"-anchor",$("html, body").animate({scrollTop:r?$(n).offset().top-1.15*t:0},300)}})},{}],"/Users/mc/cloned/svgerber/src/views/app-view.coffee":[function(e,n,r){var t,o,a,s,i,l,c,u,p,h,f,d;h=e("../github-api-url"),s=e("./filelist-item"),l=e("./layer-view"),o=e("./board-view"),a=e("./color-picker"),c=e("./modal-view"),u=e("./unsupported-view"),i=e("../collections/layers"),f=new i,t=e("../collections/boards"),p=new t,p.add([{name:"top",layers:f},{name:"bottom",layers:f}]),d=new c,n.exports=Backbone.View.extend({el:"#svgerber-app",events:{"drop #dropzone":"handleFileSelect","dragover #dropzone":function(e){return e.preventDefault(),e.stopPropagation(),e.originalEvent.dataTransfer.dropEffect="copy"},"change #upload-select":"handleFileSelect","click #sample-btn":"loadSamples","click #url-paste-btn":"showPaste","click #url-submit-btn":"processUrls","click #url-cancel-btn":"hidePaste"},initialize:function(){return this.listenTo(f,"add",this.addFilelistItem),this.listenTo(f,"processEnd",this.addBoardLayer),this.listenTo(p,"change:svg",this.addBoardRender),this.listenTo(p,"change:svg",this.handleColorPicker),this.listenTo(f,"add remove",this.handleNavIcons),this.$el.append(d.render().el),this.listenTo(f,"openModal",this.handleOpenModal),this.listenTo(p,"openModal",this.handleOpenModal)},restart:function(){return f.remove(f.models)},addFilelistItem:function(e){var n;return n=new s({model:e}),$("#filelist").append(n.render().el)},addBoardLayer:function(e){var n;return e.get("svg").length?(n=new l({model:e}),$("#layer-output").append(n.render().el)):void 0},addBoardRender:function(e){var n,r;return n=$("#board-output").find(".LayerHeading").text(),e.get("svg").length&&null==n.match(e.get("name"))?(r=new o({model:e}),$("#board-output").append(r.render().el)):void 0},handleOpenModal:function(e){return d.openModal(e)},handleColorPicker:function(e){var n,r,t;return r=$("#board-output").siblings(".ColorPicker").length,n=$("#board-output").children().length,!r&&n?(t=new a({collection:e}),$("#board-output").after(t.render().el)):void 0},handleFileSelect:function(e){var n,r,t,o,a,s,i;for(e.preventDefault(),e.stopPropagation(),t=null!=(s=e.originalEvent)&&null!=(i=s.dataTransfer)?i.files:void 0,null==t&&(t=e.target.files),r=function(e){var n;return f.add({name:e.name},{validate:!0}),n=new FileReader,n.onloadend=function(n){return n.stopPropagation(),n.preventDefault(),n.target.readyState===FileReader.DONE?f.findWhere({name:e.name}).set("gerber",n.target.result):void 0},n.readAsText(e)},o=0,a=t.length;a>o;o++)n=t[o],r(n);return!1},loadSamples:function(){var e,n,r,t,o;for(o=["clockblock-hub-B_Cu.gbl","clockblock-hub-B_Mask.gbs","clockblock-hub-B_SilkS.gbo","clockblock-hub-Edge_Cuts.gbr","clockblock-hub-F_Cu.gtl","clockblock-hub-F_Mask.gts","clockblock-hub-F_Paste.gtp","clockblock-hub-F_SilkS.gto","clockblock-hub-NPTH.drl","clockblock-hub.drl"],this.restart(),r=[],e=0,n=o.length;n>e;e++)t=o[e],r.push(function(e){return f.add({name:e},{validate:!0}),$.ajax({type:"GET",url:"./"+e,dataType:"text",success:function(n){return f.findWhere({name:e}).set("gerber",n)}})}(t));return r},showPaste:function(){return $("#url-paste-form").removeClass("is-hidden")},hidePaste:function(){return $("#url-paste").val(""),$("#url-paste-form").addClass("is-hidden")},processUrls:function(){var e,n,r,t;for(t=$("#url-paste").val().split("\n"),e=0,n=t.length;n>e;e++)r=t[e],r=h(r),r&&$.ajax({type:"GET",url:r,contentType:"application/vnd.github.VERSION.raw",dataType:"json",success:function(e){return f.add({name:e.name},{validate:!0}),f.findWhere({name:e.name}).set("gerber",e.content)}});return this.hidePaste()},handleNavIcons:function(){return 0===f.length?($("#nav-filelist, #nav-output, #nav-layers").addClass("is-disabled"),this.changeIcon($(".Nav--brand"),"octicon-jump-up"),$("#nav-top").off("click",this.restart)):($("#nav-filelist, #nav-output, #nav-layers").removeClass("is-disabled"),this.changeIcon($(".Nav--brand"),"octicon-sync"),$("#nav-top").on("click",this.restart))},changeIcon:function(e,n){return e.removeClass(function(e,n){var r;return null!=(r=n.match(/octicon-\S+/g))?r.join(" "):void 0}).addClass(n)}})},{"../collections/boards":"/Users/mc/cloned/svgerber/src/collections/boards.coffee","../collections/layers":"/Users/mc/cloned/svgerber/src/collections/layers.coffee","../github-api-url":"/Users/mc/cloned/svgerber/src/github-api-url.coffee","./board-view":"/Users/mc/cloned/svgerber/src/views/board-view.coffee","./color-picker":"/Users/mc/cloned/svgerber/src/views/color-picker.coffee","./filelist-item":"/Users/mc/cloned/svgerber/src/views/filelist-item.coffee","./layer-view":"/Users/mc/cloned/svgerber/src/views/layer-view.coffee","./modal-view":"/Users/mc/cloned/svgerber/src/views/modal-view.coffee","./unsupported-view":"/Users/mc/cloned/svgerber/src/views/unsupported-view.coffee"}],"/Users/mc/cloned/svgerber/src/views/board-view.coffee":[function(e,n,r){var t,o,a=function(e,n){function r(){this.constructor=e}for(var t in n)s.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},s={}.hasOwnProperty;o=e("./render-view"),t=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return a(n,e),n.prototype.className="BoardContainer",n.prototype.initialize=function(){return n.__super__.initialize.call(this),this.listenTo(this.model,"change:svg change:style",this.render)},n.prototype.render=function(){var e;return n.__super__.render.call(this),e=this.model.get("svg"),this.$(".LayerTitle").html("board "+this.model.get("name")),this.$("svg").prepend(this.model.get("style")),e.length?this:(this.model.trigger("renderRemove"),this.remove())},n}(o),n.exports=t},{"./render-view":"/Users/mc/cloned/svgerber/src/views/render-view.coffee"}],"/Users/mc/cloned/svgerber/src/views/color-picker.coffee":[function(e,n,r){var t;t=e("../color-options"),n.exports=Backbone.View.extend({tagName:"div",className:"ColorPicker",template:_.template($("#color-picker-template").html()),events:{"click .ColorPicker--btn":"handleColorChange","click #show-color-picker-btn":"toggleColorPicker"},initialize:function(){return this.listenTo(this.collection.collection,"renderRemove",this.handleBoardRemoval)},render:function(){return this.$el.html(this.template({cfColors:t.cf,smColors:t.sm,ssColors:t.ss})),this.$el.find(".ColorPicker--box").addClass("is-retracted"),this.$el.find(".ColorPicker--btn").each(function(){var e,n,r,o;return e=$(this),r=e.parent().attr("id").slice(6,8),o=e.html(),n=t[r][o],e.css("background-color",n.bg).css("color",n.txt)}),this.getCurrentColors(),this},getCurrentColors:function(){var e,n,r,o,a,s,i,l,c,u,p,h;for(e=this.collection.collection.pluck("style"),h=e[0],u=["cf","sm","ss"],p=[],r=0,a=u.length;a>r;r++)o=u[r],c=new RegExp(".Board--"+o+" { color: .*?;"),s=h.match(c),n=s[0].slice(20,-1),l=t[o],i=_.findKey(l,_.find(l,function(e){return e.bg===n})),p.push(this.$el.find("#board-"+o+"-color-buttons").children().each(function(){var e;return(e=$(this)).html()===i?e.prop("disabled",!0):void 0}));return p},handleColorChange:function(e){var n;return n=$(e.currentTarget),n.prop("disabled",!0).siblings().prop("disabled",!1),_.delay(function(e){var r,o,a,s,i;switch(o=n.parent().attr("id").slice(6,8),s=n.html(),r=t[o][s].bg,o){case"cf":a=".Board--cf { color: "+r+"; }",i=/\.Board--cf {.*?}/;break;case"sm":a=".Board--sm { color: "+r+"; opacity: 0.75; }",i=/\.Board--sm {.*?}/;break;case"ss":a=".Board--ss { color: "+r+"; }",i=/\.Board--ss {.*?}/}return e.collection.collection.each(function(e){return e.set("style",e.get("style").replace(i,a))})},10,this)},handleBoardRemoval:function(){var e;return e=!1,this.collection.collection.each(function(n){return n.get("svg").length?e=!0:void 0}),e?void 0:this.remove()},toggleColorPicker:function(){var e,n;return n=$(".ColorPicker--box"),e=$("#show-color-picker-btn").children(".octicon"),n.hasClass("is-retracted")?(n.removeClass("is-retracted"),this.changeIcon(e,"octicon-chevron-up")):n.length?(n.addClass("is-retracted"),this.changeIcon(e,"octicon-chevron-down")):void 0},changeIcon:function(e,n){return e.removeClass(function(e,n){var r;return null!=(r=n.match(/octicon-\S+/g))?r.join(" "):void 0}).addClass(n)}})},{"../color-options":"/Users/mc/cloned/svgerber/src/color-options.coffee"}],"/Users/mc/cloned/svgerber/src/views/filelist-item.coffee":[function(e,n,r){var t;t=e("../layer-options"),n.exports=Backbone.View.extend({tagName:"li",className:"UploadList--item",template:_.template($("#filelist-item-template").html()),events:{"click .UploadList--itemDelete":"removeLayer","change .UploadList--SelectMenu":"changeLayerType","click .UploadList--SelectMenu":function(e){return e.stopPropagation()},click:"showWarnings"},initialize:function(){return this.listenTo(this.model,"remove",this.remove),this.listenTo(this.model,"change:type",this.renderType),this.listenTo(this.model,"valid invalid",this.renderValidation),this.listenToOnce(this.model,"processEnd",this.renderProcessing),this.listenToOnce(this.model,"warningsConsolidated",this.renderWarnings)},renderValidation:function(){var e;return e=this.$el.find(".UploadList--selectIcon"),this.model.validationError?(this.$el.removeClass("is-valid").addClass("is-invalid"),this.changeIcon(e,"octicon-circle-slash")):(this.$el.removeClass("is-invalid").addClass("is-valid"),this.changeIcon(e,"octicon-chevron-right"))},renderProcessing:function(){return null==this.model.get("svgObj")?this.$el.addClass("is-processing"):(this.$el.removeClass("is-processing"),this.model.get("svg")?void 0:(this.$el.addClass("is-unprocessable"),this.$el.find(".UploadList--text").html("did not process"),this.$el.find("select.UploadList--SelectMenu").remove()))},renderWarnings:function(){var e,n,r;return r=this.model.get("warnings"),r.length?(this.$el.addClass("is-warned"),e=this.$(".UploadList--itemWarnings"),e.html(function(){var e,t,o;for(o=[],e=0,t=r.length;t>e;e++)n=r[e],o.push("<li>"+n+"</li>");return o}()),this.$(".UploadList--warningIcon").removeClass("is-hidden")):void 0},showWarnings:function(){return this.model.get("warnings").length?this.$(".UploadList--itemWarningsContainer").toggleClass("is-retracted"):void 0},render:function(){return this.$el.html(this.template({filename:this.model.get("name"),type:this.model.get("type"),options:t})),this.renderType(),this.renderValidation(),this.renderProcessing(),this},renderType:function(){return this.$el.find("option[value='"+this.model.get("type")+"']").prop("selected",!0)},removeLayer:function(){var e;return this.undelegateEvents(),e=this.model,this.$el.animate({height:0},{duration:100,queue:!1,easing:"linear",complete:function(){return e.collection.remove(e)}})},changeLayerType:function(){return this.model.set("type",this.$el.find("option:selected").attr("value"))},changeIcon:function(e,n){return e.removeClass(function(e,n){var r;return null!=(r=n.match(/octicon-\S+/g))?r.join(" "):void 0}).addClass(n)}})},{"../layer-options":"/Users/mc/cloned/svgerber/src/layer-options.coffee"}],"/Users/mc/cloned/svgerber/src/views/layer-view.coffee":[function(e,n,r){var t,o,a,s=function(e,n){function r(){this.constructor=e}for(var t in n)i.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},i={}.hasOwnProperty;o=e("./render-view"),a=e("../layer-options"),t=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return s(n,e),n.prototype.className="LayerContainer",n.prototype.initialize=function(){return n.__super__.initialize.call(this),this.listenTo(this.model,"change:type",this.renderTitle)},n.prototype.renderTitle=function(){return this.$(".LayerTitle").html(_.find(a,{val:this.model.get("type")}).desc)},n.prototype.render=function(){return n.__super__.render.call(this),this.renderTitle(),this},n}(o),n.exports=t},{"../layer-options":"/Users/mc/cloned/svgerber/src/layer-options.coffee","./render-view":"/Users/mc/cloned/svgerber/src/views/render-view.coffee"}],"/Users/mc/cloned/svgerber/src/views/modal-view.coffee":[function(e,n,r){var t,o,a=function(e,n){return function(){return e.apply(n,arguments)}},s=function(e,n){function r(){this.constructor=e}for(var t in n)i.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},i={}.hasOwnProperty;o="undefined"!=typeof document.createElement("a").download,t=function(e){function n(){return this.resize=a(this.resize,this),n.__super__.constructor.apply(this,arguments)}return s(n,e),n.prototype.tagName="div",n.prototype.className="Modal",n.prototype.template=_.template($("#modal-template").html()),n.prototype.events={click:"handleClick"},n.prototype.initialize=function(){return this.closeModal()},n.prototype.render=function(e){var n;return n=null!=e?e.get("svg64"):void 0,this.$el.html(this.template({name:null!=e?e.get("name"):void 0,src:null!=n?"data:image/svg+xml;base64,"+n:"",canDownload:o})),this},n.prototype.resize=function(){var e,n,r,t,o;return e=this.$el.height(),o=this.$el.width(),n=this.$(".Modal--img"),r=n.height(),t=n.width(),o/t>e/r?n.height(.9*e):n.width(.9*o)},n.prototype.openModal=function(e){var n;return this.$el.removeClass("is-hidden"),this.render(e),n=this.$(".Modal--img"),null!=e.get("boardLayers")?n.addClass("Modal--dark"):n.removeClass("Modal--dark"),n.one("load",this.resize)},n.prototype.closeModal=function(){return this.$el.addClass("is-hidden")},n.prototype.handleClick=function(){return this.closeModal()},n}(Backbone.View),n.exports=t},{}],"/Users/mc/cloned/svgerber/src/views/render-view.coffee":[function(e,n,r){var t,o,a=function(e,n){function r(){this.constructor=e}for(var t in n)s.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},s={}.hasOwnProperty;o="undefined"!=typeof document.createElement("a").download,t=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return a(n,e),n.prototype.tagName="div",n.prototype.template=_.template($("#board-layer-template").html()),n.prototype.events={"click .Btn--download":"handleDownloadClick","click .LayerDrawing":"handleClick"},n.prototype.initialize=function(){return this.listenTo(this.model,"change:svg64",this.handleDownloadLink),this.listenTo(this.model,"remove",this.remove)},n.prototype.handleDownloadClick=function(e){return o?void 0:(e.preventDefault(),e.stopPropagation(),this.handleClick())},n.prototype.handleClick=function(e){return this.model.trigger("openModal",this.model)},n.prototype.render=function(){return this.$el.html(this.template({name:this.model.get("name"),img:this.model.get("svg")})),this.resize(),this},n.prototype.resize=function(){var e,n,r,t;return n=this.$("svg")[0],null!=n?(t=n.width.baseVal.value,r=n.height.baseVal.value,e=r/t,this.$(".LayerDrawing").css("padding-bottom",100*e+"%")):void 0},n.prototype.handleDownloadLink=function(){var e,n;return e=this.$(".Btn--download"),n=this.model.get("svg64"),n?(o&&e.attr("href","data:image/svg+xml;base64,"+n),e.removeClass("is-disabled")):e.addClass("is-disabled")},n}(Backbone.View),n.exports=t},{}],"/Users/mc/cloned/svgerber/src/views/unsupported-view.coffee":[function(e,n,r){var t,o,a=function(e,n){function r(){this.constructor=e}for(var t in n)s.call(n,t)&&(e[t]=n[t]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e},s={}.hasOwnProperty;o="undefined"!=typeof document.createElement("a").download,t=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return a(n,e),n.prototype.tagName="div",n.prototype.className="Unsupported",n.prototype.template=_.template($("#unsupported-template").html()),n.prototype.events={"click .Unsupported--btn":"tryAnyway"},n.prototype.render=function(){return this.$el.html(this.template()),this},n.prototype.tryAnyway=function(){return this.$el.remove()},n}(Backbone.View),n.exports=t},{}]},{},["./src/index.coffee"]);